# Task 07.06: Extract Form Input Patterns

**Status**: ðŸ“‹ **PLANNED** (OPTIONAL)
**Parent Task**: [Task 07 - UI Components](../07-ui-components.md)
**Track**: B - Refactoring (Optional)
**Priority**: Low
**Estimated Duration**: 60 minutes
**Dependencies**: Task 07.01 (auth components documented)
**Deliverable**: Reusable form components and useForm hook

---

## Objective

Extract repeated form patterns from Login, Register, ForgotPassword, and Profile pages into reusable components and a custom form validation hook.

---

## Current State Analysis

### Repeated Form Patterns Identified

**Input Field with Label and Error**:
- Used in: Login, Register, ForgotPassword, Profile
- Pattern: Label â†’ Input â†’ Error message
- Repeated ~15 times across 4 pages

**Password Input with Toggle**:
- Used in: Login, Register, Profile
- Pattern: Input with show/hide password button
- Repeated 6 times

**Form Validation Logic**:
- Used in: All auth pages + Profile
- Pattern: useState for errors, validation functions, onBlur/onSubmit handlers
- ~100 lines of duplicated code

**Submit Button with Loading**:
- Used in: All auth pages + many feature pages
- Pattern: Button with loading spinner and disabled state
- Repeated ~10 times

---

## Components to Create

### 1. FormField Component

**Purpose**: Unified form field with label, input, and error display

**File**: `/src/components/forms/FormField.tsx`

**Interface**:
```typescript
interface FormFieldProps {
  label: string;
  name: string;
  type?: 'text' | 'email' | 'password' | 'tel' | 'number' | 'url';
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
  error?: string;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  autoComplete?: string;
  inputMode?: 'text' | 'email' | 'tel' | 'numeric' | 'decimal' | 'url' | 'search';
  className?: string;
  helperText?: string;
}
```

**Implementation**:
```typescript
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { AlertCircleIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

export function FormField({
  label,
  name,
  type = 'text',
  value,
  onChange,
  onBlur,
  error,
  placeholder,
  required = false,
  disabled = false,
  autoComplete,
  inputMode,
  className,
  helperText
}: FormFieldProps) {
  const hasError = !!error;

  return (
    <div className={cn('space-y-2', className)}>
      <Label htmlFor={name} className="flex items-center gap-1">
        {label}
        {required && <span className="text-red-500">*</span>}
      </Label>

      <Input
        id={name}
        name={name}
        type={type}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onBlur={onBlur}
        placeholder={placeholder}
        disabled={disabled}
        autoComplete={autoComplete}
        inputMode={inputMode}
        aria-invalid={hasError}
        aria-describedby={hasError ? `${name}-error` : helperText ? `${name}-helper` : undefined}
        className={cn(
          'text-base', // Prevent iOS zoom
          hasError && 'border-red-500 focus-visible:ring-red-500'
        )}
      />

      {helperText && !error && (
        <p id={`${name}-helper`} className="text-sm text-muted">
          {helperText}
        </p>
      )}

      {error && (
        <p id={`${name}-error`} className="text-sm text-red-600 flex items-center gap-1">
          <AlertCircleIcon className="h-4 w-4" />
          {error}
        </p>
      )}
    </div>
  );
}
```

**Usage**:
```tsx
import { FormField } from '@/components/forms/FormField';

<FormField
  label="Email address"
  name="email"
  type="email"
  value={email}
  onChange={setEmail}
  error={errors.email}
  placeholder="name@example.com"
  required
  autoComplete="email"
  inputMode="email"
/>
```

---

### 2. PasswordField Component

**Purpose**: Password input with show/hide toggle

**File**: `/src/components/forms/PasswordField.tsx`

**Implementation**:
```typescript
import { useState } from 'react';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { EyeIcon, EyeOffIcon, AlertCircleIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface PasswordFieldProps {
  label: string;
  name: string;
  value: string;
  onChange: (value: string) => void;
  onBlur?: () => void;
  error?: string;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  autoComplete?: string;
  showStrength?: boolean;
  className?: string;
}

export function PasswordField({
  label,
  name,
  value,
  onChange,
  onBlur,
  error,
  placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢',
  required = false,
  disabled = false,
  autoComplete = 'current-password',
  showStrength = false,
  className
}: PasswordFieldProps) {
  const [showPassword, setShowPassword] = useState(false);
  const hasError = !!error;

  // Password strength calculation
  const getPasswordStrength = (pwd: string): { level: number; label: string; color: string } => {
    if (!pwd) return { level: 0, label: '', color: '' };
    if (pwd.length < 8) return { level: 1, label: 'Weak', color: 'bg-red-500' };

    const hasUpper = /[A-Z]/.test(pwd);
    const hasLower = /[a-z]/.test(pwd);
    const hasNumber = /[0-9]/.test(pwd);
    const hasSpecial = /[^A-Za-z0-9]/.test(pwd);

    const strength = [hasUpper, hasLower, hasNumber, hasSpecial].filter(Boolean).length;

    if (strength >= 3) return { level: 3, label: 'Strong', color: 'bg-green-500' };
    if (strength >= 2) return { level: 2, label: 'Medium', color: 'bg-yellow-500' };
    return { level: 1, label: 'Weak', color: 'bg-red-500' };
  };

  const strength = showStrength ? getPasswordStrength(value) : null;

  return (
    <div className={cn('space-y-2', className)}>
      <Label htmlFor={name} className="flex items-center gap-1">
        {label}
        {required && <span className="text-red-500">*</span>}
      </Label>

      <div className="relative">
        <Input
          id={name}
          name={name}
          type={showPassword ? 'text' : 'password'}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onBlur={onBlur}
          placeholder={placeholder}
          disabled={disabled}
          autoComplete={autoComplete}
          aria-invalid={hasError}
          aria-describedby={hasError ? `${name}-error` : undefined}
          className={cn(
            'pr-10 text-base',
            hasError && 'border-red-500 focus-visible:ring-red-500'
          )}
        />

        <Button
          type="button"
          variant="ghost"
          size="sm"
          className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
          onClick={() => setShowPassword(!showPassword)}
          disabled={disabled}
          aria-label={showPassword ? 'Hide password' : 'Show password'}
        >
          {showPassword ? (
            <EyeOffIcon className="h-4 w-4 text-muted" />
          ) : (
            <EyeIcon className="h-4 w-4 text-muted" />
          )}
        </Button>
      </div>

      {showStrength && value && strength && (
        <div className="flex items-center gap-2">
          <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
            <div
              className={cn('h-full transition-all duration-300', strength.color)}
              style={{ width: `${(strength.level / 3) * 100}%` }}
            />
          </div>
          <span className="text-xs text-muted min-w-[60px]">{strength.label}</span>
        </div>
      )}

      {error && (
        <p id={`${name}-error`} className="text-sm text-red-600 flex items-center gap-1">
          <AlertCircleIcon className="h-4 w-4" />
          {error}
        </p>
      )}
    </div>
  );
}
```

**Usage**:
```tsx
import { PasswordField } from '@/components/forms/PasswordField';

// Login page
<PasswordField
  label="Password"
  name="password"
  value={password}
  onChange={setPassword}
  error={errors.password}
  required
/>

// Register page with strength indicator
<PasswordField
  label="Password"
  name="password"
  value={password}
  onChange={setPassword}
  error={errors.password}
  required
  showStrength
  autoComplete="new-password"
/>
```

---

### 3. SubmitButton Component

**Purpose**: Submit button with consistent loading state

**File**: `/src/components/forms/SubmitButton.tsx`

**Implementation**:
```typescript
import { Button, ButtonProps } from '@/components/ui/button';
import { LoaderIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SubmitButtonProps extends Omit<ButtonProps, 'type'> {
  loading?: boolean;
  loadingText?: string;
  children: React.ReactNode;
}

export function SubmitButton({
  loading = false,
  loadingText = 'Processing...',
  children,
  disabled,
  className,
  ...props
}: SubmitButtonProps) {
  return (
    <Button
      type="submit"
      disabled={loading || disabled}
      className={cn('w-full md:w-auto', className)}
      {...props}
    >
      {loading ? (
        <>
          <LoaderIcon className="mr-2 h-4 w-4 animate-spin" />
          {loadingText}
        </>
      ) : (
        children
      )}
    </Button>
  );
}
```

**Usage**:
```tsx
import { SubmitButton } from '@/components/forms/SubmitButton';

<SubmitButton loading={isSubmitting} loadingText="Signing in...">
  Sign in
</SubmitButton>
```

---

### 4. useForm Hook

**Purpose**: Reusable form state and validation logic

**File**: `/src/hooks/useForm.ts`

**Implementation**:
```typescript
import { useState, useCallback } from 'react';

interface ValidationRules<T> {
  [K in keyof T]?: {
    required?: boolean | string;
    minLength?: { value: number; message: string };
    maxLength?: { value: number; message: string };
    pattern?: { value: RegExp; message: string };
    validate?: (value: T[K]) => string | undefined;
  };
}

interface UseFormProps<T> {
  initialValues: T;
  validationRules?: ValidationRules<T>;
  onSubmit: (values: T) => void | Promise<void>;
}

export function useForm<T extends Record<string, any>>({
  initialValues,
  validationRules = {},
  onSubmit
}: UseFormProps<T>) {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const validateField = useCallback(
    (name: keyof T, value: any): string | undefined => {
      const rules = validationRules[name];
      if (!rules) return undefined;

      // Required validation
      if (rules.required) {
        if (!value || (typeof value === 'string' && !value.trim())) {
          return typeof rules.required === 'string' ? rules.required : `${String(name)} is required`;
        }
      }

      // Min length validation
      if (rules.minLength && typeof value === 'string') {
        if (value.length < rules.minLength.value) {
          return rules.minLength.message;
        }
      }

      // Max length validation
      if (rules.maxLength && typeof value === 'string') {
        if (value.length > rules.maxLength.value) {
          return rules.maxLength.message;
        }
      }

      // Pattern validation
      if (rules.pattern && typeof value === 'string') {
        if (!rules.pattern.value.test(value)) {
          return rules.pattern.message;
        }
      }

      // Custom validation
      if (rules.validate) {
        return rules.validate(value);
      }

      return undefined;
    },
    [validationRules]
  );

  const validateAllFields = useCallback((): boolean => {
    const newErrors: Partial<Record<keyof T, string>> = {};

    Object.keys(validationRules).forEach((key) => {
      const error = validateField(key as keyof T, values[key]);
      if (error) {
        newErrors[key as keyof T] = error;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [values, validateField, validationRules]);

  const handleChange = useCallback((name: keyof T, value: any) => {
    setValues((prev) => ({ ...prev, [name]: value }));

    // Clear error when user starts typing
    setErrors((prev) => ({ ...prev, [name]: undefined }));
  }, []);

  const handleBlur = useCallback(
    (name: keyof T) => {
      setTouched((prev) => ({ ...prev, [name]: true }));

      const error = validateField(name, values[name]);
      if (error) {
        setErrors((prev) => ({ ...prev, [name]: error }));
      }
    },
    [values, validateField]
  );

  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      if (e) e.preventDefault();

      const isValid = validateAllFields();
      if (!isValid) return;

      setIsSubmitting(true);
      try {
        await onSubmit(values);
      } catch (error) {
        // Error handling done by caller
      } finally {
        setIsSubmitting(false);
      }
    },
    [values, validateAllFields, onSubmit]
  );

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
    setError: (name: keyof T, message: string) => {
      setErrors((prev) => ({ ...prev, [name]: message }));
    }
  };
}
```

**Usage**:
```tsx
import { useForm } from '@/hooks/useForm';

function LoginPage() {
  const { values, errors, handleChange, handleBlur, handleSubmit, isSubmitting } = useForm({
    initialValues: { email: '', password: '', remember: false },
    validationRules: {
      email: {
        required: 'Email is required',
        pattern: {
          value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
          message: 'Invalid email format'
        }
      },
      password: {
        required: 'Password is required',
        minLength: { value: 8, message: 'Password must be at least 8 characters' }
      }
    },
    onSubmit: async (values) => {
      await authStore.login(values.email, values.password, values.remember);
      navigate('/dashboard');
    }
  });

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <FormField
        label="Email"
        name="email"
        type="email"
        value={values.email}
        onChange={(value) => handleChange('email', value)}
        onBlur={() => handleBlur('email')}
        error={errors.email}
        required
      />

      <PasswordField
        label="Password"
        name="password"
        value={values.password}
        onChange={(value) => handleChange('password', value)}
        onBlur={() => handleBlur('password')}
        error={errors.password}
        required
      />

      <SubmitButton loading={isSubmitting} loadingText="Signing in...">
        Sign in
      </SubmitButton>
    </form>
  );
}
```

---

## Implementation Steps

### Step 1: Create Form Components (30 min)

1. Create `/src/components/forms/` directory
2. Implement FormField component
3. Implement PasswordField component
4. Implement SubmitButton component
5. Create barrel export `/src/components/forms/index.ts`

### Step 2: Create useForm Hook (15 min)

1. Implement useForm hook in `/src/hooks/useForm.ts`
2. Add validation logic
3. Test with one page (Login)

### Step 3: Refactor Existing Pages (15 min)

1. Update Login page to use new components
2. Update Register page
3. Update ForgotPassword page
4. Remove duplicated code

---

## Success Criteria

- [ ] FormField component created and tested
- [ ] PasswordField component created with toggle functionality
- [ ] SubmitButton component created with loading state
- [ ] useForm hook implemented with validation
- [ ] Login page refactored to use new components
- [ ] Register page refactored
- [ ] ForgotPassword page refactored
- [ ] Code duplication reduced by ~70%
- [ ] All existing functionality preserved
- [ ] No regressions in form behavior
- [ ] Form components documented in Components-Reference.md

---

## Testing Checklist

- [ ] Form validation works on blur
- [ ] Form validation works on submit
- [ ] Error messages display correctly
- [ ] Password toggle works
- [ ] Password strength indicator works (register)
- [ ] Submit button shows loading state
- [ ] Submit button disabled during submission
- [ ] Form resets after successful submission
- [ ] Accessibility: Tab order correct
- [ ] Accessibility: ARIA attributes present
- [ ] Mobile: No iOS zoom on input focus (font-size â‰¥ 16px)

---

## Time Breakdown

| Activity | Duration |
|----------|----------|
| Create FormField component | 10 min |
| Create PasswordField component | 10 min |
| Create SubmitButton component | 5 min |
| Create barrel exports | 5 min |
| Implement useForm hook | 15 min |
| Refactor Login page | 5 min |
| Refactor Register page | 5 min |
| Refactor ForgotPassword page | 5 min |
| **TOTAL** | **60 min** |

---

## Benefits

**Code Reduction**:
- Eliminates ~100 lines of duplicated validation logic
- Eliminates ~50 lines of duplicated JSX
- Total reduction: ~150 lines across 4 pages

**Maintainability**:
- Single source of truth for form styling
- Consistent validation behavior
- Easier to add new form fields
- Centralized error handling

**User Experience**:
- Consistent form behavior across pages
- Better accessibility out of the box
- Mobile-optimized inputs

---

## Next Steps

After completion:
1. Consider extending to Profile page forms
2. Add more validation rules (match password, phone number, etc.)
3. Add form analytics (track validation errors)
4. Document form patterns in Style Guide
