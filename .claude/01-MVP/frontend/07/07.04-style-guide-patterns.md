# Task 07.04: Add Missing Style Guide Patterns

**Status**: üìã **PLANNED**
**Parent Task**: [Task 07 - UI Components](../07-ui-components.md)
**Priority**: High
**Estimated Duration**: 180 minutes (3 hours)
**Dependencies**: Task 07.01, 07.02, 07.03 (for component references)
**Deliverable**: Updated Style-Guide.md with 5 new design pattern categories

---

## Objective

Add 5 missing design pattern categories to the Style-Guide.md, providing comprehensive guidance on authentication UI, protected routes, modal dialogs, mobile-specific patterns, and loading/empty states.

---

## Missing Pattern Categories

### 07.04a: Authentication UI Patterns (45 min)
Form layouts, input fields, error handling, validation feedback for login/register/forgot password pages.

### 07.04b: Protected Route Patterns (30 min)
Route guard implementation, redirect behavior, session management, and authentication flow patterns.

### 07.04c: Modal Dialog Patterns (45 min)
Confirmation dialogs, destructive actions, form modals, and overlay behavior patterns.

### 07.04d: Mobile-Specific Patterns (30 min)
Mobile navigation, touch interactions, responsive breakpoints, and mobile-first considerations.

### 07.04e: Loading/Empty State Patterns (30 min)
Skeleton loading, empty states, error states, and progressive loading patterns.

---

## Implementation Steps

### Step 1: Read Existing Style Guide Structure (10 min)

Understand the current pattern organization:
```bash
# Read Style Guide to understand structure
cat /Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/frontend/Style-Guide.md
```

Current sections:
- Design Strategy
- Color Palette
- Typography
- Spacing & Layout
- Component Patterns (6 categories documented)
- Animation & Transitions
- Accessibility
- Responsive Design

**Insert new patterns** in "Component Patterns" section.

---

### Step 2: 07.04a - Authentication UI Patterns (45 min)

Add comprehensive auth UI patterns section.

```markdown
## Authentication UI Patterns

### Form Layout Pattern

All authentication forms (Login, Register, ForgotPassword) follow a consistent vertical layout with centered alignment.

**Structure**:
```tsx
<div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
  <div className="max-w-md w-full space-y-8">
    {/* Logo/Brand */}
    <div className="text-center">
      <h1 className="text-3xl font-bold text-primary">App Name</h1>
      <p className="mt-2 text-sm text-muted">Welcome back!</p>
    </div>

    {/* Form Card */}
    <Card className="p-8">
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Form fields */}
      </form>
    </Card>

    {/* Footer Links */}
    <div className="text-center text-sm">
      <Link to="/register" className="text-primary hover:underline">
        Don't have an account? Sign up
      </Link>
    </div>
  </div>
</div>
```

**Key Principles**:
- Centered card with max-width of 28rem (448px)
- Consistent vertical spacing (space-y-6, space-y-8)
- Light background (#f8f9fa) for contrast
- Logo/brand at top for context
- Footer links for navigation between auth pages

---

### Input Field Pattern

Authentication forms use consistent input styling with labels, error states, and icons.

**Basic Input Field**:
```tsx
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';

<div className="space-y-2">
  <Label htmlFor="email">Email address</Label>
  <Input
    id="email"
    type="email"
    placeholder="name@example.com"
    value={email}
    onChange={(e) => setEmail(e.target.value)}
    className={errors.email ? 'border-red-500 focus:ring-red-500' : ''}
    aria-invalid={!!errors.email}
    aria-describedby={errors.email ? 'email-error' : undefined}
  />
  {errors.email && (
    <p id="email-error" className="text-sm text-red-600 mt-1">
      {errors.email}
    </p>
  )}
</div>
```

**Password Input with Toggle**:
```tsx
import { useState } from 'react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { EyeIcon, EyeOffIcon } from 'lucide-react';

const [showPassword, setShowPassword] = useState(false);

<div className="space-y-2">
  <Label htmlFor="password">Password</Label>
  <div className="relative">
    <Input
      id="password"
      type={showPassword ? 'text' : 'password'}
      value={password}
      onChange={(e) => setPassword(e.target.value)}
      className="pr-10"
    />
    <Button
      type="button"
      variant="ghost"
      size="sm"
      className="absolute right-0 top-0 h-full px-3"
      onClick={() => setShowPassword(!showPassword)}
      aria-label={showPassword ? 'Hide password' : 'Show password'}
    >
      {showPassword ? (
        <EyeOffIcon className="h-4 w-4" />
      ) : (
        <EyeIcon className="h-4 w-4" />
      )}
    </Button>
  </div>
</div>
```

**Input Field States**:
- **Default**: Border gray-300, focus ring primary
- **Error**: Border red-500, focus ring red-500, error message below
- **Success**: Border green-500 (optional, for validation feedback)
- **Disabled**: Opacity 50%, cursor not-allowed

---

### Error Handling Pattern

Display validation errors inline below inputs and general errors at top of form.

**Inline Field Errors**:
```tsx
<Input
  id="email"
  type="email"
  aria-invalid={!!errors.email}
  aria-describedby="email-error"
  className={errors.email ? 'border-red-500' : ''}
/>
{errors.email && (
  <p id="email-error" className="text-sm text-red-600 mt-1 flex items-center gap-1">
    <AlertCircleIcon className="h-4 w-4" />
    {errors.email}
  </p>
)}
```

**General Form Error** (API errors, network issues):
```tsx
import { Alert } from '@/components/ui/alert';
import { AlertCircleIcon } from 'lucide-react';

{error && (
  <Alert variant="destructive" className="mb-4">
    <AlertCircleIcon className="h-4 w-4" />
    <AlertTitle>Error</AlertTitle>
    <AlertDescription>{error}</AlertDescription>
  </Alert>
)}
```

**Success Message**:
```tsx
import { CheckCircleIcon } from 'lucide-react';

{success && (
  <Alert variant="default" className="mb-4 border-green-500 bg-green-50">
    <CheckCircleIcon className="h-4 w-4 text-green-600" />
    <AlertDescription className="text-green-800">
      {success}
    </AlertDescription>
  </Alert>
)}
```

---

### Submit Button Pattern

Submit buttons show loading state and are disabled during submission.

**Pattern**:
```tsx
import { Button } from '@/components/ui/button';
import { LoaderIcon } from 'lucide-react';

<Button
  type="submit"
  className="w-full"
  disabled={loading}
>
  {loading ? (
    <>
      <LoaderIcon className="mr-2 h-4 w-4 animate-spin" />
      Signing in...
    </>
  ) : (
    'Sign in'
  )}
</Button>
```

**States**:
- **Default**: Full width, primary variant
- **Loading**: Spinner icon, disabled, "Processing..." text
- **Disabled**: Opacity 50%, cursor not-allowed
- **Success**: Brief success state before redirect (optional)

---

### Validation Pattern

Client-side validation runs on blur and submit.

**Validation Rules**:
```typescript
// Email validation
const isValidEmail = (email: string) => {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
};

// Password validation
const isValidPassword = (password: string) => {
  return password.length >= 8;
};

// Password strength (for registration)
const getPasswordStrength = (password: string): 'weak' | 'medium' | 'strong' => {
  if (password.length < 8) return 'weak';
  const hasUpper = /[A-Z]/.test(password);
  const hasLower = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[^A-Za-z0-9]/.test(password);

  const strength = [hasUpper, hasLower, hasNumber, hasSpecial].filter(Boolean).length;
  if (strength >= 3) return 'strong';
  if (strength >= 2) return 'medium';
  return 'weak';
};
```

**Validation Trigger Pattern**:
```tsx
const [errors, setErrors] = useState<Record<string, string>>({});
const [touched, setTouched] = useState<Record<string, boolean>>({});

// Validate single field
const validateField = (name: string, value: string) => {
  let error = '';

  if (name === 'email') {
    if (!value) error = 'Email is required';
    else if (!isValidEmail(value)) error = 'Invalid email format';
  }

  if (name === 'password') {
    if (!value) error = 'Password is required';
    else if (value.length < 8) error = 'Password must be at least 8 characters';
  }

  setErrors(prev => ({ ...prev, [name]: error }));
  return !error;
};

// Validate on blur
const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
  const { name, value } = e.target;
  setTouched(prev => ({ ...prev, [name]: true }));
  validateField(name, value);
};

// Validate all on submit
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();

  const isEmailValid = validateField('email', email);
  const isPasswordValid = validateField('password', password);

  if (!isEmailValid || !isPasswordValid) return;

  // Submit form
};
```

**Password Strength Indicator** (Registration only):
```tsx
<div className="space-y-1">
  <Label htmlFor="password">Password</Label>
  <Input
    id="password"
    type="password"
    value={password}
    onChange={(e) => setPassword(e.target.value)}
  />

  {password && (
    <div className="flex items-center gap-2 mt-2">
      <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
        <div
          className={cn(
            "h-full transition-all duration-300",
            {
              'w-1/3 bg-red-500': strength === 'weak',
              'w-2/3 bg-yellow-500': strength === 'medium',
              'w-full bg-green-500': strength === 'strong'
            }
          )}
        />
      </div>
      <span className="text-xs text-muted capitalize">{strength}</span>
    </div>
  )}
</div>
```

---

### Social Login Pattern (Future Enhancement)

Placeholder for social authentication buttons.

**Pattern**:
```tsx
<div className="space-y-3">
  <div className="relative">
    <div className="absolute inset-0 flex items-center">
      <Separator />
    </div>
    <div className="relative flex justify-center text-xs uppercase">
      <span className="bg-white px-2 text-muted">Or continue with</span>
    </div>
  </div>

  <div className="grid grid-cols-2 gap-3">
    <Button variant="outline" onClick={handleGoogleLogin}>
      <GoogleIcon className="mr-2 h-4 w-4" />
      Google
    </Button>
    <Button variant="outline" onClick={handleFacebookLogin}>
      <FacebookIcon className="mr-2 h-4 w-4" />
      Facebook
    </Button>
  </div>
</div>
```

---

### When to Use

- **Login Page**: Email + password, remember me, forgot password link
- **Registration Page**: Email + password + name, password strength indicator, terms acceptance
- **Forgot Password Page**: Email only, success message with next steps
- **Change Password**: Current password + new password + confirm password

### Accessibility Considerations

- All inputs have associated labels (htmlFor + id)
- Error messages linked with aria-describedby
- Invalid inputs marked with aria-invalid
- Submit button disabled during loading (prevents double-submit)
- Focus management: Focus first input on mount, focus first error on validation
- Keyboard navigation: Tab through inputs, Enter to submit

### Related Components

- [Login](#login) - Login page implementation
- [Register](#register) - Registration page implementation
- [ForgotPassword](#forgotpassword) - Password reset page
- [Input](#input) - Shadcn input component
- [Button](#button) - Shadcn button component
- [Alert](#alert) - Error/success message component
```

---

### Step 3: 07.04b - Protected Route Patterns (30 min)

Add route protection and session management patterns.

```markdown
## Protected Route Patterns

### Route Guard Implementation

All authenticated routes use `ProtectedRoute` component to enforce authentication.

**Basic Pattern**:
```tsx
import { ProtectedRoute } from '@/components/auth/ProtectedRoute';
import { AppLayout } from '@/components/layout/AppLayout';

// In App.tsx route configuration
<Route path="/dashboard" element={
  <ProtectedRoute>
    <AppLayout>
      <Dashboard />
    </AppLayout>
  </ProtectedRoute>
} />
```

**With Custom Redirect**:
```tsx
<Route path="/settings" element={
  <ProtectedRoute redirectTo="/login?returnUrl=/settings">
    <AppLayout>
      <Settings />
    </AppLayout>
  </ProtectedRoute>
} />
```

---

### Public Route Pattern

Authentication pages use `PublicRoute` to redirect already-authenticated users.

**Pattern**:
```tsx
import { PublicRoute } from '@/components/auth/PublicRoute';
import { AuthLayout } from '@/components/auth/AuthLayout';

<Route path="/login" element={
  <PublicRoute redirectTo="/dashboard">
    <AuthLayout>
      <Login />
    </AuthLayout>
  </PublicRoute>
} />
```

**Logic**:
- If user is authenticated ‚Üí Redirect to dashboard
- If user is not authenticated ‚Üí Show login page
- Prevents authenticated users from accessing login/register pages

---

### Session Management Pattern

Monitor session expiration and show warning dialog.

**Implementation**:
```tsx
import { useEffect, useState } from 'react';
import { useAuthStore } from '@/store/authStore';
import { SessionWarningDialog } from '@/components/auth/SessionWarningDialog';

function AppLayout({ children }: { children: React.ReactNode }) {
  const { sessionExpiresAt, extendSession, logout } = useAuthStore();
  const [showWarning, setShowWarning] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState(0);

  useEffect(() => {
    // Check session every minute
    const checkInterval = setInterval(() => {
      const remaining = sessionExpiresAt - Date.now();
      const remainingMinutes = Math.floor(remaining / 1000 / 60);

      if (remainingMinutes <= 5 && remainingMinutes > 0) {
        setShowWarning(true);
        setTimeRemaining(Math.floor(remaining / 1000));
      } else if (remainingMinutes <= 0) {
        logout();
      }
    }, 60000);

    return () => clearInterval(checkInterval);
  }, [sessionExpiresAt, logout]);

  return (
    <>
      {children}

      <SessionWarningDialog
        open={showWarning}
        onClose={() => setShowWarning(false)}
        onExtend={() => {
          extendSession();
          setShowWarning(false);
        }}
        timeRemaining={timeRemaining}
      />
    </>
  );
}
```

**Session Warning Timing**:
- Show warning: 5 minutes before expiration
- Auto-logout: On expiration
- Session extension: Adds 30 minutes (configurable)

---

### Authentication Flow

**Login Flow**:
1. User enters credentials on Login page
2. Submit ‚Üí Call `authStore.login(email, password)`
3. Store sets `isAuthenticated = true` and `sessionExpiresAt`
4. PublicRoute detects authentication ‚Üí Redirects to dashboard
5. ProtectedRoute allows access to dashboard

**Logout Flow**:
1. User clicks logout in UserMenu
2. LogoutDialog appears for confirmation
3. User confirms ‚Üí Call `authStore.logout()`
4. Store clears auth state
5. ProtectedRoute detects no authentication ‚Üí Redirects to login

**Session Expiration Flow**:
1. Session approaches expiration (5 min remaining)
2. SessionWarningDialog appears
3. User can extend session or ignore
4. If ignored ‚Üí Auto-logout on expiration
5. User redirected to login with returnUrl

---

### Return URL Pattern

Preserve intended destination when redirecting to login.

**Pattern**:
```tsx
// In ProtectedRoute component
import { useLocation, Navigate } from 'react-router-dom';

const location = useLocation();

if (!isAuthenticated) {
  // Save current location to return after login
  return <Navigate to="/login" state={{ returnUrl: location.pathname }} replace />;
}
```

**In Login Page**:
```tsx
import { useNavigate, useLocation } from 'react-router-dom';

const navigate = useNavigate();
const location = useLocation();

const handleLogin = async (email: string, password: string) => {
  await authStore.login(email, password);

  // Redirect to intended destination or default to dashboard
  const returnUrl = location.state?.returnUrl || '/dashboard';
  navigate(returnUrl, { replace: true });
};
```

**Example Flow**:
1. User tries to access `/settings` (not authenticated)
2. ProtectedRoute redirects to `/login` with state `{ returnUrl: '/settings' }`
3. User logs in successfully
4. Login page redirects to `/settings` (returnUrl from state)

---

### Token Refresh Pattern (Future Enhancement)

For JWT-based authentication with refresh tokens.

**Pattern**:
```tsx
import { useEffect } from 'react';
import { useAuthStore } from '@/store/authStore';

function useTokenRefresh() {
  const { accessToken, refreshToken, refresh, logout } = useAuthStore();

  useEffect(() => {
    // Refresh token 5 minutes before expiration
    const tokenExpiresAt = parseJWT(accessToken).exp * 1000;
    const refreshAt = tokenExpiresAt - (5 * 60 * 1000);
    const delay = refreshAt - Date.now();

    if (delay > 0) {
      const timeoutId = setTimeout(async () => {
        try {
          await refresh(refreshToken);
        } catch (error) {
          // Refresh failed, logout user
          logout();
        }
      }, delay);

      return () => clearTimeout(timeoutId);
    }
  }, [accessToken, refreshToken, refresh, logout]);
}
```

---

### When to Use

- **ProtectedRoute**: All authenticated pages (Dashboard, Decks, Profile, Settings)
- **PublicRoute**: Auth pages (Login, Register, ForgotPassword)
- **Session Warning**: All protected routes (via AppLayout)
- **Return URL**: Any ProtectedRoute that might be accessed directly via URL

### Accessibility Considerations

- SessionWarningDialog has proper focus management
- Logout requires confirmation to prevent accidental logouts
- Clear messaging about session expiration
- Keyboard navigation support (Tab, Enter, Escape)

### Related Components

- [ProtectedRoute](#protectedroute) - Route guard for authenticated pages
- [PublicRoute](#publicroute) - Route guard for public pages
- [SessionWarningDialog](#sessionwarningdialog) - Session expiration warning
- [LogoutDialog](#logoutdialog) - Logout confirmation dialog
```

---

### Step 4: 07.04c - Modal Dialog Patterns (45 min)

Add comprehensive dialog patterns for confirmations, forms, and destructive actions.

```markdown
## Modal Dialog Patterns

### Confirmation Dialog Pattern

Use for actions that require user confirmation (logout, delete, cancel).

**Basic Confirmation**:
```tsx
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Confirm Action</DialogTitle>
      <DialogDescription>
        Are you sure you want to perform this action? This action cannot be undone.
      </DialogDescription>
    </DialogHeader>

    <DialogFooter>
      <Button variant="outline" onClick={() => setOpen(false)}>
        Cancel
      </Button>
      <Button onClick={handleConfirm}>
        Confirm
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**Destructive Confirmation** (Delete, Logout):
```tsx
import { AlertTriangleIcon } from 'lucide-react';

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2 text-red-600">
        <AlertTriangleIcon className="h-5 w-5" />
        Confirm Deletion
      </DialogTitle>
      <DialogDescription>
        Are you sure you want to delete this deck? This will permanently delete all {cardCount} flashcards and cannot be undone.
      </DialogDescription>
    </DialogHeader>

    <DialogFooter>
      <Button variant="outline" onClick={() => setOpen(false)}>
        Cancel
      </Button>
      <Button variant="destructive" onClick={handleDelete}>
        Delete Deck
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**With Loading State**:
```tsx
const [loading, setLoading] = useState(false);

<DialogFooter>
  <Button variant="outline" onClick={() => setOpen(false)} disabled={loading}>
    Cancel
  </Button>
  <Button onClick={handleConfirm} disabled={loading}>
    {loading ? (
      <>
        <LoaderIcon className="mr-2 h-4 w-4 animate-spin" />
        Processing...
      </>
    ) : (
      'Confirm'
    )}
  </Button>
</DialogFooter>
```

---

### Form Dialog Pattern

Use for forms that appear in modal overlays (create deck, edit profile).

**Pattern**:
```tsx
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent className="sm:max-w-[425px]">
    <DialogHeader>
      <DialogTitle>Create New Deck</DialogTitle>
    </DialogHeader>

    <form onSubmit={handleSubmit} className="space-y-4 py-4">
      <div className="space-y-2">
        <Label htmlFor="name">Deck Name</Label>
        <Input
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Enter deck name"
          autoFocus
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description</Label>
        <Input
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="Optional description"
        />
      </div>

      <DialogFooter>
        <Button type="button" variant="outline" onClick={() => setOpen(false)}>
          Cancel
        </Button>
        <Button type="submit">Create Deck</Button>
      </DialogFooter>
    </form>
  </DialogContent>
</Dialog>
```

**Form Validation in Dialog**:
```tsx
const [errors, setErrors] = useState<Record<string, string>>({});

const validateForm = () => {
  const newErrors: Record<string, string> = {};
  if (!name.trim()) newErrors.name = 'Deck name is required';
  if (name.length > 50) newErrors.name = 'Deck name must be less than 50 characters';
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  if (!validateForm()) return;

  await createDeck({ name, description });
  setOpen(false);
};
```

---

### Alert Dialog Pattern

Use for important messages that require acknowledgment (errors, warnings, success).

**Error Alert**:
```tsx
import { AlertCircleIcon } from 'lucide-react';

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2 text-red-600">
        <AlertCircleIcon className="h-5 w-5" />
        Error
      </DialogTitle>
      <DialogDescription>
        {errorMessage}
      </DialogDescription>
    </DialogHeader>

    <DialogFooter>
      <Button onClick={() => setOpen(false)}>
        OK
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**Success Alert**:
```tsx
import { CheckCircleIcon } from 'lucide-react';

<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle className="flex items-center gap-2 text-green-600">
        <CheckCircleIcon className="h-5 w-5" />
        Success
      </DialogTitle>
      <DialogDescription>
        Your changes have been saved successfully.
      </DialogDescription>
    </DialogHeader>

    <DialogFooter>
      <Button onClick={() => setOpen(false)}>
        OK
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

---

### Fullscreen Dialog Pattern (Mobile)

Use for complex forms or content that needs more space on mobile.

**Pattern**:
```tsx
<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent className="sm:max-w-[425px] md:max-w-[600px] max-h-[90vh] overflow-y-auto">
    <DialogHeader>
      <DialogTitle>Edit Profile</DialogTitle>
    </DialogHeader>

    <div className="space-y-4 py-4">
      {/* Form content */}
    </div>

    <DialogFooter className="sticky bottom-0 bg-white pt-4 border-t">
      <Button variant="outline" onClick={() => setOpen(false)}>
        Cancel
      </Button>
      <Button onClick={handleSave}>Save Changes</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**Mobile Considerations**:
- `max-h-[90vh]` prevents dialog from exceeding viewport
- `overflow-y-auto` allows scrolling for long content
- Sticky footer with buttons for easy access
- Responsive max-width (smaller on mobile, larger on desktop)

---

### Dialog State Management Pattern

Manage dialog state with custom hooks.

**useDialog Hook**:
```tsx
import { useState, useCallback } from 'react';

function useDialog() {
  const [open, setOpen] = useState(false);

  const openDialog = useCallback(() => setOpen(true), []);
  const closeDialog = useCallback(() => setOpen(false), []);
  const toggleDialog = useCallback(() => setOpen(prev => !prev), []);

  return {
    open,
    openDialog,
    closeDialog,
    toggleDialog,
    setOpen
  };
}

// Usage
const { open, openDialog, closeDialog } = useDialog();

<Button onClick={openDialog}>Delete Deck</Button>

<Dialog open={open} onOpenChange={closeDialog}>
  {/* Dialog content */}
</Dialog>
```

**Multiple Dialogs Pattern**:
```tsx
const deleteDialog = useDialog();
const editDialog = useDialog();

<Button onClick={deleteDialog.openDialog}>Delete</Button>
<Button onClick={editDialog.openDialog}>Edit</Button>

<DeleteDialog open={deleteDialog.open} onClose={deleteDialog.closeDialog} />
<EditDialog open={editDialog.open} onClose={editDialog.closeDialog} />
```

---

### Dialog Sizes

Standard dialog sizes for different content types:

| Size | Max Width | Use Case |
|------|-----------|----------|
| Small | 384px (sm:max-w-sm) | Simple confirmations, alerts |
| Medium | 512px (sm:max-w-md) | Forms with 2-4 fields |
| Large | 640px (sm:max-w-lg) | Forms with many fields, settings |
| Extra Large | 768px (sm:max-w-xl) | Complex content, data tables |

**Example**:
```tsx
// Small dialog
<DialogContent className="sm:max-w-sm">

// Medium dialog (default)
<DialogContent className="sm:max-w-md">

// Large dialog
<DialogContent className="sm:max-w-lg">
```

---

### When to Use

- **Confirmation Dialog**: Logout, delete, cancel operations
- **Form Dialog**: Create deck, edit item, add flashcard
- **Alert Dialog**: Error messages, success notifications
- **Fullscreen Dialog**: Complex forms on mobile, multi-step wizards

### Accessibility Considerations

- Dialog traps focus (cannot tab outside)
- Escape key closes dialog
- Click overlay closes dialog (unless critical action)
- First interactive element receives focus on open
- Focus returns to trigger element on close
- DialogTitle provides accessible name (aria-labelledby)
- DialogDescription provides context (aria-describedby)

### Related Components

- [Dialog](#dialog) - Shadcn dialog component
- [LogoutDialog](#logoutdialog) - Logout confirmation
- [SessionWarningDialog](#sessionwarningdialog) - Session warning
```

---

### Step 5: 07.04d - Mobile-Specific Patterns (30 min)

Add mobile-first and responsive patterns.

```markdown
## Mobile-Specific Patterns

### Mobile Navigation Pattern

Use bottom tab navigation on mobile, header navigation on desktop.

**Pattern** (handled automatically by AppLayout):
```tsx
// Mobile (< 768px) - Bottom navigation visible
<div className="fixed bottom-0 left-0 right-0 md:hidden">
  <MobileBottomNav />
</div>

// Desktop (‚â• 768px) - Header navigation visible
<header className="hidden md:flex">
  <NavigationMenu />
</header>
```

**Mobile Bottom Nav Structure**:
```tsx
<nav className="flex justify-around items-center h-16 bg-white border-t border-gray-200">
  <NavItem icon={HomeIcon} label="Home" path="/" />
  <NavItem icon={BookOpenIcon} label="Decks" path="/decks" />
  <NavItem icon={BarChartIcon} label="Stats" path="/statistics" />
  <NavItem icon={UserIcon} label="Profile" path="/profile" />
</nav>
```

**Safe Area Padding** (for notched devices):
```css
/* In Tailwind config or CSS */
.mobile-nav {
  padding-bottom: env(safe-area-inset-bottom);
}
```

---

### Touch Interaction Pattern

Optimize tap targets and touch gestures for mobile.

**Minimum Touch Target Size**: 44x44px (iOS) / 48x48px (Android)

```tsx
// ‚úÖ Correct - adequate touch target
<button className="min-h-[44px] min-w-[44px] p-3">
  <HeartIcon className="h-6 w-6" />
</button>

// ‚ùå Wrong - touch target too small
<button className="p-1">
  <HeartIcon className="h-4 w-4" />
</button>
```

**Touch-Friendly Spacing**:
```tsx
// Mobile: Larger spacing between interactive elements
<div className="flex gap-4 md:gap-2">
  <Button>Action 1</Button>
  <Button>Action 2</Button>
</div>
```

**Swipe Gestures** (for flashcard review):
```tsx
import { useSwipeable } from 'react-swipeable';

const handlers = useSwipeable({
  onSwipedLeft: () => handleNextCard(),
  onSwipedRight: () => handlePreviousCard(),
  preventDefaultTouchmoveEvent: true,
  trackMouse: false // Swipe only on touch devices
});

<div {...handlers} className="flashcard">
  {/* Flashcard content */}
</div>
```

---

### Responsive Breakpoints

Tailwind breakpoints used throughout the application:

| Breakpoint | Min Width | Device | Common Patterns |
|------------|-----------|--------|-----------------|
| (default) | 0px | Mobile | Stack layouts, bottom nav, single column |
| sm | 640px | Large mobile | Slightly wider containers |
| md | 768px | Tablet | Switch to desktop nav, two-column layouts |
| lg | 1024px | Desktop | Multi-column grids, sidebar layouts |
| xl | 1280px | Large desktop | Max content width, more columns |
| 2xl | 1536px | Extra large | Max content width constraints |

**Key Breakpoint (md - 768px)**:
- Mobile nav ‚Üí Desktop nav
- Single column ‚Üí Multi-column
- Stacked forms ‚Üí Side-by-side

**Pattern Examples**:
```tsx
// Mobile: Full width, Desktop: Fixed width
<div className="w-full md:w-96">

// Mobile: Hidden, Desktop: Visible
<div className="hidden md:block">

// Mobile: 1 column, Tablet: 2 columns, Desktop: 3 columns
<div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">

// Mobile: Stack, Desktop: Row
<div className="flex flex-col md:flex-row gap-4">
```

---

### Mobile Form Pattern

Optimize forms for mobile input.

**Pattern**:
```tsx
<form className="space-y-4">
  {/* Full-width inputs on mobile */}
  <Input
    type="email"
    inputMode="email" // Shows email keyboard on mobile
    autoComplete="email"
    className="w-full text-base" // Prevent zoom on iOS (font-size ‚â• 16px)
  />

  <Input
    type="tel"
    inputMode="tel" // Shows phone keyboard
    autoComplete="tel"
    className="w-full text-base"
  />

  <Input
    type="number"
    inputMode="numeric" // Shows numeric keyboard
    className="w-full text-base"
  />

  {/* Full-width buttons on mobile */}
  <Button type="submit" className="w-full md:w-auto">
    Submit
  </Button>
</form>
```

**Input Types for Mobile Keyboards**:
- `type="email"` + `inputMode="email"` ‚Üí Email keyboard
- `type="tel"` + `inputMode="tel"` ‚Üí Phone keyboard
- `type="number"` + `inputMode="numeric"` ‚Üí Numeric keyboard
- `type="url"` + `inputMode="url"` ‚Üí URL keyboard
- `type="search"` + `inputMode="search"` ‚Üí Search keyboard

---

### Mobile Card Pattern

Optimize card layouts for mobile screens.

**Pattern**:
```tsx
// Desktop: Horizontal card, Mobile: Vertical card
<Card className="flex flex-col md:flex-row">
  <div className="w-full md:w-1/3">
    <img src={image} alt={title} className="w-full h-48 md:h-full object-cover" />
  </div>
  <CardContent className="flex-1 p-4">
    <CardTitle>{title}</CardTitle>
    <CardDescription>{description}</CardDescription>
  </CardContent>
</Card>

// Mobile: Single column grid, Desktop: Multi-column
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {decks.map(deck => (
    <DeckCard key={deck.id} deck={deck} />
  ))}
</div>
```

---

### Mobile Modal Pattern

Full-screen modals on mobile, centered dialogs on desktop.

**Pattern**:
```tsx
<Dialog open={open} onOpenChange={setOpen}>
  <DialogContent className="
    h-full w-full max-w-full m-0 rounded-none
    md:h-auto md:max-w-md md:m-4 md:rounded-lg
  ">
    <DialogHeader>
      <DialogTitle>Modal Title</DialogTitle>
    </DialogHeader>

    <div className="flex-1 overflow-y-auto p-4">
      {/* Content */}
    </div>

    <DialogFooter className="sticky bottom-0 bg-white border-t p-4">
      <Button onClick={() => setOpen(false)}>Close</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

**Mobile Characteristics**:
- Full height and width
- No border radius
- No margin
- Sticky footer

**Desktop Characteristics**:
- Auto height
- Max width 28rem (448px)
- Margin around edges
- Rounded corners

---

### Mobile Performance Pattern

Optimize images and content loading for mobile.

**Lazy Loading Images**:
```tsx
<img
  src={imageUrl}
  alt={alt}
  loading="lazy" // Native lazy loading
  className="w-full h-auto"
/>
```

**Responsive Images**:
```tsx
<picture>
  <source
    media="(min-width: 768px)"
    srcSet={desktopImage}
  />
  <img
    src={mobileImage}
    alt={alt}
    className="w-full h-auto"
  />
</picture>
```

---

### When to Use

- **Mobile Navigation**: All authenticated pages (via AppLayout)
- **Touch Targets**: All interactive elements (buttons, links, icons)
- **Responsive Breakpoints**: All layouts and grids
- **Mobile Forms**: All input forms (login, register, create deck)
- **Mobile Modals**: All dialogs and overlays

### Accessibility Considerations

- Touch targets minimum 44x44px
- Adequate spacing between interactive elements
- No hover-dependent interactions (use tap/click)
- Keyboard accessibility maintained on all screen sizes
- Focus indicators visible for keyboard navigation

### Related Components

- [MobileBottomNav](#mobilebottomnav) - Mobile tab navigation
- [AppLayout](#applayout) - Responsive layout wrapper
- [Header](#header) - Desktop navigation
```

---

### Step 6: 07.04e - Loading/Empty State Patterns (30 min)

Add comprehensive loading and empty state patterns.

```markdown
## Loading & Empty State Patterns

### Skeleton Loading Pattern

Use skeleton screens for loading states to improve perceived performance.

**Card Skeleton**:
```tsx
import { Skeleton } from '@/components/ui/skeleton';
import { Card } from '@/components/ui/card';

<Card className="p-4">
  <div className="space-y-3">
    <Skeleton className="h-4 w-2/3" /> {/* Title */}
    <Skeleton className="h-3 w-full" /> {/* Description line 1 */}
    <Skeleton className="h-3 w-5/6" /> {/* Description line 2 */}
    <div className="flex gap-2 pt-2">
      <Skeleton className="h-8 w-20" /> {/* Button 1 */}
      <Skeleton className="h-8 w-20" /> {/* Button 2 */}
    </div>
  </div>
</Card>
```

**List Skeleton**:
```tsx
function ListSkeleton({ count = 3 }: { count?: number }) {
  return (
    <div className="space-y-4">
      {Array.from({ length: count }).map((_, i) => (
        <Card key={i} className="p-4">
          <div className="flex items-center gap-4">
            <Skeleton className="h-12 w-12 rounded-full" />
            <div className="flex-1 space-y-2">
              <Skeleton className="h-4 w-1/2" />
              <Skeleton className="h-3 w-3/4" />
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
}
```

**Flashcard Skeleton** (existing component):
```tsx
import { FlashcardSkeleton } from '@/components/flashcard/FlashcardSkeleton';

{loading ? <FlashcardSkeleton /> : <FlashcardContainer card={currentCard} />}
```

---

### Spinner Loading Pattern

Use spinners for inline loading states and buttons.

**Page Loader**:
```tsx
import { LoaderIcon } from 'lucide-react';

function PageLoader() {
  return (
    <div className="flex items-center justify-center min-h-[400px]">
      <div className="text-center space-y-4">
        <LoaderIcon className="h-8 w-8 animate-spin text-primary mx-auto" />
        <p className="text-muted">Loading...</p>
      </div>
    </div>
  );
}
```

**Inline Loader**:
```tsx
{loading && (
  <div className="flex items-center gap-2 text-muted text-sm">
    <LoaderIcon className="h-4 w-4 animate-spin" />
    <span>Loading data...</span>
  </div>
)}
```

**Button Loading State**:
```tsx
<Button disabled={loading}>
  {loading ? (
    <>
      <LoaderIcon className="mr-2 h-4 w-4 animate-spin" />
      Loading...
    </>
  ) : (
    'Submit'
  )}
</Button>
```

---

### Empty State Pattern

Show helpful empty states when no data is available.

**Basic Empty State**:
```tsx
import { InboxIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';

function EmptyState({
  icon: Icon = InboxIcon,
  title,
  description,
  action
}: {
  icon?: LucideIcon;
  title: string;
  description?: string;
  action?: { label: string; onClick: () => void };
}) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px] text-center p-8">
      <Icon className="h-16 w-16 text-muted/50 mb-4" />
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      {description && (
        <p className="text-muted max-w-sm mb-6">{description}</p>
      )}
      {action && (
        <Button onClick={action.onClick}>
          {action.label}
        </Button>
      )}
    </div>
  );
}
```

**Usage Examples**:
```tsx
// No decks created
<EmptyState
  icon={BookOpenIcon}
  title="No decks yet"
  description="Create your first deck to start learning Greek words."
  action={{ label: 'Create Deck', onClick: () => setShowCreateDialog(true) }}
/>

// No search results
<EmptyState
  icon={SearchIcon}
  title="No results found"
  description={`No decks match "${searchQuery}". Try a different search term.`}
/>

// No activity
<EmptyState
  icon={ActivityIcon}
  title="No recent activity"
  description="Your learning activity will appear here once you start reviewing flashcards."
/>
```

---

### Error State Pattern

Show clear error messages with recovery options.

**Page Error**:
```tsx
import { AlertCircleIcon, RefreshCwIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';

function ErrorState({
  title = 'Something went wrong',
  message,
  onRetry
}: {
  title?: string;
  message: string;
  onRetry?: () => void;
}) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px] p-8">
      <Alert variant="destructive" className="max-w-md mb-4">
        <AlertCircleIcon className="h-4 w-4" />
        <AlertDescription>
          <strong className="font-semibold">{title}</strong>
          <p className="mt-1">{message}</p>
        </AlertDescription>
      </Alert>

      {onRetry && (
        <Button onClick={onRetry} variant="outline">
          <RefreshCwIcon className="mr-2 h-4 w-4" />
          Try Again
        </Button>
      )}
    </div>
  );
}
```

**Inline Error**:
```tsx
{error && (
  <Alert variant="destructive">
    <AlertCircleIcon className="h-4 w-4" />
    <AlertDescription>{error}</AlertDescription>
  </Alert>
)}
```

---

### Progressive Loading Pattern

Load content in stages for better UX.

**Pattern**:
```tsx
function DashboardPage() {
  const [loadingState, setLoadingState] = useState<'metrics' | 'charts' | 'complete'>('metrics');

  useEffect(() => {
    // Load metrics first (fastest)
    loadMetrics().then(() => {
      setLoadingState('charts');

      // Then load charts (slower)
      loadCharts().then(() => {
        setLoadingState('complete');
      });
    });
  }, []);

  return (
    <div className="space-y-6">
      {/* Metrics load immediately */}
      {loadingState === 'metrics' ? (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          {Array.from({ length: 4 }).map((_, i) => (
            <Skeleton key={i} className="h-32" />
          ))}
        </div>
      ) : (
        <MetricsGrid metrics={metrics} />
      )}

      {/* Charts load after metrics */}
      {loadingState !== 'complete' ? (
        <Skeleton className="h-64" />
      ) : (
        <ChartsSection data={chartData} />
      )}
    </div>
  );
}
```

---

### Loading State Hook

Centralize loading state management.

**useLoadingState Hook**:
```tsx
import { useState, useCallback } from 'react';

function useLoadingState() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(async <T,>(
    asyncFn: () => Promise<T>
  ): Promise<T | null> => {
    setLoading(true);
    setError(null);

    try {
      const result = await asyncFn();
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setLoading(false);
    setError(null);
  }, []);

  return { loading, error, execute, reset };
}

// Usage
const { loading, error, execute } = useLoadingState();

const handleSubmit = async () => {
  const result = await execute(() => createDeck(deckData));
  if (result) {
    // Success
  }
};
```

---

### Optimistic Update Pattern

Update UI immediately, rollback on error.

**Pattern**:
```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function DeckCard({ deck }: { deck: Deck }) {
  const queryClient = useQueryClient();

  const deleteMutation = useMutation({
    mutationFn: deleteDeck,
    onMutate: async (deckId) => {
      // Cancel outgoing fetches
      await queryClient.cancelQueries(['decks']);

      // Snapshot previous value
      const previousDecks = queryClient.getQueryData(['decks']);

      // Optimistically update
      queryClient.setQueryData(['decks'], (old: Deck[]) =>
        old.filter(d => d.id !== deckId)
      );

      // Return snapshot for rollback
      return { previousDecks };
    },
    onError: (err, deckId, context) => {
      // Rollback on error
      queryClient.setQueryData(['decks'], context.previousDecks);
      toast.error('Failed to delete deck');
    },
    onSuccess: () => {
      toast.success('Deck deleted');
    }
  });

  return (
    <Card>
      <Button
        onClick={() => deleteMutation.mutate(deck.id)}
        disabled={deleteMutation.isLoading}
      >
        {deleteMutation.isLoading ? 'Deleting...' : 'Delete'}
      </Button>
    </Card>
  );
}
```

---

### When to Use

- **Skeleton Loading**: Initial page load, content placeholders
- **Spinner Loading**: Button actions, inline data fetching
- **Empty State**: No data available, no search results
- **Error State**: Failed data loading, network errors
- **Progressive Loading**: Large dashboards, data-heavy pages
- **Optimistic Updates**: User actions (delete, update, create)

### Accessibility Considerations

- Loading states announced to screen readers (aria-live="polite")
- Focus management during loading transitions
- Keyboard navigation maintained in all states
- Error messages clearly communicated
- Retry buttons keyboard accessible

### Related Components

- [Skeleton](#skeleton) - Shadcn skeleton component
- [FlashcardSkeleton](#flashcardskeleton) - Custom flashcard skeleton
- [Alert](#alert) - Error message component
```

---

## Success Criteria

- [ ] All 5 pattern categories added to Style-Guide.md
- [ ] Each category has 2-3 comprehensive code examples
- [ ] All patterns include "When to Use" sections
- [ ] All patterns include "Accessibility Considerations"
- [ ] All patterns include "Related Components" cross-references
- [ ] Code examples are syntactically correct and runnable
- [ ] Patterns align with existing component implementations
- [ ] Documentation follows consistent formatting
- [ ] All patterns reference actual components from the codebase

---

## File Paths Reference

```
Documentation File:
/Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/frontend/Style-Guide.md

Reference Components (for examples):
/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-frontend/src/pages/Login.tsx
/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-frontend/src/components/auth/
/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-frontend/src/components/ui/dialog.tsx
/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-frontend/src/components/layout/MobileBottomNav.tsx
```

---

## Definition of Done

- [ ] Authentication UI Patterns section added (07.04a) - 45 min
- [ ] Protected Route Patterns section added (07.04b) - 30 min
- [ ] Modal Dialog Patterns section added (07.04c) - 45 min
- [ ] Mobile-Specific Patterns section added (07.04d) - 30 min
- [ ] Loading/Empty State Patterns section added (07.04e) - 30 min
- [ ] All sections inserted in appropriate location in Style-Guide.md
- [ ] All code examples tested for syntax correctness
- [ ] Cross-references added between Components-Reference.md and Style-Guide.md
- [ ] "Component Patterns" section now has 11 categories (up from 6)
- [ ] Task completion logged in Frontend-Tasks-Progress.md

---

## Time Breakdown

| Subtask | Duration | Details |
|---------|----------|---------|
| Read existing Style Guide | 10 min | Understand structure |
| 07.04a: Authentication UI Patterns | 45 min | Forms, validation, errors |
| 07.04b: Protected Route Patterns | 30 min | Guards, session management |
| 07.04c: Modal Dialog Patterns | 45 min | Confirmations, forms, alerts |
| 07.04d: Mobile-Specific Patterns | 30 min | Navigation, touch, responsive |
| 07.04e: Loading/Empty State Patterns | 30 min | Skeletons, spinners, empty states |
| **TOTAL** | **190 min** | **(slightly over 180 estimate)** |

---

## Next Steps

After completing this task:
1. Proceed to Task 07.05 (Quality Assurance)
2. Validate all cross-references between Style-Guide.md and Components-Reference.md
3. Consider creating visual examples for each pattern category
