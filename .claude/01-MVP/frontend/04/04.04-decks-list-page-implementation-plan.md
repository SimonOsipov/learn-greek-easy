# Task 04.04: Create Decks List Page - Comprehensive Implementation Plan

**Task ID**: 04.04
**Duration**: 75 minutes
**Priority**: High
**Status**: Ready for Implementation
**Created**: 2025-11-01
**Dependencies**: Task 04.03 (DeckCard Components) ✅ Completed, Task 04.02 (Deck State Management) ✅ Completed

---

## Table of Contents

1. [Overview](#overview)
2. [Context & Dependencies](#context--dependencies)
3. [Implementation Steps](#implementation-steps)
4. [Component Specifications](#component-specifications)
5. [Testing Strategy](#testing-strategy)
6. [Success Criteria Checklist](#success-criteria-checklist)
7. [Common Pitfalls & Solutions](#common-pitfalls--solutions)
8. [Accessibility Requirements](#accessibility-requirements)
9. [Documentation Requirements](#documentation-requirements)

---

## Overview

### Objective

Create the main Decks List Page (`/decks` route) that displays all available Greek language learning decks in a responsive grid layout with filtering and search capabilities. This page serves as the primary discovery interface for users to browse and select vocabulary decks to study.

### Business Value

- **Primary User Action**: Browse all available Greek vocabulary decks (A1-B2 levels)
- **Content Discovery**: Users can filter by level, search by name, and view progress at a glance
- **Mobile-First**: Optimized for commuters studying on mobile devices
- **Premium Conversion**: Locked premium decks visible with upgrade prompts
- **Progress Motivation**: Visual progress indicators encourage continued learning

### Technical Approach

- **Mobile-First Responsive Design**: 1 column (mobile) → 2 columns (tablet) → 3 columns (desktop)
- **State Management**: Zustand `deckStore` for decks, filters, loading states
- **Search Debouncing**: 300ms delay to prevent excessive filtering
- **Component Composition**: Reuses existing `DeckCard`, `DeckBadge`, `DeckProgressBar` from Task 04.03
- **Route Integration**: Updates `App.tsx` to replace placeholder `DecksPage`

---

## Context & Dependencies

### Completed Prerequisites

#### Task 04.01: Deck Data Types ✅
- **File**: `/src/types/deck.ts` - Complete TypeScript interfaces
- **File**: `/src/services/mockDeckData.ts` - 6 authentic Greek decks (575 cards total)
- **File**: `/src/services/mockDeckAPI.ts` - Mock API with filtering support
- **Key Types**: `Deck`, `DeckProgress`, `DeckFilters`, `DeckLevel`, `DeckStatus`

#### Task 04.02: Deck State Management ✅
- **File**: `/src/stores/deckStore.ts` - Zustand store with 8 actions
- **Actions Available**:
  - `fetchDecks()` - Load decks with current filters
  - `setFilters(filters)` - Update filters and re-fetch
  - `clearFilters()` - Reset to default filters
  - `selectDeck(id)` - Navigate to deck detail
  - `startLearning(id)` - Initialize learning session
- **State Properties**:
  - `decks: Deck[]` - Filtered deck list
  - `filters: DeckFilters` - Active filter settings
  - `isLoading: boolean` - Loading state
  - `error: string | null` - Error message
- **Premium Checks**: Integrated with `authStore` for access control

#### Task 04.03: DeckCard Components ✅
- **File**: `/src/components/decks/DeckCard.tsx` - Main deck display component
- **File**: `/src/components/decks/DeckBadge.tsx` - Level/status badges
- **File**: `/src/components/decks/DeckProgressBar.tsx` - Segmented progress visualization
- **File**: `/src/components/decks/index.ts` - Barrel export for clean imports
- **Features**:
  - Greek typography support (titleGreek > title)
  - Premium indicators (lock icon, gold border)
  - Progress visualization (new/learning/mastered segments)
  - Keyboard accessible (Enter/Space)
  - Mobile responsive

### Available Resources

#### Design System (Style-Guide.md)
- **Colors**: Primary blue (#2563eb), level badge colors (A1: green, A2: blue, B1: orange, B2: purple)
- **Spacing**: 4px base unit, gap-4 (1rem) for grids
- **Typography**: Mobile-first scale (1.75rem → 2rem for headings)
- **Breakpoints**: 768px (tablet), 1024px (desktop)
- **Premium Indicators**: Amber-500 lock icon, amber-100 badge background, 70% opacity for locked

#### Existing Components (Components-Reference.md)
- **Shadcn/ui**: `Card`, `Badge`, `Button`, `Skeleton`, `Input`
- **Custom Layout**: `PageContainer` (max-width wrapper)
- **Icons**: Lucide React (`Lock`, `Search`, `Filter`, `X`)

#### Mock Data (mockDeckData.ts)
- **6 Greek Decks**: A1 Basic Vocabulary (100 cards), Family & Relationships (75 cards), Numbers/Dates/Time (80 cards), Food & Dining (120 cards, premium), Travel (90 cards), Work & Professional (110 cards, premium)
- **Mock Progress**: 3 decks with progress data (in-progress, completed, not-started)
- **Total Cards**: 575 flashcards across all decks

---

## Implementation Steps

### Step 1: Create DecksGrid Component (15 minutes)

**File**: `/src/components/decks/DecksGrid.tsx`

**Purpose**: Responsive grid container that displays deck cards in 1/2/3 column layout based on viewport width.

#### Implementation

```typescript
// /src/components/decks/DecksGrid.tsx

import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Deck } from '@/types/deck';
import { DeckCard } from './DeckCard';

export interface DecksGridProps {
  decks: Deck[];
  onDeckClick?: (deckId: string) => void;
}

export const DecksGrid: React.FC<DecksGridProps> = ({
  decks,
  onDeckClick
}) => {
  const navigate = useNavigate();

  const handleDeckClick = (deckId: string) => {
    if (onDeckClick) {
      onDeckClick(deckId);
    } else {
      // Default behavior: navigate to deck detail page
      navigate(`/decks/${deckId}`);
    }
  };

  return (
    <div
      className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3"
      role="list"
      aria-label="Available decks"
    >
      {decks.map((deck) => (
        <div key={deck.id} role="listitem">
          <DeckCard
            deck={deck}
            onClick={() => handleDeckClick(deck.id)}
            showProgress={true}
            showStats={true}
            variant="grid"
          />
        </div>
      ))}
    </div>
  );
};
```

#### Key Features

1. **Responsive Grid Classes**:
   - `grid-cols-1` - Mobile: 1 column (< 768px)
   - `md:grid-cols-2` - Tablet: 2 columns (768px - 1024px)
   - `lg:grid-cols-3` - Desktop: 3 columns (≥ 1024px)
   - `gap-4` - 1rem (16px) spacing between cards

2. **Navigation Integration**:
   - Default behavior: Navigate to `/decks/:deckId`
   - Optional custom `onDeckClick` handler for flexibility
   - Uses React Router's `useNavigate` hook

3. **Accessibility**:
   - `role="list"` on grid container
   - `role="listitem"` on each deck wrapper
   - `aria-label` for screen readers
   - Each `DeckCard` handles its own keyboard navigation

4. **Component Composition**:
   - Reuses `DeckCard` from Task 04.03
   - Passes `variant="grid"` for vertical layout
   - Shows progress and stats by default

#### Testing Points

- [ ] Grid displays 1 column on mobile (375px)
- [ ] Grid displays 2 columns on tablet (768px)
- [ ] Grid displays 3 columns on desktop (1024px+)
- [ ] Cards maintain aspect ratio across breakpoints
- [ ] Gap spacing consistent (16px between cards)
- [ ] Empty array renders nothing (no errors)
- [ ] Navigation works when clicking deck cards
- [ ] ARIA roles detected by screen reader

---

### Step 2: Create DeckFilters Component (25 minutes)

**File**: `/src/components/decks/DeckFilters.tsx`

**Purpose**: Filter and search UI for decks - search input, level toggles, status dropdown, premium filter.

#### Implementation

```typescript
// /src/components/decks/DeckFilters.tsx

import React, { useState, useCallback } from 'react';
import { Search, X } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { DeckFilters as DeckFiltersType, DeckLevel, DeckStatus } from '@/types/deck';
import { debounce } from '@/lib/utils';

export interface DeckFiltersProps {
  filters: DeckFiltersType;
  onChange: (filters: Partial<DeckFiltersType>) => void;
  onClear: () => void;
  totalDecks: number;
  filteredDecks: number;
}

const LEVEL_OPTIONS: { value: DeckLevel; label: string; color: string }[] = [
  { value: 'A1', label: 'A1 - Beginner', color: 'bg-green-500' },
  { value: 'A2', label: 'A2 - Elementary', color: 'bg-blue-500' },
  { value: 'B1', label: 'B1 - Intermediate', color: 'bg-orange-500' },
  { value: 'B2', label: 'B2 - Upper-Intermediate', color: 'bg-purple-600' },
];

const STATUS_OPTIONS: { value: DeckStatus; label: string }[] = [
  { value: 'not-started', label: 'Not Started' },
  { value: 'in-progress', label: 'In Progress' },
  { value: 'completed', label: 'Completed' },
];

export const DeckFilters: React.FC<DeckFiltersProps> = ({
  filters,
  onChange,
  onClear,
  totalDecks,
  filteredDecks,
}) => {
  // Local state for search input (debounced before updating store)
  const [searchInput, setSearchInput] = useState(filters.search);

  // Debounced search handler (300ms delay)
  const debouncedSearch = useCallback(
    debounce((value: string) => {
      onChange({ search: value });
    }, 300),
    [onChange]
  );

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setSearchInput(value);
    debouncedSearch(value);
  };

  const handleLevelToggle = (level: DeckLevel) => {
    const newLevels = filters.levels.includes(level)
      ? filters.levels.filter((l) => l !== level)
      : [...filters.levels, level];
    onChange({ levels: newLevels });
  };

  const handleStatusToggle = (status: DeckStatus) => {
    const newStatuses = filters.status.includes(status)
      ? filters.status.filter((s) => s !== status)
      : [...filters.status, status];
    onChange({ status: newStatuses });
  };

  const handlePremiumToggle = () => {
    onChange({ showPremiumOnly: !filters.showPremiumOnly });
  };

  const handleClearFilters = () => {
    setSearchInput('');
    onClear();
  };

  // Count active filters
  const activeFilterCount =
    filters.levels.length +
    filters.status.length +
    (filters.showPremiumOnly ? 1 : 0) +
    (filters.search.length > 0 ? 1 : 0);

  return (
    <div className="mb-6 space-y-4">
      {/* Search Input */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
        <Input
          type="text"
          placeholder="Search decks by name..."
          value={searchInput}
          onChange={handleSearchChange}
          className="pl-10 pr-10"
          aria-label="Search decks"
        />
        {searchInput.length > 0 && (
          <button
            onClick={() => {
              setSearchInput('');
              onChange({ search: '' });
            }}
            className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            aria-label="Clear search"
          >
            <X className="h-4 w-4" />
          </button>
        )}
      </div>

      {/* Filter Buttons Row */}
      <div className="flex flex-wrap items-center gap-2">
        {/* Level Filters */}
        <div className="flex flex-wrap gap-2">
          <span className="text-sm font-medium text-gray-700">Level:</span>
          {LEVEL_OPTIONS.map(({ value, label, color }) => (
            <Button
              key={value}
              variant={filters.levels.includes(value) ? 'default' : 'outline'}
              size="sm"
              onClick={() => handleLevelToggle(value)}
              className={
                filters.levels.includes(value)
                  ? `${color} text-white hover:opacity-90`
                  : ''
              }
              aria-pressed={filters.levels.includes(value)}
            >
              {value}
            </Button>
          ))}
        </div>

        {/* Status Filters */}
        <div className="flex flex-wrap gap-2">
          <span className="text-sm font-medium text-gray-700">Status:</span>
          {STATUS_OPTIONS.map(({ value, label }) => (
            <Button
              key={value}
              variant={filters.status.includes(value) ? 'default' : 'outline'}
              size="sm"
              onClick={() => handleStatusToggle(value)}
              aria-pressed={filters.status.includes(value)}
            >
              {label}
            </Button>
          ))}
        </div>

        {/* Premium Filter */}
        <Button
          variant={filters.showPremiumOnly ? 'default' : 'outline'}
          size="sm"
          onClick={handlePremiumToggle}
          className={
            filters.showPremiumOnly
              ? 'bg-amber-500 text-white hover:bg-amber-600'
              : ''
          }
          aria-pressed={filters.showPremiumOnly}
        >
          Premium Only
        </Button>

        {/* Clear Filters Button */}
        {activeFilterCount > 0 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClearFilters}
            className="ml-auto text-gray-600 hover:text-gray-900"
          >
            <X className="mr-1 h-4 w-4" />
            Clear All ({activeFilterCount})
          </Button>
        )}
      </div>

      {/* Results Counter */}
      <div className="text-sm text-gray-600">
        Showing {filteredDecks} of {totalDecks} decks
      </div>
    </div>
  );
};
```

#### Utility: Debounce Function

Add to `/src/lib/utils.ts` if not already present:

```typescript
// /src/lib/utils.ts (add to existing file)

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };

    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}
```

#### Key Features

1. **Search Input**:
   - 300ms debounce delay to prevent excessive re-renders
   - Clear button (X icon) when input has text
   - Search icon on left for visual clarity
   - Updates `filters.search` after debounce

2. **Level Filter Toggles**:
   - 4 buttons (A1, A2, B1, B2)
   - Active state shows level badge color (green/blue/orange/purple)
   - Multiple selections allowed (array of levels)
   - ARIA `aria-pressed` for accessibility

3. **Status Filter Toggles**:
   - 3 buttons (Not Started, In Progress, Completed)
   - Multiple selections allowed
   - Default outline style, blue when active

4. **Premium Filter**:
   - Single toggle (on/off)
   - Amber color when active
   - Shows only premium decks when enabled

5. **Clear All Button**:
   - Appears when any filter is active
   - Shows count of active filters
   - Resets all filters to default state

6. **Results Counter**:
   - Shows "X of Y decks" for user feedback
   - Updates in real-time as filters change

#### Testing Points

- [ ] Search debounces (no API call until 300ms pause)
- [ ] Clear search button works
- [ ] Level toggles update filter state
- [ ] Multiple levels can be selected
- [ ] Status toggles work independently
- [ ] Premium filter shows only premium decks
- [ ] Clear all resets all filters
- [ ] Active filter count accurate
- [ ] Results counter updates correctly
- [ ] Responsive layout (wraps on mobile)

---

### Step 3: Create DecksPage Component (20 minutes)

**File**: `/src/pages/DecksPage.tsx`

**Purpose**: Main page component integrating DecksGrid, DeckFilters, loading states, and empty states.

#### Implementation

```typescript
// /src/pages/DecksPage.tsx

import React, { useEffect } from 'react';
import { useDeckStore } from '@/stores/deckStore';
import { DecksGrid } from '@/components/decks/DecksGrid';
import { DeckFilters } from '@/components/decks/DeckFilters';
import { Skeleton } from '@/components/ui/skeleton';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { AlertCircle, BookOpen } from 'lucide-react';

export const DecksPage: React.FC = () => {
  const {
    decks,
    filters,
    isLoading,
    error,
    fetchDecks,
    setFilters,
    clearFilters,
    clearError,
  } = useDeckStore();

  // Fetch decks on mount and when filters change
  useEffect(() => {
    fetchDecks();
  }, [fetchDecks]);

  // Calculate total decks (would come from API in real implementation)
  const totalDecks = 6; // Mock value - in production, fetch from API

  return (
    <div className="container mx-auto px-4 py-6 md:py-8">
      {/* Page Header */}
      <div className="mb-6 md:mb-8">
        <h1 className="text-2xl font-semibold text-gray-900 md:text-3xl">
          Available Decks
        </h1>
        <p className="mt-2 text-sm text-gray-600 md:text-base">
          Choose a deck to start learning Greek vocabulary
        </p>
      </div>

      {/* Filters */}
      <DeckFilters
        filters={filters}
        onChange={setFilters}
        onClear={clearFilters}
        totalDecks={totalDecks}
        filteredDecks={decks.length}
      />

      {/* Error State */}
      {error && (
        <Card className="mb-6 border-red-200 bg-red-50 p-4">
          <div className="flex items-start gap-3">
            <AlertCircle className="h-5 w-5 flex-shrink-0 text-red-600" />
            <div className="flex-1">
              <h3 className="font-medium text-red-900">Error Loading Decks</h3>
              <p className="mt-1 text-sm text-red-700">{error}</p>
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  clearError();
                  fetchDecks();
                }}
                className="mt-3 border-red-300 text-red-700 hover:bg-red-100"
              >
                Try Again
              </Button>
            </div>
          </div>
        </Card>
      )}

      {/* Loading State */}
      {isLoading && !error && <DeckGridSkeleton />}

      {/* Decks Grid */}
      {!isLoading && !error && decks.length > 0 && (
        <DecksGrid decks={decks} />
      )}

      {/* Empty State */}
      {!isLoading && !error && decks.length === 0 && (
        <EmptyState onClearFilters={clearFilters} />
      )}
    </div>
  );
};

// Loading skeleton component
const DeckGridSkeleton: React.FC = () => (
  <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
    {[1, 2, 3, 4, 5, 6].map((i) => (
      <Card key={i} className="p-6">
        <div className="space-y-4">
          <div className="flex items-start justify-between">
            <div className="flex-1 space-y-2">
              <Skeleton className="h-5 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
            </div>
            <Skeleton className="h-6 w-12 rounded-full" />
          </div>
          <Skeleton className="h-3 w-full" />
          <Skeleton className="h-2 w-full rounded-full" />
          <div className="grid grid-cols-3 gap-2 pt-3">
            <Skeleton className="h-10 w-full" />
            <Skeleton className="h-10 w-full" />
            <Skeleton className="h-10 w-full" />
          </div>
        </div>
      </Card>
    ))}
  </div>
);

// Empty state component
interface EmptyStateProps {
  onClearFilters: () => void;
}

const EmptyState: React.FC<EmptyStateProps> = ({ onClearFilters }) => (
  <Card className="mx-auto max-w-md p-8 text-center">
    <div className="flex justify-center">
      <BookOpen className="h-16 w-16 text-gray-400" />
    </div>
    <h3 className="mt-4 text-lg font-semibold text-gray-900">
      No Decks Found
    </h3>
    <p className="mt-2 text-sm text-gray-600">
      No decks match your current filters. Try adjusting your search or
      clearing filters.
    </p>
    <Button variant="secondary" onClick={onClearFilters} className="mt-4">
      Clear All Filters
    </Button>
  </Card>
);
```

#### Key Features

1. **Page Structure**:
   - Container with responsive padding (px-4 on mobile, responsive py)
   - Page header with title and description
   - Filter section
   - Content area with conditional rendering

2. **State Management**:
   - Uses `useDeckStore` hook for decks, filters, loading, error
   - `useEffect` fetches decks on mount
   - Filters trigger automatic re-fetch via `setFilters`

3. **Conditional Rendering**:
   - **Error**: Red alert card with retry button
   - **Loading**: 6-card skeleton grid
   - **Success**: DecksGrid with actual decks
   - **Empty**: Centered empty state with "Clear Filters" button

4. **Loading Skeleton**:
   - Matches DeckCard layout structure
   - 6 skeleton cards in responsive grid
   - Shows during initial load and filter changes

5. **Empty State**:
   - Friendly message with icon
   - "Clear All Filters" action
   - Centered card layout

6. **Accessibility**:
   - Semantic HTML (h1, p)
   - Clear heading hierarchy
   - Error state with icon and descriptive text

#### Testing Points

- [ ] Page loads and fetches decks on mount
- [ ] Loading skeleton displays during fetch
- [ ] Decks grid displays after loading
- [ ] Error state shows with retry button
- [ ] Empty state displays when no results
- [ ] Filters update deck list in real-time
- [ ] Clear filters button resets to all decks
- [ ] Page header responsive (text size changes)
- [ ] Container padding responsive

---

### Step 4: Update Barrel Export (5 minutes)

**File**: `/src/components/decks/index.ts`

**Purpose**: Add new components to barrel export for clean imports.

#### Implementation

```typescript
// /src/components/decks/index.ts

// Existing exports from Task 04.03
export { DeckCard } from './DeckCard';
export type { DeckCardProps } from './DeckCard';

export { DeckBadge } from './DeckBadge';
export type { DeckBadgeProps } from './DeckBadge';

export { DeckProgressBar } from './DeckProgressBar';
export type { DeckProgressBarProps } from './DeckProgressBar';

// New exports from Task 04.04
export { DecksGrid } from './DecksGrid';
export type { DecksGridProps } from './DecksGrid';

export { DeckFilters } from './DeckFilters';
export type { DeckFiltersProps } from './DeckFilters';
```

#### Testing Points

- [ ] All exports resolve correctly
- [ ] No circular dependencies
- [ ] TypeScript types exported alongside components

---

### Step 5: Update App.tsx Route (5 minutes)

**File**: `/src/App.tsx`

**Purpose**: Replace placeholder `DecksPage` component with actual implementation.

#### Implementation

```typescript
// /src/App.tsx

import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';

import { AppLayout } from '@/components/layout';
import { Toaster } from '@/components/ui/toaster';
import { TooltipProvider } from '@/components/ui/tooltip';
import { LayoutProvider } from '@/contexts/LayoutContext';
import { RouteGuard } from '@/components/auth/RouteGuard';
import { ProtectedRoute } from '@/components/auth/ProtectedRoute';
import { PublicRoute } from '@/components/auth/PublicRoute';
import { Dashboard } from '@/pages/Dashboard';
import { Login } from '@/pages/auth/Login';
import { Register } from '@/pages/auth/Register';
import { ForgotPassword } from '@/pages/auth/ForgotPassword';
import { NotFound } from '@/pages/NotFound';
import { Unauthorized } from '@/pages/Unauthorized';
import { Profile } from '@/pages/Profile';
import { DecksPage } from '@/pages/DecksPage'; // NEW IMPORT
import { useActivityMonitor } from '@/hooks/useActivityMonitor';
import { SessionWarningDialog } from '@/components/auth/SessionWarningDialog';

// REMOVE OLD PLACEHOLDER:
// const DecksPage = () => (
//   <div>
//     <h1 className="mb-4 text-2xl font-semibold">All Decks</h1>
//     <p>Decks list will go here.</p>
//   </div>
// );

// ... rest of placeholders unchanged ...

function AppContent() {
  const { showWarning, remainingSeconds, extendSession } = useActivityMonitor();

  return (
    <>
      <RouteGuard>
        <Routes>
          {/* Public Routes - redirect to dashboard if authenticated */}
          <Route element={<PublicRoute />}>
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/forgot-password" element={<ForgotPassword />} />
          </Route>

          {/* Protected Routes - require authentication */}
          <Route element={<ProtectedRoute />}>
            <Route path="/" element={<AppLayout />}>
              <Route index element={<Dashboard />} />
              <Route path="dashboard" element={<Navigate to="/" replace />} />
              <Route path="decks" element={<DecksPage />} /> {/* UPDATED */}
              <Route path="statistics" element={<StatisticsPage />} />
              <Route path="stats" element={<Navigate to="/statistics" replace />} />
              <Route path="settings" element={<SettingsPage />} />
              <Route path="profile" element={<Profile />} />
              <Route path="review" element={<Dashboard />} /> {/* Temporary */}
            </Route>
          </Route>

          {/* Admin Routes - require admin role */}
          <Route element={<ProtectedRoute requiredRole="admin" />}>
            <Route path="/admin" element={<AppLayout />}>
              <Route index element={<AdminPanel />} />
            </Route>
          </Route>

          {/* Error Pages */}
          <Route path="/unauthorized" element={<Unauthorized />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </RouteGuard>

      {/* Session warning dialog */}
      <SessionWarningDialog
        open={showWarning}
        remainingSeconds={remainingSeconds}
        onExtendSession={extendSession}
      />

      <Toaster />
    </>
  );
}

// ... rest unchanged ...
```

#### Changes Summary

1. **Import**: Add `import { DecksPage } from '@/pages/DecksPage';`
2. **Remove**: Delete placeholder `DecksPage` function component
3. **Route**: `/decks` route now uses actual `DecksPage` component

#### Testing Points

- [ ] Navigate to `/decks` loads DecksPage
- [ ] Route protected (requires authentication)
- [ ] Navigation links to `/decks` work
- [ ] No placeholder component visible

---

### Step 6: Update Components-Reference.md (10 minutes)

**File**: `.claude/01-MVP/frontend/Components-Reference.md`

**Purpose**: Document `DecksGrid` and `DeckFilters` components in existing "Deck Management Components (8)" section.

#### Implementation

Add the following entries to the "Deck Management Components (8)" section (after DeckBadge):

```markdown
### 4. DecksGrid

**Purpose**: Responsive grid container for displaying deck cards in 1/2/3 column layout based on viewport width.

**File**: `/src/components/decks/DecksGrid.tsx`

**Interface**:
```typescript
interface DecksGridProps {
  decks: Deck[];                    // Array of decks to display
  onDeckClick?: (deckId: string) => void;  // Optional click handler (defaults to navigation)
}
```

**Usage**:
```tsx
import { DecksGrid } from '@/components/decks';
import { useDeckStore } from '@/stores/deckStore';

const { decks } = useDeckStore();

<DecksGrid decks={decks} />

// With custom click handler
<DecksGrid
  decks={decks}
  onDeckClick={(deckId) => console.log('Clicked:', deckId)}
/>
```

**Features**:
- Responsive grid layout (1 col mobile, 2 col tablet, 3 col desktop)
- 16px gap between cards (gap-4)
- ARIA list/listitem roles for accessibility
- Keyboard navigation via DeckCard components
- Default behavior: navigate to `/decks/:deckId`
- Optional custom click handler via props
- Empty array renders nothing (no errors)

**Props**:
| Name | Type | Default | Description |
|------|------|---------|-------------|
| decks | Deck[] | required | Array of deck objects to display in grid |
| onDeckClick | (deckId: string) => void | undefined | Optional click handler. If not provided, navigates to deck detail page. |

**Responsive Behavior**:
- **Mobile (< 768px)**: 1 column, full width cards
- **Tablet (768-1024px)**: 2 columns, equal width
- **Desktop (≥ 1024px)**: 3 columns, equal width
- Uses Tailwind classes: `grid-cols-1 md:grid-cols-2 lg:grid-cols-3`

---

### 5. DeckFilters

**Purpose**: Filter and search UI for deck browsing - includes search input, level toggles, status filters, and premium filter.

**File**: `/src/components/decks/DeckFilters.tsx`

**Interface**:
```typescript
interface DeckFiltersProps {
  filters: DeckFilters;             // Current filter state
  onChange: (filters: Partial<DeckFilters>) => void;  // Partial filter update handler
  onClear: () => void;               // Reset all filters handler
  totalDecks: number;                // Total available decks (before filtering)
  filteredDecks: number;             // Count of decks after filtering
}
```

**Usage**:
```tsx
import { DeckFilters } from '@/components/decks';
import { useDeckStore } from '@/stores/deckStore';

const { filters, setFilters, clearFilters, decks } = useDeckStore();

<DeckFilters
  filters={filters}
  onChange={setFilters}
  onClear={clearFilters}
  totalDecks={6}
  filteredDecks={decks.length}
/>
```

**Features**:
- **Search Input**: Debounced search (300ms delay) with clear button
- **Level Filter**: 4 toggles (A1, A2, B1, B2) with level badge colors
- **Status Filter**: 3 toggles (Not Started, In Progress, Completed)
- **Premium Filter**: Single toggle for premium-only decks (amber color)
- **Clear All Button**: Resets all filters, shows active filter count
- **Results Counter**: "Showing X of Y decks" for user feedback
- **Responsive Layout**: Wraps filter buttons on mobile
- **ARIA States**: aria-pressed for toggle buttons

**Props**:
| Name | Type | Default | Description |
|------|------|---------|-------------|
| filters | DeckFilters | required | Current active filter state from store |
| onChange | (filters: Partial<DeckFilters>) => void | required | Handler to update filters (partial updates) |
| onClear | () => void | required | Handler to reset all filters to defaults |
| totalDecks | number | required | Total count of decks before any filtering |
| filteredDecks | number | required | Count of decks after current filters applied |

**Filter Options**:
- **search**: string (debounced 300ms)
- **levels**: DeckLevel[] (A1, A2, B1, B2)
- **status**: DeckStatus[] (not-started, in-progress, completed)
- **showPremiumOnly**: boolean (true/false)

**Level Badge Colors**:
- **A1**: Green (bg-green-500)
- **A2**: Blue (bg-blue-500)
- **B1**: Orange (bg-orange-500)
- **B2**: Purple (bg-purple-600)

**Debounce Behavior**:
- Search input has 300ms debounce delay
- No API calls until user stops typing for 300ms
- Prevents excessive re-renders during typing
- Uses debounce utility from `/src/lib/utils.ts`

**Responsive Behavior**:
- **Mobile**: Filter buttons wrap vertically, search full width
- **Desktop**: Filters displayed in horizontal rows
- Uses Tailwind `flex-wrap` for responsive wrapping
```

#### Testing Points

- [ ] Documentation added to Components-Reference.md
- [ ] Both components documented (DecksGrid, DeckFilters)
- [ ] Interfaces match actual implementation
- [ ] Usage examples accurate
- [ ] Props tables complete
- [ ] Responsive behavior documented

---

### Step 7: Manual Testing & Polish (10 minutes)

#### Testing Checklist

**Visual Verification**:
- [ ] Page loads without errors
- [ ] Decks grid displays in correct columns (1/2/3)
- [ ] Filter buttons styled correctly
- [ ] Level badges show correct colors
- [ ] Premium decks show lock icon
- [ ] Loading skeleton displays during fetch
- [ ] Empty state shows when no results
- [ ] Error state displays with retry button

**Interaction Testing**:
- [ ] Search input debounces (300ms)
- [ ] Clear search button works
- [ ] Level filters toggle on/off
- [ ] Multiple levels can be selected
- [ ] Status filters work independently
- [ ] Premium filter shows only premium decks
- [ ] Clear all filters button works
- [ ] Click deck card navigates to detail page (or shows error if not implemented)

**Responsive Testing**:
- [ ] Test at 375px (mobile)
- [ ] Test at 768px (tablet)
- [ ] Test at 1024px (desktop)
- [ ] Test at 1440px (wide desktop)
- [ ] Filters wrap correctly on mobile
- [ ] Cards maintain aspect ratio

**Accessibility Testing**:
- [ ] Tab navigation works
- [ ] ARIA labels present
- [ ] Screen reader announces "X of Y decks"
- [ ] Filter toggle states announced (aria-pressed)
- [ ] Error state announces to screen reader

**Performance Checks**:
- [ ] No console errors
- [ ] No unnecessary re-renders
- [ ] Debounce prevents excessive filtering
- [ ] Skeleton shows immediately on load

---

## Component Specifications

### DecksGrid Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `decks` | `Deck[]` | Yes | - | Array of deck objects to display |
| `onDeckClick` | `(deckId: string) => void` | No | Navigate to `/decks/:id` | Click handler for deck selection |

### DeckFilters Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `filters` | `DeckFilters` | Yes | - | Current active filter state |
| `onChange` | `(filters: Partial<DeckFilters>) => void` | Yes | - | Handler for filter updates |
| `onClear` | `() => void` | Yes | - | Handler to reset filters |
| `totalDecks` | `number` | Yes | - | Total decks before filtering |
| `filteredDecks` | `number` | Yes | - | Decks after filtering |

### DecksPage State Flow

```
Mount → useEffect → fetchDecks()
                        ↓
                   isLoading=true
                        ↓
                 Show Skeleton
                        ↓
                 Fetch completes
                        ↓
            ┌───────────┴───────────┐
            ↓                       ↓
         Success                 Error
            ↓                       ↓
    decks=[...data]          error="message"
    isLoading=false          isLoading=false
            ↓                       ↓
    Show DecksGrid          Show Error Card
```

---

## Testing Strategy

### Unit Testing (Optional - If Time Permits)

```typescript
// /src/components/decks/__tests__/DecksGrid.test.tsx

import { render, screen } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { DecksGrid } from '../DecksGrid';
import { MOCK_DECKS } from '@/services/mockDeckData';

describe('DecksGrid', () => {
  it('renders all decks', () => {
    render(
      <BrowserRouter>
        <DecksGrid decks={MOCK_DECKS} />
      </BrowserRouter>
    );
    expect(screen.getAllByRole('listitem')).toHaveLength(MOCK_DECKS.length);
  });

  it('renders empty when no decks', () => {
    const { container } = render(
      <BrowserRouter>
        <DecksGrid decks={[]} />
      </BrowserRouter>
    );
    expect(container.querySelector('[role="list"]')).toBeEmptyDOMElement();
  });
});
```

### Manual Testing Scenarios

#### Scenario 1: First Load
1. Navigate to `/decks`
2. **Expected**: Loading skeleton shows (6 cards)
3. **Expected**: After ~300ms, decks grid appears
4. **Expected**: 6 decks displayed in 3 columns (desktop)

#### Scenario 2: Filter by Level
1. Click "A1" level filter
2. **Expected**: Only A1 decks displayed (3 decks)
3. **Expected**: Results counter shows "3 of 6 decks"
4. Click "A2" level filter (in addition to A1)
5. **Expected**: A1 and A2 decks displayed (5 decks)

#### Scenario 3: Search
1. Type "family" in search input
2. **Expected**: After 300ms, shows 1 deck ("Family & Relationships")
3. Clear search with X button
4. **Expected**: All decks appear again

#### Scenario 4: Premium Filter
1. Click "Premium Only" filter
2. **Expected**: Shows 2 premium decks (Food & Dining, Work & Professional)
3. **Expected**: Both show lock icon

#### Scenario 5: Empty State
1. Apply filters: Level A1, Status "Completed"
2. **Expected**: Empty state card displays
3. Click "Clear All Filters"
4. **Expected**: All decks appear again

#### Scenario 6: Error Handling
1. Simulate network error (modify deckStore to throw error)
2. **Expected**: Red error card displays
3. Click "Try Again"
4. **Expected**: Refetches decks

---

## Success Criteria Checklist

### Functional Requirements (15 items)

- [ ] **F1**: DecksPage component renders without errors
- [ ] **F2**: Decks grid displays all 6 mock decks on initial load
- [ ] **F3**: Search input filters decks by title (Greek or English)
- [ ] **F4**: Search debounces with 300ms delay
- [ ] **F5**: Level filter (A1/A2/B1/B2) works correctly
- [ ] **F6**: Multiple level filters can be combined
- [ ] **F7**: Status filter (not-started/in-progress/completed) works
- [ ] **F8**: Premium filter shows only premium decks
- [ ] **F9**: "Clear All Filters" button resets all filters
- [ ] **F10**: Results counter shows "X of Y decks" accurately
- [ ] **F11**: Loading skeleton displays during deck fetch
- [ ] **F12**: Empty state displays when no decks match filters
- [ ] **F13**: Error state displays with retry button on API failure
- [ ] **F14**: Clicking deck card navigates to `/decks/:id` (or shows placeholder)
- [ ] **F15**: All components use existing DeckCard from Task 04.03

### Visual & Design (15 items)

- [ ] **V1**: Responsive grid: 1 column (mobile), 2 columns (tablet), 3 columns (desktop)
- [ ] **V2**: Grid gap is 16px (gap-4) between cards
- [ ] **V3**: Page header displays "Available Decks" with description
- [ ] **V4**: Search input has magnifying glass icon on left
- [ ] **V5**: Clear search button (X icon) appears when typing
- [ ] **V6**: Level filter buttons show badge colors when active (green/blue/orange/purple)
- [ ] **V7**: Active filters display in blue (default variant)
- [ ] **V8**: Premium filter shows amber color when active
- [ ] **V9**: Clear all button shows active filter count
- [ ] **V10**: Loading skeleton matches DeckCard structure
- [ ] **V11**: Empty state shows BookOpen icon and centered message
- [ ] **V12**: Error state shows red alert with AlertCircle icon
- [ ] **V13**: Greek text renders correctly in all deck cards
- [ ] **V14**: Premium decks show lock icon (amber-500)
- [ ] **V15**: Page padding responsive (px-4 mobile, adjusts for desktop)

### Responsive Behavior (10 items)

- [ ] **R1**: Test at 375px width (mobile)
- [ ] **R2**: Test at 768px width (tablet breakpoint)
- [ ] **R3**: Test at 1024px width (desktop breakpoint)
- [ ] **R4**: Test at 1440px width (wide desktop)
- [ ] **R5**: Filter buttons wrap on mobile (flex-wrap)
- [ ] **R6**: Search input full width on mobile
- [ ] **R7**: Deck cards maintain aspect ratio across breakpoints
- [ ] **R8**: Page header text size responsive (2xl → 3xl)
- [ ] **R9**: Container padding responsive (py-6 → py-8)
- [ ] **R10**: No horizontal scroll on any breakpoint

### Accessibility (10 items)

- [ ] **A1**: DecksGrid has `role="list"` and `aria-label="Available decks"`
- [ ] **A2**: Each deck has `role="listitem"`
- [ ] **A3**: Search input has `aria-label="Search decks"`
- [ ] **A4**: Clear search button has `aria-label="Clear search"`
- [ ] **A5**: Filter buttons have `aria-pressed` state
- [ ] **A6**: Results counter announces to screen readers
- [ ] **A7**: Error state announces with AlertCircle icon
- [ ] **A8**: Keyboard navigation works (Tab through filters)
- [ ] **A9**: Focus indicators visible on all interactive elements
- [ ] **A10**: Heading hierarchy correct (h1 for page title)

### Integration & State (5 items)

- [ ] **I1**: Uses `useDeckStore` hook correctly
- [ ] **I2**: `fetchDecks()` called on mount via `useEffect`
- [ ] **I3**: `setFilters()` triggers automatic re-fetch
- [ ] **I4**: `clearFilters()` resets to default state
- [ ] **I5**: Store state updates reflect in UI immediately

### Documentation (5 items)

- [ ] **D1**: Components-Reference.md updated with DecksGrid entry
- [ ] **D2**: Components-Reference.md updated with DeckFilters entry
- [ ] **D3**: Both entries include TypeScript interfaces
- [ ] **D4**: Usage examples include realistic code
- [ ] **D5**: Props tables complete with name/type/default/description

### TypeScript & Code Quality (5 items)

- [ ] **T1**: No TypeScript compilation errors
- [ ] **T2**: No `any` types used
- [ ] **T3**: All component props have interfaces
- [ ] **T4**: Debounce utility typed correctly
- [ ] **T5**: No ESLint warnings or errors

---

## Common Pitfalls & Solutions

### Pitfall 1: Debounce Not Working

**Symptom**: Search triggers immediately instead of after 300ms delay.

**Cause**: `debounce` function recreated on every render, breaking closure.

**Solution**:
```typescript
// WRONG - debounce recreated every render
const handleSearch = debounce((value) => onChange({ search: value }), 300);

// CORRECT - use useCallback to memoize
const debouncedSearch = useCallback(
  debounce((value: string) => onChange({ search: value }), 300),
  [onChange]
);
```

---

### Pitfall 2: Filter State Not Syncing

**Symptom**: Filter UI shows active, but decks don't filter.

**Cause**: Local state not synced with store state.

**Solution**:
```typescript
// Ensure local searchInput state initializes from store
const [searchInput, setSearchInput] = useState(filters.search);

// Update local state when store resets
useEffect(() => {
  setSearchInput(filters.search);
}, [filters.search]);
```

---

### Pitfall 3: Infinite Re-fetch Loop

**Symptom**: `fetchDecks()` called repeatedly, causing infinite loading.

**Cause**: `useEffect` dependency array includes `fetchDecks` but it's not memoized.

**Solution**:
```typescript
// Zustand actions are stable by default, so this is safe:
useEffect(() => {
  fetchDecks();
}, [fetchDecks]); // fetchDecks from Zustand is stable

// Alternative: Ignore ESLint warning and omit dependency
useEffect(() => {
  fetchDecks();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // Only fetch on mount
```

---

### Pitfall 4: Grid Layout Breaks on Mobile

**Symptom**: Cards overflow or don't stack properly on mobile.

**Cause**: Missing responsive grid classes.

**Solution**:
```typescript
// WRONG - no responsive classes
<div className="grid grid-cols-3 gap-4">

// CORRECT - mobile-first responsive
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
```

---

### Pitfall 5: Empty State Always Shows

**Symptom**: Empty state shows even when decks exist.

**Cause**: Condition checks before loading completes.

**Solution**:
```typescript
// WRONG - checks before loading finishes
{decks.length === 0 && <EmptyState />}

// CORRECT - check loading state first
{!isLoading && !error && decks.length === 0 && <EmptyState />}
```

---

### Pitfall 6: Premium Filter Shows No Decks

**Symptom**: Premium filter shows empty state despite premium decks existing.

**Cause**: Store filter logic doesn't check `isPremium` field.

**Solution**: Verify `mockDeckAPI.ts` includes premium filtering:
```typescript
// In mockDeckAPI.ts
if (filters.showPremiumOnly) {
  decks = decks.filter(deck => deck.isPremium);
}
```

---

### Pitfall 7: Greek Text Not Displaying

**Symptom**: Greek characters show as boxes or question marks.

**Cause**: Missing UTF-8 encoding or font loading issue.

**Solution**:
1. Verify `index.html` has `<meta charset="UTF-8">`
2. Check console for font loading errors
3. Verify Greek text in `mockDeckData.ts` is properly encoded
4. Test in multiple browsers (Chrome, Firefox, Safari)

---

### Pitfall 8: Skeleton Flashes Too Quickly

**Symptom**: Skeleton shows for <100ms, creating visual jank.

**Cause**: Mock API delay too short, or skeleton not showing during filter changes.

**Solution**:
```typescript
// In mockDeckAPI.ts - ensure realistic delay
await simulateDelay(300); // Minimum 300ms

// In component - show skeleton during filter changes too
{isLoading && <DeckGridSkeleton />}
```

---

## Accessibility Requirements

### WCAG AA Compliance

#### Color Contrast
- [ ] All text meets 4.5:1 contrast ratio (body text)
- [ ] Large text meets 3:1 contrast ratio (headings)
- [ ] Filter button text readable against background
- [ ] Error text (red) readable against light red background

#### Keyboard Navigation
- [ ] Tab order follows visual hierarchy (filters → decks)
- [ ] All interactive elements keyboard accessible
- [ ] Enter/Space activates filter buttons
- [ ] Escape key clears search input
- [ ] Focus indicators visible (2px outline)

#### ARIA Attributes

```typescript
// DecksGrid
<div
  role="list"
  aria-label="Available decks"
>
  <div role="listitem">
    {/* DeckCard handles own accessibility */}
  </div>
</div>

// Search Input
<Input
  aria-label="Search decks"
  aria-describedby="search-hint"
/>

// Filter Buttons
<Button
  aria-pressed={isActive}
  aria-label={`Filter by ${label}`}
/>

// Results Counter
<div
  aria-live="polite"
  aria-atomic="true"
>
  Showing {count} of {total} decks
</div>
```

#### Screen Reader Announcements
- [ ] Page title announced on load ("Available Decks")
- [ ] Results counter updates announced (aria-live="polite")
- [ ] Filter changes announced via state change
- [ ] Error messages announced immediately (aria-live="assertive")
- [ ] Empty state message announced

#### Focus Management
- [ ] Focus stays in viewport during filter changes
- [ ] Focus returns to filter after clearing
- [ ] Deck click moves focus to detail page (future)
- [ ] Modal dialogs trap focus (if added later)

---

## Documentation Requirements

### Components-Reference.md Updates

**Section**: Deck Management Components (8)

**Add 2 New Entries**:

1. **DecksGrid** (Component #4 in section)
   - Purpose statement
   - File location: `/src/components/decks/DecksGrid.tsx`
   - TypeScript interface with prop descriptions
   - Usage example with import statement
   - Features list (7 features)
   - Props table (2 props)
   - Responsive behavior (3 breakpoints)

2. **DeckFilters** (Component #5 in section)
   - Purpose statement
   - File location: `/src/components/decks/DeckFilters.tsx`
   - TypeScript interface with prop descriptions
   - Usage example with store integration
   - Features list (10 features)
   - Props table (5 props)
   - Filter options breakdown
   - Level badge colors
   - Debounce behavior explanation
   - Responsive behavior

**Format**: Follow existing component documentation pattern in Components-Reference.md (see DeckCard, DeckBadge examples).

**Verification**:
- [ ] Markdown formatting correct
- [ ] Code blocks have language tags
- [ ] Interface matches actual implementation
- [ ] Usage examples are copy-paste ready
- [ ] Props tables use consistent formatting
- [ ] File paths are absolute and correct

---

## Appendix: File Checklist

### Files to Create (3 files)

- [ ] `/src/components/decks/DecksGrid.tsx` (50 lines)
- [ ] `/src/components/decks/DeckFilters.tsx` (180 lines)
- [ ] `/src/pages/DecksPage.tsx` (150 lines)

### Files to Modify (3 files)

- [ ] `/src/components/decks/index.ts` (add 4 lines)
- [ ] `/src/App.tsx` (add 1 import, remove 1 placeholder, update 1 route)
- [ ] `/src/lib/utils.ts` (add debounce function if not present)
- [ ] `.claude/01-MVP/frontend/Components-Reference.md` (add 2 component entries)

### Files NOT to Modify
- `/src/stores/deckStore.ts` (already complete from Task 04.02)
- `/src/types/deck.ts` (already complete from Task 04.01)
- `/src/services/mockDeckData.ts` (already complete from Task 04.01)
- `/src/services/mockDeckAPI.ts` (already complete from Task 04.01)
- `/src/components/decks/DeckCard.tsx` (already complete from Task 04.03)
- `/src/components/decks/DeckBadge.tsx` (already complete from Task 04.03)
- `/src/components/decks/DeckProgressBar.tsx` (already complete from Task 04.03)

---

## Time Breakdown

| Step | Task | Estimated Time |
|------|------|----------------|
| 1 | Create DecksGrid Component | 15 minutes |
| 2 | Create DeckFilters Component | 25 minutes |
| 3 | Create DecksPage Component | 20 minutes |
| 4 | Update Barrel Export | 5 minutes |
| 5 | Update App.tsx Route | 5 minutes |
| 6 | Update Components-Reference.md | 10 minutes |
| 7 | Manual Testing & Polish | 10 minutes |
| **Total** | | **75 minutes** |

---

## Next Steps After Completion

1. **Task 04.05**: Create Deck Detail Page (`/decks/:id` route)
2. **Task 04.06**: Add advanced filtering (categories, tags)
3. **Task 04.07**: Implement deck progress tracking integration
4. **Task 05**: Flashcard Review System (connect "Start Learning" button)

---

## Additional Notes

### Greek Typography Handling

- All Greek text (`titleGreek`) rendered via existing `DeckCard` component
- UTF-8 encoding verified in `mockDeckData.ts`
- System font stack supports Greek characters: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto`
- Test in Chrome, Firefox, Safari, Edge for cross-browser compatibility

### Premium Access UI Patterns

- Lock icon (`Lock` from lucide-react) shown on premium decks
- Free tier users see 70% opacity on locked premium cards (handled by `DeckCard`)
- Premium filter shows all premium decks (locked and unlocked)
- Future: Add "Upgrade to Premium" CTA in empty state when premium filter active

### Mock Backend Integration

- All API calls go through `mockDeckAPI.ts`
- Realistic 300ms delays simulate network latency
- Error handling built into `deckStore` (catch blocks, error state)
- Future: Replace `mockDeckAPI` with real API client (TanStack Query)

### State Management Flow

```
User Action → DeckFilters.onChange
                    ↓
            useDeckStore.setFilters
                    ↓
          Store updates filters state
                    ↓
            Automatically calls fetchDecks()
                    ↓
          mockDeckAPI.getAllDecks(filters)
                    ↓
            Store updates decks array
                    ↓
           DecksGrid re-renders with filtered decks
```

---

**Plan Created**: 2025-11-01
**Plan Status**: Ready for Executor
**Total Estimated Duration**: 75 minutes
**Success Criteria Items**: 60+ checklist items
**Documentation Updates**: Components-Reference.md (2 components)

---

**End of Implementation Plan**
