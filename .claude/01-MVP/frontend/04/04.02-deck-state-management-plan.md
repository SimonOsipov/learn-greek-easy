# Task 04.02: Implement Deck State Management - Implementation Plan

**Status**: Ready for Execution
**Created**: 2025-11-01
**Priority**: High (Foundation)
**Estimated Duration**: 45 minutes
**Parent Task**: 04 - Deck Management Interface
**Dependencies**: Task 04.01 (Deck Data Types and Mock Service) ✅ Completed

---

## ✅ TASK COMPLETED

**Status**: COMPLETE
**Completion Date**: 2025-11-01
**Actual Duration**: ~45 minutes (matched estimate)
**Verification**: PASS (all success criteria met)

**Deliverables**:
- ✅ `/src/stores/deckStore.ts` (437 lines)
- ✅ All 8 actions implemented
- ✅ TypeScript: 0 compilation errors
- ✅ Premium access control: Working
- ✅ localStorage persistence: Correct (only deckProgress)
- ✅ Integration: Auth store, Mock API, Type definitions
- ✅ Code quality: 17 TODO comments, no `any` types, JSDoc present
- ✅ Error handling: Consistent pattern across all async actions

**Verification Report**: See `/Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/frontend/04/04.02-test-report.md`

**Next Task**: 04.03 - Create Deck Card Component (70 min)

---

## Executive Summary

This implementation plan provides a step-by-step guide for creating a Zustand-based state management system for deck operations. The store will manage deck data, user progress, filters, and UI states while integrating with the existing auth store for premium access control.

**CRITICAL ARCHITECTURAL NOTE**: This implementation is **temporary for MVP**. The deck data and progress will eventually migrate to a backend (PostgreSQL + FastAPI). Clear TODO comments will mark migration points throughout the code.

---

## Table of Contents

1. [File Structure](#file-structure)
2. [State Architecture](#state-architecture)
3. [Implementation Steps](#implementation-steps)
4. [Code Implementation](#code-implementation)
5. [Testing Strategy](#testing-strategy)
6. [Success Criteria](#success-criteria)
7. [Common Pitfalls](#common-pitfalls)
8. [Backend Migration Notes](#backend-migration-notes)
9. [Time Breakdown](#time-breakdown)

---

## File Structure

### File to Create

**Location**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-frontend/src/stores/deckStore.ts`

**Purpose**: Global state management for deck browsing, selection, filtering, and progress tracking

**Size Estimate**: ~250-300 lines

**Dependencies**:
- `zustand` - Already installed (v5.0.2)
- `zustand/middleware` - For persist middleware
- `@/types/deck` - Type definitions from Task 04.01
- `@/services/mockDeckAPI` - API methods from Task 04.01
- `@/stores/authStore` - For premium access checks

---

## State Architecture

### State Shape

```typescript
interface DeckState {
  // ========================================
  // DATA STATE (TODO: Move to backend when ready)
  // ========================================

  decks: Deck[];                              // All available decks (from API)
  selectedDeck: Deck | null;                  // Currently selected deck
  deckProgress: Record<string, DeckProgress>; // User progress per deck (key: deckId)

  // ========================================
  // UI STATE (Keep on frontend after migration)
  // ========================================

  filters: DeckFilters;                       // Active filter settings
  isLoading: boolean;                         // Loading state for async ops
  error: string | null;                       // Error message for display

  // ========================================
  // ACTIONS
  // ========================================

  // Deck fetching and selection
  fetchDecks: () => Promise<void>;
  selectDeck: (deckId: string) => Promise<void>;
  clearSelection: () => void;

  // Filter management
  setFilters: (filters: Partial<DeckFilters>) => void;
  clearFilters: () => void;

  // Learning flow
  startLearning: (deckId: string) => Promise<void>;
  updateProgress: (deckId: string, progress: Partial<DeckProgress>) => void;

  // Error handling
  clearError: () => void;
}
```

### Default Filter State

```typescript
const DEFAULT_FILTERS: DeckFilters = {
  search: '',
  levels: [],              // Empty = show all levels
  categories: [],          // Empty = show all categories
  status: [],              // Empty = show all statuses
  showPremiumOnly: false,  // Default to showing all decks
};
```

### Persistence Strategy

**Persist to localStorage**:
- `deckProgress` - User's learning progress (temporary until backend ready)

**DO NOT persist** (reset on page load):
- `decks` - Always fetch fresh from API
- `selectedDeck` - User context resets
- `filters` - Start with default filters each session
- `isLoading`, `error` - Temporary UI states

**Rationale**: Progress is the only user-generated data that needs persistence. Everything else should be fresh on each session to prevent stale data issues.

---

## Implementation Steps

### Step 1: File Setup and Imports (3 minutes)

**Objective**: Set up the file structure with all necessary imports and type definitions.

**Actions**:
1. Create new file: `/src/stores/deckStore.ts`
2. Add file header comment explaining temporary nature
3. Import Zustand and middleware
4. Import types from deck types
5. Import mock API methods
6. Import auth store for premium checks

**Code Template**:
```typescript
// src/stores/deckStore.ts

/**
 * Deck State Management Store
 *
 * ⚠️ TEMPORARY IMPLEMENTATION (MVP)
 *
 * This store manages deck data and progress on the frontend using:
 * - Zustand for state management
 * - localStorage for progress persistence
 * - Mock API with simulated delays
 *
 * TODO: Backend Migration Required
 * When backend is ready, refactor as follows:
 * 1. Replace mockDeckAPI with real API client
 * 2. Install TanStack Query for server state
 * 3. Move decks & progress to PostgreSQL
 * 4. Keep only UI state (filters, selectedDeckId) in Zustand
 * 5. Remove localStorage persistence for progress
 *
 * Estimated migration time: 4-6 hours
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { Deck, DeckProgress, DeckFilters } from '@/types/deck';
import { mockDeckAPI } from '@/services/mockDeckAPI';
import { useAuthStore } from '@/stores/authStore';
```

**Validation**:
- [ ] All imports resolve without TypeScript errors
- [ ] File header comment clearly explains temporary nature
- [ ] `import type` syntax used for type-only imports

---

### Step 2: Define Default States and Constants (3 minutes)

**Objective**: Set up default filter state and any necessary constants.

**Actions**:
1. Define `DEFAULT_FILTERS` constant
2. Add JSDoc comments explaining each filter's purpose

**Code Template**:
```typescript
/**
 * Default filter state
 * Resets on each session to prevent stale filter preferences
 */
const DEFAULT_FILTERS: DeckFilters = {
  search: '',              // Empty search = show all
  levels: [],              // Empty = show all levels (A1, A2, B1, B2)
  categories: [],          // Empty = show all categories
  status: [],              // Empty = show all statuses (not-started, in-progress, completed)
  showPremiumOnly: false,  // Default to showing both free and premium decks
};
```

**Validation**:
- [ ] DEFAULT_FILTERS matches DeckFilters interface exactly
- [ ] All array fields initialized as empty arrays (not undefined)
- [ ] Boolean fields have explicit false values

---

### Step 3: Define State Interface (5 minutes)

**Objective**: Create the TypeScript interface for the complete store state.

**Actions**:
1. Define `DeckState` interface with all state properties
2. Add JSDoc comments marking what moves to backend
3. Define all action method signatures

**Code Template**:
```typescript
/**
 * Deck Store State Interface
 */
interface DeckState {
  // ========================================
  // DATA STATE
  // TODO: Move to backend (PostgreSQL) when ready
  // ========================================

  /** All available decks (fetched from API) */
  decks: Deck[];

  /** Currently selected deck for detail view */
  selectedDeck: Deck | null;

  /** User's learning progress per deck (key: deckId)
   * TODO: Move to backend user_deck_progress table
   */
  deckProgress: Record<string, DeckProgress>;

  // ========================================
  // UI STATE
  // Keep on frontend after backend migration
  // ========================================

  /** Active filter settings */
  filters: DeckFilters;

  /** Loading state for async operations */
  isLoading: boolean;

  /** Error message for user display (null = no error) */
  error: string | null;

  // ========================================
  // ACTIONS
  // ========================================

  /**
   * Fetch all decks from API with current filters applied
   * Sets isLoading, populates decks array, handles errors
   */
  fetchDecks: () => Promise<void>;

  /**
   * Select a deck by ID and fetch its full details
   * Sets selectedDeck, handles errors
   * @param deckId - Unique deck identifier
   */
  selectDeck: (deckId: string) => Promise<void>;

  /**
   * Clear the currently selected deck
   */
  clearSelection: () => void;

  /**
   * Update filter settings (partial update)
   * Automatically triggers deck re-fetch
   * @param filters - Partial filter updates
   */
  setFilters: (filters: Partial<DeckFilters>) => void;

  /**
   * Reset all filters to default state
   */
  clearFilters: () => void;

  /**
   * Initialize deck for learning (create initial progress)
   * Checks premium access before allowing start
   * @param deckId - Deck to start learning
   */
  startLearning: (deckId: string) => Promise<void>;

  /**
   * Update user's progress for a deck
   * TODO: Replace with API call when backend ready
   * @param deckId - Deck being updated
   * @param progress - Partial progress updates
   */
  updateProgress: (deckId: string, progress: Partial<DeckProgress>) => void;

  /**
   * Clear current error message
   */
  clearError: () => void;
}
```

**Validation**:
- [ ] All state properties typed correctly
- [ ] All action methods have proper parameter and return types
- [ ] JSDoc comments mark backend migration points
- [ ] Promise return types used for async actions

---

### Step 4: Implement Core Store Logic (20 minutes)

**Objective**: Implement the Zustand store with all actions and state management logic.

**Actions**:
1. Create store with `create()` and `persist()` middleware
2. Implement initial state
3. Implement `fetchDecks` action with error handling
4. Implement `selectDeck` action with premium checks
5. Implement `clearSelection` action
6. Implement `setFilters` action with auto-refetch
7. Implement `clearFilters` action
8. Implement `startLearning` action with premium validation
9. Implement `updateProgress` action with localStorage sync
10. Implement `clearError` action
11. Configure persist middleware to only save `deckProgress`

**Code Template** (see next section for full implementation)

**Key Implementation Details**:

**Error Handling Pattern**:
```typescript
try {
  set({ isLoading: true, error: null });
  // ... API call
  set({ isLoading: false });
} catch (error) {
  const errorMessage = error instanceof Error
    ? error.message
    : 'An unexpected error occurred';
  set({
    isLoading: false,
    error: errorMessage
  });
  throw error; // Re-throw for component-level handling
}
```

**Premium Access Check Pattern**:
```typescript
const { user } = useAuthStore.getState();
const isPremiumLocked = deck.isPremium && user?.role === 'free';

if (isPremiumLocked) {
  throw new Error('This is a premium deck. Please upgrade to access.');
}
```

**Progress Update Pattern**:
```typescript
updateProgress: (deckId: string, progress: Partial<DeckProgress>) => {
  set((state) => ({
    deckProgress: {
      ...state.deckProgress,
      [deckId]: {
        ...state.deckProgress[deckId],
        ...progress,
      },
    },
  }));
}
```

**Validation**:
- [ ] All async operations set `isLoading` true before, false after
- [ ] All errors caught and set to `error` state
- [ ] Premium access checked before `startLearning`
- [ ] Filters trigger automatic `fetchDecks` call
- [ ] Progress updates persist immediately to localStorage

---

### Step 5: Configure Persistence Middleware (5 minutes)

**Objective**: Set up localStorage persistence for deck progress only.

**Actions**:
1. Configure persist middleware in store creation
2. Use `partialize` to only persist `deckProgress`
3. Set storage key name
4. Test persistence in browser

**Code Template**:
```typescript
export const useDeckStore = create<DeckState>()(
  persist(
    (set, get) => ({
      // ... store implementation
    }),
    {
      name: 'deck-progress-storage', // localStorage key
      storage: createJSONStorage(() => localStorage),

      // Only persist user progress (temporary until backend)
      partialize: (state) => ({
        deckProgress: state.deckProgress,
      }),

      // TODO: Remove this persist configuration when migrating to backend
      // Progress will be stored in PostgreSQL user_deck_progress table
    }
  )
);
```

**Why Only Persist Progress?**:
- **decks**: Should always be fresh from API (prevents stale data)
- **selectedDeck**: User context resets each session
- **filters**: Better UX to start with clean slate
- **deckProgress**: Only user-generated data that needs survival across sessions

**Validation**:
- [ ] localStorage key is descriptive and unique
- [ ] Only `deckProgress` appears in localStorage after updates
- [ ] Progress persists across page refreshes
- [ ] Other state resets to defaults after refresh

---

### Step 6: Add Export and Type Safety (2 minutes)

**Objective**: Export the store and ensure TypeScript type safety.

**Actions**:
1. Export the store hook
2. Verify all types are properly inferred
3. Add final file comment about migration

**Code Template**:
```typescript
/**
 * Deck store hook for components
 *
 * Usage:
 * const { decks, fetchDecks, selectDeck } = useDeckStore();
 *
 * useEffect(() => {
 *   fetchDecks();
 * }, [fetchDecks]);
 */
export const useDeckStore = create<DeckState>()(
  // ... implementation
);

// Type-safe selectors can be created like:
// const decks = useDeckStore(state => state.decks);
// const isLoading = useDeckStore(state => state.isLoading);
```

**Validation**:
- [ ] Store exports without TypeScript errors
- [ ] Type inference works in IDE (hover shows correct types)
- [ ] No `any` types in implementation

---

### Step 7: Manual Testing and Validation (7 minutes)

**Objective**: Test the store in browser to verify all functionality works.

**Actions**:
1. Start dev server: `npm run dev`
2. Open browser console
3. Import and test store methods
4. Verify localStorage persistence
5. Test error scenarios
6. Test premium access blocking

**Test Script** (run in browser console):
```javascript
// Import store
import { useDeckStore } from './stores/deckStore';

// Get store instance
const store = useDeckStore.getState();

// Test 1: Fetch all decks
console.log('Test 1: Fetching all decks...');
await store.fetchDecks();
console.log(`✓ Loaded ${store.decks.length} decks`); // Should be 6

// Test 2: Apply filters
console.log('\nTest 2: Filter by A1 level...');
store.setFilters({ levels: ['A1'] });
console.log(`✓ Filtered to ${store.decks.length} decks`); // Should be 3

// Test 3: Search
console.log('\nTest 3: Search for "food"...');
store.setFilters({ search: 'food' });
console.log(`✓ Found ${store.decks.length} decks`); // Should be 1

// Test 4: Select deck
console.log('\nTest 4: Select deck...');
await store.selectDeck('deck-a1-basics');
console.log(`✓ Selected: ${store.selectedDeck?.title}`);

// Test 5: Start learning (free deck)
console.log('\nTest 5: Start learning free deck...');
await store.startLearning('deck-a1-basics');
console.log(`✓ Progress initialized: ${store.deckProgress['deck-a1-basics'].status}`);

// Test 6: Try premium deck as free user
console.log('\nTest 6: Try premium deck (should fail)...');
try {
  await store.startLearning('deck-a2-food'); // Premium deck
  console.error('✗ Should have thrown error!');
} catch (e) {
  console.log(`✓ Correctly blocked: ${e.message}`);
}

// Test 7: Update progress
console.log('\nTest 7: Update progress...');
store.updateProgress('deck-a1-basics', {
  cardsMastered: 10,
  accuracy: 85
});
console.log(`✓ Progress updated: ${store.deckProgress['deck-a1-basics'].cardsMastered} mastered`);

// Test 8: Check localStorage
console.log('\nTest 8: Check localStorage persistence...');
const stored = localStorage.getItem('deck-progress-storage');
console.log(`✓ Progress stored:`, JSON.parse(stored));

// Test 9: Clear filters
console.log('\nTest 9: Clear filters...');
store.clearFilters();
console.log(`✓ Filters reset, showing ${store.decks.length} decks`); // Should be 6

// Test 10: Error handling
console.log('\nTest 10: Test error handling...');
try {
  await store.selectDeck('invalid-deck-id');
  console.error('✗ Should have thrown error!');
} catch (e) {
  console.log(`✓ Error handled: ${store.error}`);
}

console.log('\n✅ All tests passed!');
```

**Expected Results**:
- Test 1: 6 decks loaded
- Test 2: 3 A1 decks shown
- Test 3: 1 food deck found
- Test 4: Deck selected without error
- Test 5: Progress initialized
- Test 6: Premium blocked with error
- Test 7: Progress updated in state
- Test 8: Progress visible in localStorage
- Test 9: All 6 decks shown again
- Test 10: Error set in state

**Validation**:
- [ ] All 10 tests pass
- [ ] No console errors (except expected premium block)
- [ ] localStorage updates correctly
- [ ] Premium access blocking works
- [ ] Error messages are user-friendly

---

## Code Implementation

### Complete Store Implementation

```typescript
// src/stores/deckStore.ts

/**
 * Deck State Management Store
 *
 * ⚠️ TEMPORARY IMPLEMENTATION (MVP)
 *
 * This store manages deck data and progress on the frontend using:
 * - Zustand for state management
 * - localStorage for progress persistence
 * - Mock API with simulated delays
 *
 * TODO: Backend Migration Required
 * When backend is ready, refactor as follows:
 * 1. Replace mockDeckAPI with real API client
 * 2. Install TanStack Query for server state
 * 3. Move decks & progress to PostgreSQL
 * 4. Keep only UI state (filters, selectedDeckId) in Zustand
 * 5. Remove localStorage persistence for progress
 *
 * Estimated migration time: 4-6 hours
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { Deck, DeckProgress, DeckFilters } from '@/types/deck';
import { mockDeckAPI } from '@/services/mockDeckAPI';
import { useAuthStore } from '@/stores/authStore';

/**
 * Default filter state
 * Resets on each session to prevent stale filter preferences
 */
const DEFAULT_FILTERS: DeckFilters = {
  search: '',              // Empty search = show all
  levels: [],              // Empty = show all levels (A1, A2, B1, B2)
  categories: [],          // Empty = show all categories
  status: [],              // Empty = show all statuses (not-started, in-progress, completed)
  showPremiumOnly: false,  // Default to showing both free and premium decks
};

/**
 * Deck Store State Interface
 */
interface DeckState {
  // ========================================
  // DATA STATE
  // TODO: Move to backend (PostgreSQL) when ready
  // ========================================

  /** All available decks (fetched from API) */
  decks: Deck[];

  /** Currently selected deck for detail view */
  selectedDeck: Deck | null;

  /** User's learning progress per deck (key: deckId)
   * TODO: Move to backend user_deck_progress table
   */
  deckProgress: Record<string, DeckProgress>;

  // ========================================
  // UI STATE
  // Keep on frontend after backend migration
  // ========================================

  /** Active filter settings */
  filters: DeckFilters;

  /** Loading state for async operations */
  isLoading: boolean;

  /** Error message for user display (null = no error) */
  error: string | null;

  // ========================================
  // ACTIONS
  // ========================================

  /**
   * Fetch all decks from API with current filters applied
   * Sets isLoading, populates decks array, handles errors
   */
  fetchDecks: () => Promise<void>;

  /**
   * Select a deck by ID and fetch its full details
   * Sets selectedDeck, handles errors
   * @param deckId - Unique deck identifier
   */
  selectDeck: (deckId: string) => Promise<void>;

  /**
   * Clear the currently selected deck
   */
  clearSelection: () => void;

  /**
   * Update filter settings (partial update)
   * Automatically triggers deck re-fetch
   * @param filters - Partial filter updates
   */
  setFilters: (filters: Partial<DeckFilters>) => void;

  /**
   * Reset all filters to default state
   */
  clearFilters: () => void;

  /**
   * Initialize deck for learning (create initial progress)
   * Checks premium access before allowing start
   * @param deckId - Deck to start learning
   */
  startLearning: (deckId: string) => Promise<void>;

  /**
   * Update user's progress for a deck
   * TODO: Replace with API call when backend ready
   * @param deckId - Deck being updated
   * @param progress - Partial progress updates
   */
  updateProgress: (deckId: string, progress: Partial<DeckProgress>) => void;

  /**
   * Clear current error message
   */
  clearError: () => void;
}

/**
 * Deck store hook for components
 *
 * Usage:
 * ```tsx
 * const { decks, fetchDecks, selectDeck } = useDeckStore();
 *
 * useEffect(() => {
 *   fetchDecks();
 * }, [fetchDecks]);
 * ```
 */
export const useDeckStore = create<DeckState>()(
  persist(
    (set, get) => ({
      // ========================================
      // INITIAL STATE
      // ========================================

      decks: [],
      selectedDeck: null,
      deckProgress: {}, // Will be hydrated from localStorage on init
      filters: DEFAULT_FILTERS,
      isLoading: false,
      error: null,

      // ========================================
      // ACTIONS - DECK FETCHING
      // ========================================

      /**
       * Fetch all decks with current filters
       * TODO: Replace mockDeckAPI with real API when backend ready
       */
      fetchDecks: async () => {
        const { filters } = get();

        set({ isLoading: true, error: null });

        try {
          // TODO: Replace with real API call
          // const decks = await deckAPI.getAll(filters);
          const decks = await mockDeckAPI.getAllDecks(filters);

          // Inject user's progress into decks
          // TODO: Remove when backend returns joined data
          const { deckProgress } = get();
          const decksWithProgress = decks.map(deck => ({
            ...deck,
            progress: deckProgress[deck.id] || deck.progress,
          }));

          set({
            decks: decksWithProgress,
            isLoading: false,
            error: null,
          });
        } catch (error) {
          const errorMessage = error instanceof Error
            ? error.message
            : 'Failed to load decks. Please try again.';

          set({
            isLoading: false,
            error: errorMessage,
            decks: [], // Clear decks on error
          });

          // Re-throw for component-level handling if needed
          throw error;
        }
      },

      /**
       * Select a specific deck by ID
       * TODO: Replace mockDeckAPI with real API when backend ready
       */
      selectDeck: async (deckId: string) => {
        set({ isLoading: true, error: null });

        try {
          // TODO: Replace with real API call
          // const deck = await deckAPI.getById(deckId);
          const deck = await mockDeckAPI.getDeckById(deckId);

          // Inject user's progress
          // TODO: Remove when backend returns joined data
          const { deckProgress } = get();
          const deckWithProgress = {
            ...deck,
            progress: deckProgress[deck.id] || deck.progress,
          };

          set({
            selectedDeck: deckWithProgress,
            isLoading: false,
            error: null,
          });
        } catch (error) {
          const errorMessage = error instanceof Error
            ? error.message
            : 'Failed to load deck details. Please try again.';

          set({
            isLoading: false,
            error: errorMessage,
            selectedDeck: null,
          });

          throw error;
        }
      },

      /**
       * Clear the currently selected deck
       */
      clearSelection: () => {
        set({ selectedDeck: null });
      },

      // ========================================
      // ACTIONS - FILTERING
      // ========================================

      /**
       * Update filters and automatically re-fetch decks
       */
      setFilters: (newFilters: Partial<DeckFilters>) => {
        const { filters, fetchDecks } = get();

        // Merge new filters with existing
        const updatedFilters = {
          ...filters,
          ...newFilters,
        };

        set({ filters: updatedFilters });

        // Automatically re-fetch with new filters
        // Don't await - let it run in background
        fetchDecks().catch((error) => {
          console.error('Error fetching decks after filter change:', error);
        });
      },

      /**
       * Reset all filters to defaults
       */
      clearFilters: () => {
        const { fetchDecks } = get();

        set({ filters: DEFAULT_FILTERS });

        // Re-fetch with default filters
        fetchDecks().catch((error) => {
          console.error('Error fetching decks after clearing filters:', error);
        });
      },

      // ========================================
      // ACTIONS - LEARNING FLOW
      // ========================================

      /**
       * Start learning a deck
       * Checks premium access and initializes progress
       * TODO: Replace with backend API call when ready
       */
      startLearning: async (deckId: string) => {
        set({ isLoading: true, error: null });

        try {
          // Get deck to check premium status
          // TODO: Replace with real API call
          const deck = await mockDeckAPI.getDeckById(deckId);

          // Check premium access
          const { user } = useAuthStore.getState();
          const isPremiumLocked = deck.isPremium && user?.role === 'free';

          if (isPremiumLocked) {
            throw new Error(
              'This is a premium deck. Please upgrade your account to access premium content.'
            );
          }

          // Initialize progress
          // TODO: Replace with backend API call
          // const progress = await deckAPI.startLearning(deckId);
          const progress = await mockDeckAPI.startDeck(deckId);

          // Update local progress state
          // TODO: Remove when backend handles this
          set((state) => ({
            deckProgress: {
              ...state.deckProgress,
              [deckId]: progress,
            },
            isLoading: false,
            error: null,
          }));

          // Update selected deck if it's the current one
          const { selectedDeck } = get();
          if (selectedDeck?.id === deckId) {
            set({
              selectedDeck: {
                ...selectedDeck,
                progress,
              },
            });
          }

          // Re-fetch decks to update list with new progress
          await get().fetchDecks();

        } catch (error) {
          const errorMessage = error instanceof Error
            ? error.message
            : 'Failed to start learning. Please try again.';

          set({
            isLoading: false,
            error: errorMessage,
          });

          throw error;
        }
      },

      /**
       * Update user's progress for a deck
       * TODO: Replace with backend API call when ready
       */
      updateProgress: (deckId: string, progressUpdates: Partial<DeckProgress>) => {
        set((state) => {
          const currentProgress = state.deckProgress[deckId];

          if (!currentProgress) {
            console.warn(`No progress found for deck ${deckId}. Cannot update.`);
            return state;
          }

          // Merge updates
          const updatedProgress = {
            ...currentProgress,
            ...progressUpdates,
          };

          // Update deck progress map
          const newDeckProgress = {
            ...state.deckProgress,
            [deckId]: updatedProgress,
          };

          // Update selected deck if it matches
          let newSelectedDeck = state.selectedDeck;
          if (state.selectedDeck?.id === deckId) {
            newSelectedDeck = {
              ...state.selectedDeck,
              progress: updatedProgress,
            };
          }

          // Update decks array
          const newDecks = state.decks.map(deck =>
            deck.id === deckId
              ? { ...deck, progress: updatedProgress }
              : deck
          );

          return {
            deckProgress: newDeckProgress,
            selectedDeck: newSelectedDeck,
            decks: newDecks,
          };
        });

        // TODO: When backend ready, add API call:
        // await deckAPI.updateProgress(deckId, progressUpdates);
      },

      // ========================================
      // ACTIONS - ERROR HANDLING
      // ========================================

      /**
       * Clear current error message
       */
      clearError: () => {
        set({ error: null });
      },
    }),
    {
      name: 'deck-progress-storage', // localStorage key
      storage: createJSONStorage(() => localStorage),

      // Only persist user progress (temporary until backend)
      partialize: (state) => ({
        deckProgress: state.deckProgress,
      }),

      // TODO: Remove this persist configuration when migrating to backend
      // Progress will be stored in PostgreSQL user_deck_progress table
    }
  )
);
```

---

## Testing Strategy

### Unit Testing Checklist

**State Initialization**:
- [ ] Store initializes with empty decks array
- [ ] Store initializes with null selectedDeck
- [ ] Store initializes with empty deckProgress
- [ ] Store initializes with DEFAULT_FILTERS
- [ ] Store initializes with isLoading: false
- [ ] Store initializes with error: null

**fetchDecks Action**:
- [ ] Sets isLoading to true before fetch
- [ ] Sets isLoading to false after fetch
- [ ] Populates decks array on success
- [ ] Sets error on failure
- [ ] Clears decks on error
- [ ] Injects user progress into fetched decks
- [ ] Applies current filters correctly

**selectDeck Action**:
- [ ] Sets isLoading to true before fetch
- [ ] Sets isLoading to false after fetch
- [ ] Sets selectedDeck on success
- [ ] Sets error on failure for invalid ID
- [ ] Injects user progress into selected deck
- [ ] Clears selectedDeck on error

**Filter Actions**:
- [ ] setFilters merges with existing filters
- [ ] setFilters triggers automatic fetchDecks
- [ ] clearFilters resets to DEFAULT_FILTERS
- [ ] clearFilters triggers automatic fetchDecks
- [ ] Filter changes visible in decks array

**startLearning Action**:
- [ ] Checks premium access before proceeding
- [ ] Blocks free users from premium decks
- [ ] Allows premium users to start premium decks
- [ ] Initializes progress for new deck
- [ ] Updates deckProgress state
- [ ] Updates selectedDeck if current
- [ ] Re-fetches decks to update list
- [ ] Sets error on premium access denial

**updateProgress Action**:
- [ ] Updates progress in deckProgress map
- [ ] Updates selectedDeck if matches deckId
- [ ] Updates deck in decks array
- [ ] Warns if no existing progress found
- [ ] Merges partial updates correctly

**Persistence**:
- [ ] deckProgress persists to localStorage
- [ ] deckProgress restored on page reload
- [ ] decks NOT persisted (always empty on init)
- [ ] filters NOT persisted (always DEFAULT on init)
- [ ] selectedDeck NOT persisted (always null on init)

### Integration Testing

**With Auth Store**:
- [ ] Premium check reads from useAuthStore correctly
- [ ] Free user blocked from premium decks
- [ ] Premium user allowed to start premium decks
- [ ] Admin user allowed to start all decks

**With Mock API**:
- [ ] All API methods called with correct parameters
- [ ] API delays visible in isLoading state
- [ ] API errors caught and set to error state
- [ ] Filtered requests send correct filters to API

### Browser Testing

**Chrome DevTools Tests**:
1. Open Application tab → Local Storage
2. Verify `deck-progress-storage` key appears
3. Start a deck, verify progress saved
4. Refresh page, verify progress restored
5. Update progress, verify localStorage updates immediately

**Network Tab Tests**:
1. Open Network tab
2. Call fetchDecks, verify delay (300ms)
3. Call selectDeck, verify delay (200ms)
4. Call startLearning, verify delay (200ms)

**Console Tests**:
- [ ] No TypeScript errors
- [ ] No runtime errors during normal use
- [ ] Premium block error shows helpful message
- [ ] Invalid deck ID error shows helpful message

---

## Success Criteria

### Code Quality
- [ ] TypeScript compiles with 0 errors
- [ ] All actions properly typed
- [ ] No `any` types used
- [ ] JSDoc comments on all complex functions
- [ ] Consistent error handling pattern used

### Functionality
- [ ] fetchDecks loads all decks from API
- [ ] selectDeck sets selectedDeck correctly
- [ ] Filters apply and trigger re-fetch
- [ ] Premium access blocking works
- [ ] startLearning initializes progress
- [ ] updateProgress merges updates correctly
- [ ] Error handling works for all edge cases

### Integration
- [ ] Auth store integration works (premium checks)
- [ ] Mock API integration works (all methods)
- [ ] Progress injects into decks correctly
- [ ] localStorage persistence works
- [ ] Progress survives page refresh

### User Experience
- [ ] Loading states clear (isLoading)
- [ ] Error messages helpful and user-friendly
- [ ] No flash of stale data on load
- [ ] Filters feel responsive (auto-refetch)

---

## Common Pitfalls

### 1. Forgetting to Set isLoading

**Problem**: Async operations don't show loading state.

**Solution**: Always set `isLoading: true` at start, `isLoading: false` at end.

```typescript
// ✗ BAD
fetchDecks: async () => {
  const decks = await mockDeckAPI.getAllDecks();
  set({ decks });
}

// ✓ GOOD
fetchDecks: async () => {
  set({ isLoading: true, error: null });
  try {
    const decks = await mockDeckAPI.getAllDecks();
    set({ decks, isLoading: false });
  } catch (error) {
    set({ isLoading: false, error: error.message });
  }
}
```

### 2. Not Clearing Error State

**Problem**: Old errors persist even after successful operations.

**Solution**: Clear error at start of every async operation.

```typescript
set({ isLoading: true, error: null }); // Always clear error
```

### 3. Forgetting to Re-throw Errors

**Problem**: Component-level error handling doesn't work.

**Solution**: Re-throw errors after setting state.

```typescript
catch (error) {
  set({ error: error.message });
  throw error; // Re-throw for components
}
```

### 4. Premium Check Before Deck Fetch

**Problem**: Checking premium before fetching deck details.

**Solution**: Fetch deck first, then check premium status.

```typescript
// ✗ BAD - deck details not available yet
const { user } = useAuthStore.getState();
if (deck.isPremium && user?.role === 'free') { ... }

// ✓ GOOD - fetch deck first
const deck = await mockDeckAPI.getDeckById(deckId);
const { user } = useAuthStore.getState();
if (deck.isPremium && user?.role === 'free') { ... }
```

### 5. Not Injecting Progress into Decks

**Problem**: Progress stored separately doesn't show in deck cards.

**Solution**: Always inject progress when returning decks.

```typescript
const decksWithProgress = decks.map(deck => ({
  ...deck,
  progress: deckProgress[deck.id] || deck.progress,
}));
```

### 6. Persisting Everything to localStorage

**Problem**: Stale data issues and unnecessary persistence.

**Solution**: Only persist `deckProgress`, nothing else.

```typescript
partialize: (state) => ({
  deckProgress: state.deckProgress, // Only this!
})
```

### 7. Not Updating Multiple State Locations

**Problem**: Progress updates in `deckProgress` but not in `selectedDeck` or `decks` array.

**Solution**: Update all three locations simultaneously.

```typescript
updateProgress: (deckId, updates) => {
  set((state) => ({
    // 1. Update progress map
    deckProgress: { ...state.deckProgress, [deckId]: updated },

    // 2. Update selected deck if matches
    selectedDeck: state.selectedDeck?.id === deckId
      ? { ...state.selectedDeck, progress: updated }
      : state.selectedDeck,

    // 3. Update decks array
    decks: state.decks.map(d =>
      d.id === deckId ? { ...d, progress: updated } : d
    ),
  }));
}
```

### 8. Awaiting Auto-Refetch in setFilters

**Problem**: setFilters returns a Promise, making UI code awkward.

**Solution**: Fire-and-forget the refetch, catch errors internally.

```typescript
setFilters: (newFilters) => {
  set({ filters: { ...filters, ...newFilters } });

  // Don't await - let it run in background
  fetchDecks().catch(error => {
    console.error('Filter refetch error:', error);
  });
}
```

---

## Backend Migration Notes

### What Changes When Backend is Ready

**Step 1: Install TanStack Query**
```bash
npm install @tanstack/react-query
```

**Step 2: Create Real API Client**
```typescript
// src/services/deckAPI.ts
export const deckAPI = {
  getAll: (filters) => fetch('/api/decks', { params: filters }),
  getById: (id) => fetch(`/api/decks/${id}`),
  startLearning: (id) => fetch(`/api/decks/${id}/start`, { method: 'POST' }),
  updateProgress: (id, progress) => fetch(`/api/decks/${id}/progress`, {
    method: 'PATCH',
    body: JSON.stringify(progress),
  }),
};
```

**Step 3: Refactor Zustand Store**
```typescript
// Only keep UI state
interface DeckState {
  // Keep these
  filters: DeckFilters;
  selectedDeckId: string | null;

  // Remove these (move to TanStack Query)
  // decks: Deck[] ← Query: useQuery(['decks', filters])
  // selectedDeck: Deck | null ← Query: useQuery(['deck', id])
  // deckProgress: Record<...> ← Query: useQuery(['progress', deckId])
}
```

**Step 4: Use TanStack Query in Components**
```typescript
// Before (Zustand)
const { decks, fetchDecks } = useDeckStore();
useEffect(() => { fetchDecks() }, []);

// After (TanStack Query)
const { data: decks } = useQuery({
  queryKey: ['decks', filters],
  queryFn: () => deckAPI.getAll(filters),
});
```

### Migration Checklist

- [ ] Backend API endpoints deployed
- [ ] TanStack Query installed and configured
- [ ] Real API client created (`deckAPI.ts`)
- [ ] Zustand store reduced to UI state only
- [ ] Components refactored to use `useQuery`
- [ ] Progress mutations use `useMutation`
- [ ] localStorage persistence removed
- [ ] Cross-device sync tested
- [ ] Error handling updated for network failures
- [ ] Loading states work with Query
- [ ] Remove all TODO comments

**Estimated Time**: 4-6 hours

---

## Time Breakdown

| Step | Task | Estimated Time | Cumulative |
|------|------|----------------|------------|
| 1 | File setup and imports | 3 min | 3 min |
| 2 | Define defaults and constants | 3 min | 6 min |
| 3 | Define state interface | 5 min | 11 min |
| 4 | Implement core store logic | 20 min | 31 min |
| 5 | Configure persistence middleware | 5 min | 36 min |
| 6 | Add export and type safety | 2 min | 38 min |
| 7 | Manual testing and validation | 7 min | 45 min |
| **Total** | | **45 minutes** | |

**No buffer included** - timing assumes focused, uninterrupted implementation.

**Actual implementation may vary** based on:
- Debugging TypeScript errors (+5-10 min)
- Testing edge cases (+5 min)
- Code review and refinement (+5 min)

**Total with buffer**: 50-60 minutes

---

## Final Notes

### Critical Success Factors

1. **Type Safety First**: Ensure all TypeScript types are correct before testing
2. **Error Handling Consistency**: Use same pattern in all async actions
3. **Premium Access Check**: Always check before `startLearning`
4. **Progress Injection**: Always inject progress into decks before returning
5. **Persistence Scope**: Only persist `deckProgress`, nothing else

### Ready for Execution

This plan is ready for handoff to an executor or developer. Each step has:
- Clear objective
- Detailed actions
- Code templates
- Validation criteria
- Testing instructions

### Questions for Clarification

If any part of this plan is unclear, ask before starting implementation:
1. Should premium users have access to all premium decks, or tier-based?
2. Should errors auto-clear after X seconds, or require manual clearError()?
3. Should filters persist across sessions (currently they don't)?
4. Should we add analytics tracking for deck starts?

---

**Created**: 2025-11-01
**Ready for**: Task 04.02 Execution
**Next Task**: 04.03 - Create Deck Card Component
**Estimated Duration**: 45 minutes (focused implementation)
