# Task 05.05: Request Validation Enhancement - Technical Design Document

**Status**: ✅ COMPLETED (2025-12-07)
**PR**: [#14](https://github.com/SimonOsipov/learn-greek-easy/pull/14)
**Parent Task**: Task 05 - API Foundation & Middleware
**Dependencies**: None (standalone utility module)
**Estimated Duration**: 30-45 minutes

## Overview

**Feature**: Request Validation Utilities
**Architecture Pattern**: Standalone utility module with pure functions
**File**: `src/utils/validation.py`

### Objectives

1. Create reusable regex patterns for common validations (EMAIL, UUID)
2. Implement `validate_pagination()` function for standardized pagination parameter handling
3. Implement `sanitize_search_query()` function for safe user search input
4. Provide utilities that complement Pydantic's automatic validation for complex scenarios

---

## Current State Analysis

### Existing Validation in Codebase

The codebase already uses Pydantic for request validation:

```python
# src/schemas/user.py - EmailStr handles email validation
class UserBase(BaseModel):
    email: EmailStr  # Pydantic's built-in email validation

# src/schemas/deck.py - Pagination response exists but no parameter validation
class DeckListResponse(BaseModel):
    total: int
    page: int
    page_size: int
    decks: list[DeckResponse]
```

### Gap Analysis

| Scenario | Current State | Gap |
|----------|---------------|-----|
| Email validation in schemas | Pydantic EmailStr | None (but regex useful for other contexts) |
| UUID validation | Implicit via UUID type | Regex needed for string validation |
| Pagination parameters | No standardized handling | Need offset/limit calculation |
| Search query sanitization | No sanitization | Need to prevent SQL LIKE injection |

### Use Cases for New Utilities

1. **validate_pagination()**: Convert user-friendly page/page_size to database offset/limit
2. **sanitize_search_query()**: Clean user input before using in LIKE queries
3. **Regex patterns**: Validate strings before conversion, logging, or external API calls

---

## Technical Design

### File Structure

```
src/utils/
├── __init__.py          # Export validation utilities
└── validation.py        # NEW: Validation utilities

tests/unit/utils/
├── __init__.py          # NEW: Utils test package
└── test_validation.py   # NEW: Validation tests
```

### Implementation

#### File: `src/utils/validation.py`

```python
"""Request validation utilities for complex scenarios beyond Pydantic.

This module provides:
- Regex patterns for common validations (email, UUID)
- Pagination parameter validation with offset/limit calculation
- Search query sanitization for safe database queries

These utilities complement Pydantic's automatic validation for scenarios
where manual validation or transformation is needed.

Usage:
    from src.utils.validation import (
        EMAIL_REGEX,
        UUID_REGEX,
        validate_pagination,
        sanitize_search_query,
    )

    # Validate email format outside of Pydantic
    if EMAIL_REGEX.match(user_input):
        process_email(user_input)

    # Convert pagination params to offset/limit
    offset, limit = validate_pagination(page=2, page_size=20)
    # Result: offset=20, limit=20

    # Sanitize search input
    clean_query = sanitize_search_query("  user%input_  ")
    # Result: "userinput"
"""

import re
from typing import Tuple

# ============================================================================
# Regex Patterns
# ============================================================================

# Email regex pattern - RFC 5322 simplified
# Matches: user@domain.com, user.name+tag@sub.domain.co.uk
# Does not match: invalid emails, missing TLD, special chars in wrong places
EMAIL_REGEX = re.compile(
    r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
)

# UUID v4 regex pattern (case-insensitive)
# Matches: 550e8400-e29b-41d4-a716-446655440000
# Also matches uppercase: 550E8400-E29B-41D4-A716-446655440000
UUID_REGEX = re.compile(
    r"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
    re.IGNORECASE,
)


# ============================================================================
# Pagination Validation
# ============================================================================

def validate_pagination(
    page: int,
    page_size: int,
    max_page_size: int = 100,
) -> Tuple[int, int]:
    """Validate and normalize pagination parameters.

    Converts user-friendly page/page_size parameters to database-friendly
    offset/limit values. Enforces minimum and maximum constraints.

    Args:
        page: Page number (1-indexed). Must be >= 1.
        page_size: Number of items per page. Must be >= 1.
        max_page_size: Maximum allowed page size. Defaults to 100.
            If page_size exceeds this, it will be capped (not raise error).

    Returns:
        Tuple of (offset, limit) for database queries:
        - offset: Number of items to skip (0-indexed)
        - limit: Maximum items to return (capped at max_page_size)

    Raises:
        ValueError: If page < 1 or page_size < 1.

    Examples:
        >>> validate_pagination(page=1, page_size=20)
        (0, 20)

        >>> validate_pagination(page=2, page_size=20)
        (20, 20)

        >>> validate_pagination(page=3, page_size=50)
        (100, 50)

        >>> validate_pagination(page=1, page_size=500, max_page_size=100)
        (0, 100)  # Capped at max_page_size

        >>> validate_pagination(page=0, page_size=20)
        ValueError: Page must be >= 1
    """
    if page < 1:
        raise ValueError("Page must be >= 1")
    if page_size < 1:
        raise ValueError("Page size must be >= 1")

    # Cap page_size at maximum (don't raise, just cap)
    if page_size > max_page_size:
        page_size = max_page_size

    # Calculate offset (0-indexed)
    offset = (page - 1) * page_size

    return offset, page_size


# ============================================================================
# Search Query Sanitization
# ============================================================================

def sanitize_search_query(
    query: str,
    max_length: int = 100,
) -> str:
    """Sanitize user search query for safe database operations.

    Cleans user input by:
    1. Stripping leading/trailing whitespace
    2. Truncating to max_length
    3. Removing SQL LIKE wildcard characters (%, _, \\)

    Note: SQLAlchemy's parameterized queries already prevent SQL injection.
    This function specifically handles LIKE pattern injection where
    % and _ have special meaning.

    Args:
        query: Raw user search query.
        max_length: Maximum allowed length. Defaults to 100.
            Query is truncated AFTER stripping whitespace.

    Returns:
        Sanitized query string safe for LIKE operations.
        Returns empty string if input is empty after sanitization.

    Examples:
        >>> sanitize_search_query("  hello world  ")
        'hello world'

        >>> sanitize_search_query("search%term")
        'searchterm'

        >>> sanitize_search_query("user_input")
        'userinput'

        >>> sanitize_search_query("test\\query")
        'testquery'

        >>> sanitize_search_query("a" * 200, max_length=100)
        'a' * 100  # Truncated

        >>> sanitize_search_query("   ")
        ''  # Empty after strip
    """
    # Strip whitespace first
    query = query.strip()

    # Truncate to max length
    query = query[:max_length]

    # Remove SQL LIKE special characters
    # % - matches any sequence of characters
    # _ - matches any single character
    # \ - escape character
    query = re.sub(r"[%_\\]", "", query)

    return query
```

#### File: `src/utils/__init__.py`

Update to export validation utilities:

```python
"""Utility modules for Learn Greek Easy backend.

This package contains utility functions and helpers for:
- Request validation (validation.py)
- Future: Response formatting, date utilities, etc.
"""

from src.utils.validation import (
    EMAIL_REGEX,
    UUID_REGEX,
    sanitize_search_query,
    validate_pagination,
)

__all__ = [
    "EMAIL_REGEX",
    "UUID_REGEX",
    "sanitize_search_query",
    "validate_pagination",
]
```

---

## Testing Strategy

### Test File: `tests/unit/utils/test_validation.py`

```python
"""Unit tests for validation utilities.

Tests cover:
- EMAIL_REGEX pattern matching
- UUID_REGEX pattern matching
- validate_pagination() function with valid and invalid inputs
- sanitize_search_query() function with various edge cases

Target coverage: 95%+
"""

import pytest

from src.utils.validation import (
    EMAIL_REGEX,
    UUID_REGEX,
    sanitize_search_query,
    validate_pagination,
)


class TestEmailRegex:
    """Tests for EMAIL_REGEX pattern."""

    @pytest.mark.parametrize(
        "email",
        [
            "user@example.com",
            "user.name@example.com",
            "user+tag@example.com",
            "user@sub.domain.com",
            "user@example.co.uk",
            "user123@example.com",
            "user.name+tag@sub.domain.co.uk",
        ],
    )
    def test_valid_emails_match(self, email: str):
        """Test that valid emails match the pattern."""
        assert EMAIL_REGEX.match(email) is not None

    @pytest.mark.parametrize(
        "email",
        [
            "",
            "not-an-email",
            "@example.com",
            "user@",
            "user@.com",
            "user@example",
            "user @example.com",
            "user@ example.com",
            "user@example .com",
        ],
    )
    def test_invalid_emails_do_not_match(self, email: str):
        """Test that invalid emails do not match the pattern."""
        assert EMAIL_REGEX.match(email) is None


class TestUuidRegex:
    """Tests for UUID_REGEX pattern."""

    @pytest.mark.parametrize(
        "uuid_str",
        [
            "550e8400-e29b-41d4-a716-446655440000",
            "550E8400-E29B-41D4-A716-446655440000",
            "00000000-0000-0000-0000-000000000000",
            "ffffffff-ffff-ffff-ffff-ffffffffffff",
            "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF",
            "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        ],
    )
    def test_valid_uuids_match(self, uuid_str: str):
        """Test that valid UUIDs match the pattern."""
        assert UUID_REGEX.match(uuid_str) is not None

    @pytest.mark.parametrize(
        "uuid_str",
        [
            "",
            "not-a-uuid",
            "550e8400e29b41d4a716446655440000",  # Missing dashes
            "550e8400-e29b-41d4-a716-44665544000",  # Too short
            "550e8400-e29b-41d4-a716-4466554400000",  # Too long
            "550e8400-e29b-41d4-a716",  # Incomplete
            "g50e8400-e29b-41d4-a716-446655440000",  # Invalid char
            "550e8400-e29b-41d4-a716-446655440000-extra",  # Extra segment
        ],
    )
    def test_invalid_uuids_do_not_match(self, uuid_str: str):
        """Test that invalid UUIDs do not match the pattern."""
        assert UUID_REGEX.match(uuid_str) is None


class TestValidatePagination:
    """Tests for validate_pagination function."""

    def test_first_page(self):
        """Test pagination for first page."""
        offset, limit = validate_pagination(page=1, page_size=20)
        assert offset == 0
        assert limit == 20

    def test_second_page(self):
        """Test pagination for second page."""
        offset, limit = validate_pagination(page=2, page_size=20)
        assert offset == 20
        assert limit == 20

    def test_third_page(self):
        """Test pagination for third page."""
        offset, limit = validate_pagination(page=3, page_size=50)
        assert offset == 100
        assert limit == 50

    def test_large_page_number(self):
        """Test pagination with large page number."""
        offset, limit = validate_pagination(page=100, page_size=10)
        assert offset == 990
        assert limit == 10

    def test_page_size_capped_at_max(self):
        """Test that page_size is capped at max_page_size."""
        offset, limit = validate_pagination(
            page=1, page_size=500, max_page_size=100
        )
        assert offset == 0
        assert limit == 100

    def test_custom_max_page_size(self):
        """Test custom max_page_size."""
        offset, limit = validate_pagination(
            page=1, page_size=50, max_page_size=25
        )
        assert offset == 0
        assert limit == 25

    def test_page_size_at_max(self):
        """Test page_size exactly at max is not capped."""
        offset, limit = validate_pagination(
            page=1, page_size=100, max_page_size=100
        )
        assert offset == 0
        assert limit == 100

    def test_page_less_than_one_raises_error(self):
        """Test that page < 1 raises ValueError."""
        with pytest.raises(ValueError, match="Page must be >= 1"):
            validate_pagination(page=0, page_size=20)

    def test_page_negative_raises_error(self):
        """Test that negative page raises ValueError."""
        with pytest.raises(ValueError, match="Page must be >= 1"):
            validate_pagination(page=-1, page_size=20)

    def test_page_size_less_than_one_raises_error(self):
        """Test that page_size < 1 raises ValueError."""
        with pytest.raises(ValueError, match="Page size must be >= 1"):
            validate_pagination(page=1, page_size=0)

    def test_page_size_negative_raises_error(self):
        """Test that negative page_size raises ValueError."""
        with pytest.raises(ValueError, match="Page size must be >= 1"):
            validate_pagination(page=1, page_size=-5)

    def test_default_max_page_size_is_100(self):
        """Test that default max_page_size is 100."""
        offset, limit = validate_pagination(page=1, page_size=150)
        assert limit == 100

    def test_returns_tuple(self):
        """Test that function returns a tuple."""
        result = validate_pagination(page=1, page_size=20)
        assert isinstance(result, tuple)
        assert len(result) == 2


class TestSanitizeSearchQuery:
    """Tests for sanitize_search_query function."""

    def test_strips_whitespace(self):
        """Test that leading/trailing whitespace is stripped."""
        assert sanitize_search_query("  hello  ") == "hello"

    def test_preserves_internal_whitespace(self):
        """Test that internal whitespace is preserved."""
        assert sanitize_search_query("hello world") == "hello world"

    def test_removes_percent_sign(self):
        """Test that % is removed."""
        assert sanitize_search_query("search%term") == "searchterm"

    def test_removes_underscore(self):
        """Test that _ is removed."""
        assert sanitize_search_query("user_name") == "username"

    def test_removes_backslash(self):
        """Test that \\ is removed."""
        assert sanitize_search_query("test\\query") == "testquery"

    def test_removes_multiple_special_chars(self):
        """Test removal of multiple special characters."""
        assert sanitize_search_query("%user_name\\%") == "username"

    def test_truncates_to_max_length(self):
        """Test that query is truncated to max_length."""
        long_query = "a" * 200
        result = sanitize_search_query(long_query, max_length=100)
        assert len(result) == 100
        assert result == "a" * 100

    def test_custom_max_length(self):
        """Test custom max_length."""
        result = sanitize_search_query("hello world", max_length=5)
        assert result == "hello"

    def test_empty_string(self):
        """Test empty string input."""
        assert sanitize_search_query("") == ""

    def test_whitespace_only_returns_empty(self):
        """Test that whitespace-only input returns empty string."""
        assert sanitize_search_query("   ") == ""

    def test_special_chars_only_returns_empty(self):
        """Test that special-chars-only input returns empty string."""
        assert sanitize_search_query("%_\\") == ""

    def test_unicode_characters_preserved(self):
        """Test that unicode characters are preserved."""
        assert sanitize_search_query("hello") == "hello"

    def test_numbers_preserved(self):
        """Test that numbers are preserved."""
        assert sanitize_search_query("test123") == "test123"

    def test_default_max_length_is_100(self):
        """Test that default max_length is 100."""
        long_query = "a" * 150
        result = sanitize_search_query(long_query)
        assert len(result) == 100

    def test_strips_then_truncates(self):
        """Test that whitespace is stripped before truncation."""
        # 5 spaces + 100 a's = 105 chars
        # After strip: 100 a's
        # No truncation needed
        query = "     " + "a" * 100
        result = sanitize_search_query(query, max_length=100)
        assert result == "a" * 100

    def test_returns_string(self):
        """Test that function returns a string."""
        result = sanitize_search_query("test")
        assert isinstance(result, str)
```

### Test File: `tests/unit/utils/__init__.py`

```python
"""Unit tests for utility modules."""
```

---

## Implementation Checklist

### Phase 1: Create Validation Module

- [ ] Create `src/utils/validation.py` with:
  - [ ] `EMAIL_REGEX` pattern
  - [ ] `UUID_REGEX` pattern
  - [ ] `validate_pagination()` function
  - [ ] `sanitize_search_query()` function
  - [ ] Comprehensive docstrings

### Phase 2: Update Package Exports

- [ ] Update `src/utils/__init__.py` to export all utilities
- [ ] Add module docstring

### Phase 3: Create Tests

- [ ] Create `tests/unit/utils/__init__.py`
- [ ] Create `tests/unit/utils/test_validation.py` with all test classes
- [ ] Run tests and verify passing
- [ ] Check test coverage meets 95% target

### Phase 4: Verification

- [ ] Run linting: `poetry run ruff check src/utils/validation.py`
- [ ] Run type checking: `poetry run mypy src/utils/validation.py`
- [ ] Run all tests: `poetry run pytest tests/unit/utils/ -v`
- [ ] Check coverage: `poetry run pytest tests/unit/utils/ --cov=src/utils --cov-report=term-missing`

---

## Success Criteria

### Functional Requirements

| Requirement | Verification Method |
|-------------|---------------------|
| EMAIL_REGEX matches valid emails | Parametrized tests with valid emails |
| EMAIL_REGEX rejects invalid emails | Parametrized tests with invalid emails |
| UUID_REGEX matches valid UUIDs (case-insensitive) | Parametrized tests |
| UUID_REGEX rejects invalid UUIDs | Parametrized tests |
| validate_pagination() returns correct offset/limit | Unit tests |
| validate_pagination() raises ValueError for invalid input | Exception tests |
| validate_pagination() caps page_size at max | Unit tests |
| sanitize_search_query() strips whitespace | Unit tests |
| sanitize_search_query() removes %, _, \\ | Unit tests |
| sanitize_search_query() truncates to max_length | Unit tests |

### Non-Functional Requirements

| Requirement | Target | Verification |
|-------------|--------|--------------|
| Test coverage | 95%+ | Coverage report |
| No external dependencies | Confirmed | Only uses `re` stdlib |
| Pure functions | Confirmed | No side effects |
| Type hints | All functions | mypy check |

---

## Usage Examples

### Using validate_pagination in API Endpoints

```python
# Future API endpoint example
from fastapi import Query
from src.utils.validation import validate_pagination

@router.get("/decks")
async def list_decks(
    page: int = Query(default=1, ge=1),
    page_size: int = Query(default=20, ge=1, le=100),
    db: AsyncSession = Depends(get_db),
):
    offset, limit = validate_pagination(page, page_size)

    # Use offset and limit in database query
    query = select(Deck).offset(offset).limit(limit)
    result = await db.execute(query)
    decks = result.scalars().all()

    return {"decks": decks, "page": page, "page_size": limit}
```

### Using sanitize_search_query for Search

```python
# Future search endpoint example
from src.utils.validation import sanitize_search_query

@router.get("/decks/search")
async def search_decks(
    q: str = Query(..., min_length=1),
    db: AsyncSession = Depends(get_db),
):
    clean_query = sanitize_search_query(q)

    if not clean_query:
        return {"decks": []}

    # Safe to use in LIKE query
    query = select(Deck).where(Deck.name.ilike(f"%{clean_query}%"))
    result = await db.execute(query)
    return {"decks": result.scalars().all()}
```

### Using Regex Patterns for Validation

```python
# Example: Validate ID format before database lookup
from src.utils.validation import UUID_REGEX

def validate_resource_id(resource_id: str) -> bool:
    """Check if resource_id is a valid UUID format."""
    return UUID_REGEX.match(resource_id) is not None
```

---

## Security Considerations

### SQL LIKE Pattern Injection

The `sanitize_search_query()` function prevents SQL LIKE pattern injection:

- `%` matches any sequence (e.g., `%admin%` would match unintended records)
- `_` matches any single character (e.g., `_dmin` could match "admin")
- `\` is the escape character in some databases

Note: SQLAlchemy parameterization already prevents SQL injection. This function specifically handles LIKE wildcard abuse.

### Input Length Limits

Both functions enforce length limits:
- `validate_pagination()`: Caps page_size at configurable maximum
- `sanitize_search_query()`: Truncates query to configurable maximum

---

## Open Questions

### Resolved

1. **Should validate_pagination raise or cap page_size?**
   - **Answer**: Cap at max_page_size (more user-friendly)

2. **Should sanitize_search_query handle Unicode?**
   - **Answer**: Yes, preserve all non-special Unicode characters

3. **What default max_page_size?**
   - **Answer**: 100 (standard pagination limit)

### Assumptions

1. Pagination uses 1-indexed pages (standard for APIs)
2. LIKE queries use `%` prefix and suffix for partial matching
3. Backslash is treated as special character (PostgreSQL behavior)

---

## References

- **Parent Task**: `/Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/backend/05/05-api-foundation-middleware-plan.md`
- **Existing Schemas**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/schemas/deck.py`
- **Test Patterns**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/unit/middleware/`

---

**Document Version**: 1.0
**Created**: 2025-12-07
**Author**: Architect Agent
**Status**: Ready for Implementation
