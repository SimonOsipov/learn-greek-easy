# Task 05.03: Error Handling Middleware - Technical Architecture Document

**Status**: ✅ COMPLETED (2025-12-06)
**PR**: [#12](https://github.com/SimonOsipov/learn-greek-easy/pull/12)

## Overview

**Feature**: Centralized Error Handling Middleware
**Architecture Pattern**: Middleware-based exception catching with consistent JSON error formatting
**File Created**: `src/middleware/error_handler.py`
**Dependencies**: Task 05.02 (Request Logging Middleware) - COMPLETED
**Priority**: High

### Objectives

1. Catch unhandled exceptions from other middleware layers before FastAPI exception handlers
2. Log errors with full traceback and request context (including request ID from logging middleware)
3. Return consistent JSON error response format matching existing exception handlers
4. Include debug information (type, message, traceback) only when `settings.debug` is True
5. Add `X-Request-ID` header to error responses for correlation

---

## Current State Analysis

### Existing Exception Handlers in `src/main.py`

The application already has a comprehensive exception handling system with four exception handlers:

```python
# 1. BaseAPIException handler (lines 110-137)
@app.exception_handler(BaseAPIException)
async def base_api_exception_handler(request: Request, exc: BaseAPIException) -> JSONResponse:
    """Handle custom API exceptions."""
    # Returns: {"success": False, "error": {"code": ..., "message": ..., "extra": ...}}

# 2. RequestValidationError handler (lines 162-187)
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """Handle Pydantic validation errors."""
    # Returns: {"success": False, "error": {"code": "VALIDATION_ERROR", "message": ..., "details": ...}}

# 3. StarletteHTTPException handler (lines 190-214)
@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException) -> JSONResponse:
    """Handle HTTP exceptions."""
    # Returns: {"success": False, "error": {"code": "HTTP_<status>", "message": ...}}

# 4. Generic Exception handler (lines 217-240)
@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Handle unhandled exceptions."""
    # Returns: {"success": False, "error": {"code": "INTERNAL_SERVER_ERROR", "message": ...}}
```

### Gap Analysis

The existing exception handlers cover errors within the request/response lifecycle but have limitations:

| Scenario | Current Coverage | Gap |
|----------|------------------|-----|
| Exceptions in endpoint handlers | Covered by exception handlers | None |
| Exceptions in dependencies | Covered by exception handlers | None |
| Exceptions in middleware | **NOT COVERED** - propagates as 500 | **Critical Gap** |
| Request ID in error responses | **NOT INCLUDED** | Missing correlation |
| Debug information in dev | **NOT INCLUDED** | Limited debugging |

### Why Middleware-Based Error Handling?

```
Request Flow:

Client Request
     │
     ▼
┌─────────────────────┐
│ CORSMiddleware      │
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ RequestLogging      │  ← Generates request_id
│ Middleware          │
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ ErrorHandling       │  ← NEW: Catches middleware
│ Middleware          │    exceptions
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ AuthLogging         │  ← If this throws,
│ Middleware          │    ErrorHandling catches it
└─────────────────────┘
     │
     ▼
┌─────────────────────┐
│ FastAPI Router      │
│ + Exception         │  ← Normal exception
│   Handlers          │    handlers work here
└─────────────────────┘
```

The ErrorHandlingMiddleware acts as a safety net for exceptions in middleware layers that occur **before** reaching FastAPI's exception handlers.

---

## Technical Design

### Component Structure

```
src/middleware/
├── __init__.py          # Export ErrorHandlingMiddleware
├── auth.py              # Existing: AuthLoggingMiddleware
├── logging.py           # Existing: RequestLoggingMiddleware
└── error_handler.py     # NEW: ErrorHandlingMiddleware
```

### ErrorHandlingMiddleware Implementation

```python
"""Centralized error handling middleware.

This middleware provides a safety net for catching and formatting
unhandled exceptions that occur in other middleware layers.

While FastAPI exception handlers catch most errors that occur within
the router/endpoint lifecycle, exceptions in middleware are not caught
by those handlers. This middleware ensures:

1. All exceptions produce consistent JSON error responses
2. Errors are logged with full context including request ID
3. Debug information is included only in development mode
4. Request ID is always included in error responses
"""

import logging
import traceback
from typing import Callable

from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

from src.config import settings

logger = logging.getLogger(__name__)


class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """Middleware for catching and formatting unhandled errors.

    This middleware complements FastAPI exception handlers by providing
    error catching for the middleware layer. It should be registered
    AFTER RequestLoggingMiddleware to ensure request_id is available.

    Features:
    - Catches exceptions from downstream middleware
    - Logs errors with full traceback and request context
    - Returns consistent JSON error format
    - Includes debug info only when settings.debug is True
    - Adds X-Request-ID header to error responses

    Middleware Registration Order:
    The error handling middleware should be registered AFTER the
    request logging middleware (meaning it executes AFTER logging
    on the request path but BEFORE logging on the response path):

        app.add_middleware(RequestLoggingMiddleware)  # First registered
        app.add_middleware(ErrorHandlingMiddleware)   # Second registered

    Starlette processes in reverse: ErrorHandling wraps RequestLogging.

    Example Response (Production):
        {
            "success": false,
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "An unexpected error occurred",
                "request_id": "abc12345"
            }
        }

    Example Response (Debug Mode):
        {
            "success": false,
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "An unexpected error occurred",
                "request_id": "abc12345",
                "debug": {
                    "type": "ValueError",
                    "message": "Invalid configuration",
                    "traceback": ["Traceback (most recent call last):", ...]
                }
            }
        }
    """

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        """Process request with error catching.

        Args:
            request: The incoming HTTP request.
            call_next: The next middleware/handler in the chain.

        Returns:
            Either the normal response or a formatted error response.
        """
        try:
            response: Response = await call_next(request)
            return response
        except Exception as exc:
            return self._handle_exception(request, exc)

    def _handle_exception(self, request: Request, exc: Exception) -> JSONResponse:
        """Handle an exception and return formatted error response.

        Args:
            request: The HTTP request that caused the error.
            exc: The exception that was raised.

        Returns:
            A JSONResponse with consistent error format.
        """
        # Get request ID if available (set by RequestLoggingMiddleware)
        request_id = getattr(request.state, "request_id", "unknown")

        # Log the error with full context
        logger.exception(
            "Unhandled middleware exception",
            extra={
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "query": str(request.query_params) if request.query_params else None,
                "error_type": type(exc).__name__,
                "error_message": str(exc),
            },
        )

        # Build error response
        error_response = self._build_error_response(request_id, exc)

        return JSONResponse(
            status_code=500,
            content=error_response,
            headers={"X-Request-ID": request_id},
        )

    def _build_error_response(
        self,
        request_id: str,
        exc: Exception,
    ) -> dict:
        """Build the error response dictionary.

        Args:
            request_id: The correlation request ID.
            exc: The exception that was raised.

        Returns:
            Dictionary matching the standard error response format.
        """
        error_content: dict = {
            "code": "INTERNAL_SERVER_ERROR",
            "message": "An unexpected error occurred",
            "request_id": request_id,
        }

        # Include debug information only in debug mode
        if settings.debug:
            error_content["debug"] = {
                "type": type(exc).__name__,
                "message": str(exc),
                "traceback": traceback.format_exc().split("\n"),
            }

        return {
            "success": False,
            "error": error_content,
        }
```

---

## Middleware Registration Order

### Updated `src/main.py`

The middleware must be registered in the correct order. In Starlette/FastAPI, middleware is processed in **reverse order** of registration:

```python
# Current registration (src/main.py lines 93-99):
app.add_middleware(AuthLoggingMiddleware)
app.add_middleware(RequestLoggingMiddleware)

# Updated registration order:
app.add_middleware(AuthLoggingMiddleware)       # 4th to execute on request
app.add_middleware(ErrorHandlingMiddleware)     # 3rd to execute on request
app.add_middleware(RequestLoggingMiddleware)    # 2nd to execute on request
# CORSMiddleware is already first                # 1st to execute on request
```

**Execution Flow**:
```
Request Path (left to right):
CORS -> TrustedHost -> RequestLogging -> ErrorHandling -> AuthLogging -> Router

Response Path (right to left):
Router -> AuthLogging -> ErrorHandling -> RequestLogging -> TrustedHost -> CORS
```

### Registration Code

```python
# src/main.py - Updated middleware section

from src.middleware import (
    AuthLoggingMiddleware,
    ErrorHandlingMiddleware,
    RequestLoggingMiddleware,
)

# ... existing CORS and TrustedHost middleware ...

# Auth logging middleware for security monitoring
app.add_middleware(AuthLoggingMiddleware)

# Error handling middleware - catches exceptions from downstream middleware
# Registered after AuthLogging so it can catch errors from that middleware
app.add_middleware(ErrorHandlingMiddleware)

# Request logging middleware for comprehensive API observability
# Registered last so it executes first on requests (sets request_id)
app.add_middleware(RequestLoggingMiddleware)
```

---

## Error Response Format Specification

### Standard Error Response

All error responses follow this format, matching existing exception handlers:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "request_id": "abc12345"
  }
}
```

### Error Response with Debug Info (debug=True only)

```json
{
  "success": false,
  "error": {
    "code": "INTERNAL_SERVER_ERROR",
    "message": "An unexpected error occurred",
    "request_id": "abc12345",
    "debug": {
      "type": "ValueError",
      "message": "Invalid configuration value",
      "traceback": [
        "Traceback (most recent call last):",
        "  File \"/app/src/middleware/auth.py\", line 45, in dispatch",
        "    result = process_request()",
        "  File \"/app/src/middleware/auth.py\", line 52, in process_request",
        "    raise ValueError(\"Invalid configuration value\")",
        "ValueError: Invalid configuration value"
      ]
    }
  }
}
```

### Response Headers

| Header | Value | Description |
|--------|-------|-------------|
| `X-Request-ID` | `abc12345` | Request correlation ID |
| `Content-Type` | `application/json` | Response format |

---

## Integration Points

### Dependency on RequestLoggingMiddleware

The ErrorHandlingMiddleware depends on `request.state.request_id` being set by the RequestLoggingMiddleware:

```python
# In RequestLoggingMiddleware (src/middleware/logging.py, line 76):
request.state.request_id = request_id

# In ErrorHandlingMiddleware:
request_id = getattr(request.state, "request_id", "unknown")
```

If the request ID is not available (e.g., if RequestLoggingMiddleware hasn't run), it defaults to `"unknown"`.

### Integration with Existing Exception Handlers

The ErrorHandlingMiddleware **complements** (does not replace) existing exception handlers:

| Exception Source | Handler |
|------------------|---------|
| Endpoint code | FastAPI exception handlers in `main.py` |
| Dependency code | FastAPI exception handlers in `main.py` |
| Middleware code | **ErrorHandlingMiddleware** (new) |
| ASGI server errors | Server-level error handling |

### Update `src/middleware/__init__.py`

```python
"""Middleware package for Learn Greek Easy backend.

This package contains custom middleware components for:
- Authentication logging and security monitoring
- Request logging with timing and request ID correlation
- Error handling for middleware-level exceptions
- Future: Rate limiting
"""

from src.middleware.auth import AuthLoggingMiddleware
from src.middleware.error_handler import ErrorHandlingMiddleware
from src.middleware.logging import RequestLoggingMiddleware

__all__ = [
    "AuthLoggingMiddleware",
    "ErrorHandlingMiddleware",
    "RequestLoggingMiddleware",
]
```

---

## Testing Strategy

### Test File Location

`tests/unit/middleware/test_error_handler_middleware.py`

### Test Structure

Following the pattern established in `test_logging_middleware.py`:

```python
"""Unit tests for error handling middleware.

Tests cover:
- Exception catching and response formatting
- Request ID inclusion in error responses
- X-Request-ID header in responses
- Debug information in debug mode
- Debug information hidden in production mode
- Logging with full context
- Normal request passthrough
"""

import logging
from unittest.mock import MagicMock, patch

import pytest
from fastapi import FastAPI, Request
from fastapi.testclient import TestClient

from src.middleware.error_handler import ErrorHandlingMiddleware
from src.middleware.logging import RequestLoggingMiddleware


class TestExceptionCatching:
    """Tests for exception catching functionality."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        # Add in correct order (reverse of execution)
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/success")
        async def success_endpoint():
            return {"status": "ok"}

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app, raise_server_exceptions=False)

    def test_normal_requests_pass_through(self, client: TestClient):
        """Test that normal requests are not affected."""
        response = client.get("/api/v1/success")

        assert response.status_code == 200
        assert response.json() == {"status": "ok"}

    def test_catches_unhandled_exceptions(self, client: TestClient):
        """Test that exceptions are caught and return 500."""
        response = client.get("/api/v1/error")

        assert response.status_code == 500
        assert response.json()["success"] is False

    def test_returns_consistent_error_format(self, client: TestClient):
        """Test error response follows standard format."""
        response = client.get("/api/v1/error")

        data = response.json()
        assert "success" in data
        assert "error" in data
        assert "code" in data["error"]
        assert "message" in data["error"]


class TestRequestIdInErrors:
    """Tests for request ID inclusion in error responses."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app, raise_server_exceptions=False)

    def test_error_response_includes_request_id(self, client: TestClient):
        """Test that error response includes request_id."""
        response = client.get("/api/v1/error")

        data = response.json()
        assert "request_id" in data["error"]
        assert data["error"]["request_id"] is not None

    def test_error_header_includes_request_id(self, client: TestClient):
        """Test that X-Request-ID header is present in error response."""
        response = client.get("/api/v1/error")

        assert "X-Request-ID" in response.headers
        assert len(response.headers["X-Request-ID"]) == 8

    def test_header_and_body_request_id_match(self, client: TestClient):
        """Test that header and body request IDs match."""
        response = client.get("/api/v1/error")

        header_id = response.headers["X-Request-ID"]
        body_id = response.json()["error"]["request_id"]

        assert header_id == body_id


class TestDebugMode:
    """Tests for debug mode behavior."""

    @pytest.fixture
    def app_debug_true(self) -> FastAPI:
        """Create test app with debug=True."""
        app = FastAPI()
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Detailed error message")

        return app

    @pytest.fixture
    def client_debug(self, app_debug_true: FastAPI) -> TestClient:
        """Create test client for debug mode."""
        return TestClient(app_debug_true, raise_server_exceptions=False)

    def test_debug_info_included_when_debug_true(self, client_debug: TestClient):
        """Test that debug info is included when settings.debug is True."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            response = client_debug.get("/api/v1/error")
            data = response.json()

            assert "debug" in data["error"]
            assert "type" in data["error"]["debug"]
            assert "message" in data["error"]["debug"]
            assert "traceback" in data["error"]["debug"]

    def test_debug_info_contains_exception_type(self, client_debug: TestClient):
        """Test that debug info contains correct exception type."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            response = client_debug.get("/api/v1/error")
            data = response.json()

            assert data["error"]["debug"]["type"] == "ValueError"

    def test_debug_info_contains_exception_message(self, client_debug: TestClient):
        """Test that debug info contains exception message."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            response = client_debug.get("/api/v1/error")
            data = response.json()

            assert data["error"]["debug"]["message"] == "Detailed error message"

    def test_debug_info_contains_traceback(self, client_debug: TestClient):
        """Test that debug info contains traceback as list."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            response = client_debug.get("/api/v1/error")
            data = response.json()

            assert isinstance(data["error"]["debug"]["traceback"], list)
            assert len(data["error"]["debug"]["traceback"]) > 0

    def test_debug_info_hidden_when_debug_false(self, client_debug: TestClient):
        """Test that debug info is NOT included when settings.debug is False."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = False

            response = client_debug.get("/api/v1/error")
            data = response.json()

            assert "debug" not in data["error"]


class TestErrorLogging:
    """Tests for error logging functionality."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app, raise_server_exceptions=False)

    def test_logs_exception_with_logger_exception(self, client: TestClient):
        """Test that exceptions are logged using logger.exception."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            mock_logger.exception.assert_called_once()

    def test_log_contains_request_id(self, client: TestClient):
        """Test that log contains request ID."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert "request_id" in call_args.kwargs["extra"]

    def test_log_contains_method(self, client: TestClient):
        """Test that log contains HTTP method."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert call_args.kwargs["extra"]["method"] == "GET"

    def test_log_contains_path(self, client: TestClient):
        """Test that log contains request path."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert call_args.kwargs["extra"]["path"] == "/api/v1/error"

    def test_log_contains_error_type(self, client: TestClient):
        """Test that log contains error type."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert call_args.kwargs["extra"]["error_type"] == "ValueError"

    def test_log_contains_error_message(self, client: TestClient):
        """Test that log contains error message."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert call_args.kwargs["extra"]["error_message"] == "Test error"

    def test_log_message_is_correct(self, client: TestClient):
        """Test that log message is correct."""
        with patch("src.middleware.error_handler.logger") as mock_logger:
            client.get("/api/v1/error")

            call_args = mock_logger.exception.call_args
            assert call_args.args[0] == "Unhandled middleware exception"


class TestErrorCodeAndMessage:
    """Tests for error code and message in responses."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app, raise_server_exceptions=False)

    def test_error_code_is_internal_server_error(self, client: TestClient):
        """Test that error code is INTERNAL_SERVER_ERROR."""
        response = client.get("/api/v1/error")
        data = response.json()

        assert data["error"]["code"] == "INTERNAL_SERVER_ERROR"

    def test_error_message_is_generic(self, client: TestClient):
        """Test that error message is generic (no sensitive info)."""
        response = client.get("/api/v1/error")
        data = response.json()

        assert data["error"]["message"] == "An unexpected error occurred"
        # Original error message should NOT be in response (except in debug)
        assert "Test error" not in data["error"]["message"]

    def test_success_is_false(self, client: TestClient):
        """Test that success is false in error response."""
        response = client.get("/api/v1/error")
        data = response.json()

        assert data["success"] is False


class TestMissingRequestId:
    """Tests for behavior when request ID is not available."""

    @pytest.fixture
    def app_no_logging_middleware(self) -> FastAPI:
        """Create test app without RequestLoggingMiddleware."""
        app = FastAPI()
        # Only add ErrorHandlingMiddleware, no RequestLoggingMiddleware
        app.add_middleware(ErrorHandlingMiddleware)

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    def client(self, app_no_logging_middleware: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app_no_logging_middleware, raise_server_exceptions=False)

    def test_uses_unknown_when_request_id_missing(self, client: TestClient):
        """Test that 'unknown' is used when request_id is not set."""
        response = client.get("/api/v1/error")
        data = response.json()

        assert data["error"]["request_id"] == "unknown"

    def test_header_contains_unknown_when_missing(self, client: TestClient):
        """Test that X-Request-ID header contains 'unknown' when missing."""
        response = client.get("/api/v1/error")

        assert response.headers["X-Request-ID"] == "unknown"


class TestMiddlewareExceptionCatching:
    """Tests for catching exceptions from other middleware."""

    @pytest.fixture
    def app_with_failing_middleware(self) -> FastAPI:
        """Create test app with a failing middleware after error handler."""
        from starlette.middleware.base import BaseHTTPMiddleware

        class FailingMiddleware(BaseHTTPMiddleware):
            async def dispatch(self, request, call_next):
                raise RuntimeError("Middleware failure")

        app = FastAPI()
        # Order: FailingMiddleware runs AFTER ErrorHandling catches
        app.add_middleware(FailingMiddleware)
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app_with_failing_middleware: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app_with_failing_middleware, raise_server_exceptions=False)

    def test_catches_middleware_exceptions(self, client: TestClient):
        """Test that exceptions from other middleware are caught."""
        response = client.get("/api/v1/test")

        assert response.status_code == 500
        assert response.json()["success"] is False

    def test_catches_runtime_error_from_middleware(self, client: TestClient):
        """Test catching RuntimeError from middleware."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            response = client.get("/api/v1/test")
            data = response.json()

            assert data["error"]["debug"]["type"] == "RuntimeError"
            assert data["error"]["debug"]["message"] == "Middleware failure"


class TestBuildErrorResponseHelper:
    """Tests for the _build_error_response helper method."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return ErrorHandlingMiddleware(app=MagicMock())

    def test_build_error_response_structure(self, middleware):
        """Test error response has correct structure."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = False

            exc = ValueError("test")
            response = middleware._build_error_response("req123", exc)

            assert response["success"] is False
            assert response["error"]["code"] == "INTERNAL_SERVER_ERROR"
            assert response["error"]["message"] == "An unexpected error occurred"
            assert response["error"]["request_id"] == "req123"

    def test_build_error_response_debug_mode(self, middleware):
        """Test error response includes debug info when debug=True."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = True

            exc = ValueError("debug test")
            response = middleware._build_error_response("req456", exc)

            assert "debug" in response["error"]
            assert response["error"]["debug"]["type"] == "ValueError"
            assert response["error"]["debug"]["message"] == "debug test"

    def test_build_error_response_no_debug_in_production(self, middleware):
        """Test error response excludes debug info when debug=False."""
        with patch("src.middleware.error_handler.settings") as mock_settings:
            mock_settings.debug = False

            exc = ValueError("secret info")
            response = middleware._build_error_response("req789", exc)

            assert "debug" not in response["error"]
```

### Test Coverage Target

| Component | Target |
|-----------|--------|
| `src/middleware/error_handler.py` | 95%+ |

---

## Implementation Checklist

### Phase 1: Create ErrorHandlingMiddleware

- [ ] Create `src/middleware/error_handler.py` file
- [ ] Implement `ErrorHandlingMiddleware` class with `dispatch` method
- [ ] Implement `_handle_exception` method for formatting errors
- [ ] Implement `_build_error_response` method for building response dict
- [ ] Add comprehensive docstrings

### Phase 2: Integration

- [ ] Update `src/middleware/__init__.py` to export `ErrorHandlingMiddleware`
- [ ] Update `src/main.py` to register middleware in correct order
- [ ] Verify middleware registration order is correct

### Phase 3: Testing

- [ ] Create `tests/unit/middleware/test_error_handler_middleware.py`
- [ ] Implement all test classes as specified
- [ ] Run tests and verify passing
- [ ] Check test coverage meets 95% target

### Phase 4: Verification

- [ ] Test manually in development mode (verify debug info appears)
- [ ] Test with `DEBUG=false` (verify no debug info in response)
- [ ] Verify X-Request-ID header is present in error responses
- [ ] Verify error logs contain full context

---

## Success Criteria

### Functional Requirements

| Requirement | Verification Method |
|-------------|---------------------|
| Catches unhandled exceptions from middleware | Unit test with failing middleware |
| Logs errors with full traceback | Check log output in tests |
| Returns consistent JSON error format | Validate response structure in tests |
| Includes request_id in error responses | Check `error.request_id` field |
| Debug info only in debug mode | Test with `settings.debug` mocked |
| X-Request-ID header in error responses | Check response headers |

### Non-Functional Requirements

| Requirement | Target | Verification |
|-------------|--------|--------------|
| Middleware overhead | < 1ms | Timing tests (minimal processing) |
| Test coverage | 95%+ | Coverage report |
| No sensitive data in production errors | Ensured | Manual review + tests |

---

## Security Considerations

### Information Disclosure Prevention

1. **Production Mode** (`debug=False`):
   - Generic error message: "An unexpected error occurred"
   - No exception type, message, or traceback in response
   - Full details logged internally for debugging

2. **Debug Mode** (`debug=True`):
   - Exception type, message, and traceback included
   - **Never enable in production**
   - Useful for local development

### Sensitive Data in Logs

The middleware logs full exception details to the application logger. Ensure:
- Log aggregation systems are access-controlled
- Logs are not exposed publicly
- Log retention policies comply with data regulations

---

## Open Questions

### Resolved

1. **Should this middleware replace existing exception handlers?**
   - **Answer**: No. This middleware complements exception handlers by catching middleware-layer exceptions.

2. **What request ID format should be used?**
   - **Answer**: Use the same 8-character format as RequestLoggingMiddleware.

### Assumptions

1. RequestLoggingMiddleware is always registered before ErrorHandlingMiddleware
2. The `settings.debug` flag accurately reflects the environment
3. All middleware exceptions should return 500 status (no differentiation)

---

## References

- **Main Task Plan**: `/Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/backend/05/05-api-foundation-middleware-plan.md`
- **Request Logging Middleware**: `src/middleware/logging.py`
- **Existing Exception Handlers**: `src/main.py` (lines 110-240)
- **Configuration**: `src/config.py` (`settings.debug`)
- **Test Patterns**: `tests/unit/middleware/test_logging_middleware.py`

---

**Document Version**: 1.0
**Created**: 2025-12-06
**Author**: Architect Agent
**Status**: Ready for Implementation
