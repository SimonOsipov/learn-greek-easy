# Task 05.02: Request Logging Middleware - Technical Design Document

## Overview

**Feature**: Request Logging Middleware
**Parent Task**: 05 - API Foundation & Middleware
**File**: `src/middleware/logging.py`
**Status**: Pending
**Priority**: High

### Objective

Implement comprehensive HTTP request/response logging middleware that provides:
- Unique request ID generation for correlation
- Structured logging of all API requests
- Response timing and status tracking
- Configurable path exclusions

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Incoming HTTP Request                            │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      RequestLoggingMiddleware                            │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │  1. Check if path should be skipped (health probes, docs, etc.)   │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                    │                                     │
│                    ┌───────────────┴───────────────┐                    │
│                    ▼                               ▼                    │
│              [Skip Path]                    [Log Path]                  │
│                    │                               │                    │
│                    │                    ┌──────────┴──────────┐        │
│                    │                    ▼                     │        │
│                    │           2. Generate Request ID         │        │
│                    │              (8-char UUID)               │        │
│                    │                    │                     │        │
│                    │                    ▼                     │        │
│                    │           3. Store in request.state      │        │
│                    │                    │                     │        │
│                    │                    ▼                     │        │
│                    │           4. Log "Request started"       │        │
│                    │              - request_id                │        │
│                    │              - method, path              │        │
│                    │              - client_ip, user_agent     │        │
│                    │                    │                     │        │
│                    │                    ▼                     │        │
│                    │           5. Start timer                 │        │
│                    │                    │                     │        │
│                    └────────────────────┼─────────────────────┘        │
│                                         ▼                               │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                      call_next(request)                            │ │
│  │                   (Process through app)                            │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                                         │                               │
│                    ┌────────────────────┴────────────────────┐         │
│                    ▼                                         ▼         │
│              [Success]                              [Exception]        │
│                    │                                         │         │
│                    ▼                                         ▼         │
│           6. Calculate duration               Log exception with       │
│                    │                          request context          │
│                    ▼                                         │         │
│           7. Add X-Request-ID header                   Re-raise        │
│                    │                                                   │
│                    ▼                                                   │
│           8. Log "Request completed"                                   │
│              - request_id                                              │
│              - status_code                                             │
│              - duration_ms                                             │
│              - log level based on status                               │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         HTTP Response                                    │
│                   (with X-Request-ID header)                            │
└─────────────────────────────────────────────────────────────────────────┘
```

### Request ID Flow

```
┌──────────────┐     ┌──────────────────┐     ┌──────────────────┐
│   Generate   │────▶│  Store in State  │────▶│  Add to Logs     │
│   UUID[:8]   │     │  request.state.  │     │  extra={         │
│   "abc12345" │     │  request_id      │     │    request_id:   │
└──────────────┘     └──────────────────┘     │    "abc12345"    │
                                              │  }               │
                                              └──────────────────┘
                                                       │
                                                       ▼
                            ┌──────────────────────────────────────┐
                            │  Add to Response Header              │
                            │  X-Request-ID: abc12345              │
                            └──────────────────────────────────────┘
```

---

## Implementation Specification

### Class: RequestLoggingMiddleware

```python
"""Request logging middleware for comprehensive API observability."""

import logging
import time
import uuid
from typing import Callable

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

logger = logging.getLogger(__name__)


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware for logging all HTTP requests with timing and request IDs.

    Features:
    - Generates unique request ID for correlation
    - Logs request start with method, path, client IP
    - Logs response with status code and duration
    - Adds X-Request-ID header to response
    - Supports log level based on status code

    Attributes:
        EXCLUDED_PATHS: Paths to exclude from logging (health checks, static files)
    """

    EXCLUDED_PATHS: list[str] = [
        "/health/live",  # Liveness probe - too frequent
        "/docs",
        "/redoc",
        "/openapi.json",
        "/favicon.ico",
    ]

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        """Process request and log details."""
        # Skip excluded paths
        if self._should_skip(request.url.path):
            return await call_next(request)

        # Generate request ID
        request_id = str(uuid.uuid4())[:8]  # Short ID for readability

        # Store in request state for access by handlers
        request.state.request_id = request_id

        # Log request start
        start_time = time.perf_counter()
        client_ip = self._get_client_ip(request)

        logger.info(
            "Request started",
            extra={
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "query": str(request.query_params) if request.query_params else None,
                "client_ip": client_ip,
                "user_agent": request.headers.get("user-agent"),
            },
        )

        # Process request
        try:
            response = await call_next(request)
        except Exception as e:
            # Log unhandled exceptions
            duration_ms = (time.perf_counter() - start_time) * 1000
            logger.exception(
                "Request failed with unhandled exception",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "duration_ms": round(duration_ms, 2),
                    "error": str(e),
                },
            )
            raise

        # Calculate duration
        duration_ms = (time.perf_counter() - start_time) * 1000

        # Add request ID to response headers
        response.headers["X-Request-ID"] = request_id

        # Log response
        log_level = self._get_log_level(response.status_code)
        logger.log(
            log_level,
            "Request completed",
            extra={
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "status_code": response.status_code,
                "duration_ms": round(duration_ms, 2),
            },
        )

        return response

    def _should_skip(self, path: str) -> bool:
        """Check if path should be excluded from logging."""
        return any(path.startswith(excluded) for excluded in self.EXCLUDED_PATHS)

    def _get_client_ip(self, request: Request) -> str | None:
        """Extract client IP, handling proxied requests."""
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        if request.client:
            return request.client.host
        return None

    def _get_log_level(self, status_code: int) -> int:
        """Determine log level based on status code."""
        if status_code >= 500:
            return logging.ERROR
        elif status_code >= 400:
            return logging.WARNING
        return logging.INFO
```

---

## Configuration

### Excluded Paths

| Path | Reason |
|------|--------|
| `/health/live` | Kubernetes liveness probes - too frequent |
| `/docs` | OpenAPI documentation UI |
| `/redoc` | ReDoc documentation UI |
| `/openapi.json` | OpenAPI schema endpoint |
| `/favicon.ico` | Browser favicon requests |

**Note**: `/health` and `/health/ready` are NOT excluded - they provide useful observability data without being called as frequently as liveness probes.

### Log Levels by Status Code

| Status Range | Log Level | Use Case |
|--------------|-----------|----------|
| 2xx | INFO | Successful requests |
| 3xx | INFO | Redirects |
| 4xx | WARNING | Client errors (bad request, not found, unauthorized) |
| 5xx | ERROR | Server errors (internal error, service unavailable) |

---

## Integration

### Registration in main.py

```python
# src/main.py
from src.middleware.logging import RequestLoggingMiddleware

# Middleware registration order (reverse execution order)
# Register AFTER CORS but BEFORE rate limiting and error handling
app.add_middleware(RequestLoggingMiddleware)
```

### Middleware Execution Order

```
Request Flow:
1. CORSMiddleware (first registered, last to execute on request)
2. TrustedHostMiddleware
3. RequestLoggingMiddleware  ← THIS MIDDLEWARE
4. RateLimitingMiddleware
5. ErrorHandlingMiddleware
6. AuthLoggingMiddleware
7. Router/Endpoint
```

### Accessing Request ID in Handlers

```python
from fastapi import Request

@router.get("/example")
async def example_endpoint(request: Request):
    request_id = getattr(request.state, "request_id", "unknown")
    # Use request_id for logging, error reporting, etc.
    logger.info("Processing example", extra={"request_id": request_id})
```

---

## Response Headers

### X-Request-ID Header

Every response (except excluded paths) includes:

```http
HTTP/1.1 200 OK
X-Request-ID: abc12345
Content-Type: application/json
```

**CORS Requirement**: For browser access, `X-Request-ID` must be exposed via CORS. This is handled in Task 05.01:

```python
# src/config.py
cors_expose_headers: List[str] = ["X-Request-ID", "X-RateLimit-Limit", ...]
```

---

## Log Output Examples

### Successful Request (INFO)

```json
{
  "timestamp": "2025-12-05T10:30:00.123Z",
  "level": "INFO",
  "message": "Request started",
  "request_id": "abc12345",
  "method": "GET",
  "path": "/api/v1/decks",
  "query": "page=1&limit=10",
  "client_ip": "192.168.1.100",
  "user_agent": "Mozilla/5.0 ..."
}

{
  "timestamp": "2025-12-05T10:30:00.168Z",
  "level": "INFO",
  "message": "Request completed",
  "request_id": "abc12345",
  "method": "GET",
  "path": "/api/v1/decks",
  "status_code": 200,
  "duration_ms": 45.32
}
```

### Client Error (WARNING)

```json
{
  "timestamp": "2025-12-05T10:31:00.456Z",
  "level": "WARNING",
  "message": "Request completed",
  "request_id": "def67890",
  "method": "POST",
  "path": "/api/v1/auth/login",
  "status_code": 401,
  "duration_ms": 12.45
}
```

### Server Error (ERROR)

```json
{
  "timestamp": "2025-12-05T10:32:00.789Z",
  "level": "ERROR",
  "message": "Request completed",
  "request_id": "ghi11111",
  "method": "GET",
  "path": "/api/v1/cards/999",
  "status_code": 500,
  "duration_ms": 234.56
}
```

### Unhandled Exception

```json
{
  "timestamp": "2025-12-05T10:33:00.000Z",
  "level": "ERROR",
  "message": "Request failed with unhandled exception",
  "request_id": "jkl22222",
  "method": "POST",
  "path": "/api/v1/reviews",
  "duration_ms": 89.12,
  "error": "Database connection timeout",
  "exc_info": "Traceback (most recent call last): ..."
}
```

---

## Testing Strategy

### Unit Tests

**File**: `tests/unit/middleware/test_logging_middleware.py`

```python
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from fastapi import FastAPI
from fastapi.testclient import TestClient
from httpx import AsyncClient

from src.middleware.logging import RequestLoggingMiddleware


class TestRequestLoggingMiddleware:
    """Unit tests for request logging middleware."""

    @pytest.fixture
    def app(self):
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        @app.get("/health/live")
        async def health_live():
            return {"status": "alive"}

        @app.get("/api/v1/error")
        async def error_endpoint():
            raise ValueError("Test error")

        return app

    @pytest.fixture
    async def client(self, app):
        """Create async test client."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            yield client

    async def test_generates_request_id(self, client):
        """Test that request ID is generated and returned in header."""
        response = await client.get("/api/v1/test")

        assert response.status_code == 200
        assert "X-Request-ID" in response.headers
        assert len(response.headers["X-Request-ID"]) == 8

    async def test_request_id_is_unique(self, client):
        """Test that each request gets a unique ID."""
        response1 = await client.get("/api/v1/test")
        response2 = await client.get("/api/v1/test")

        assert response1.headers["X-Request-ID"] != response2.headers["X-Request-ID"]

    async def test_logs_request_start(self, client, caplog):
        """Test that request start is logged."""
        with caplog.at_level("INFO"):
            await client.get("/api/v1/test")

        assert "Request started" in caplog.text
        assert "/api/v1/test" in caplog.text

    async def test_logs_request_completed(self, client, caplog):
        """Test that request completion is logged."""
        with caplog.at_level("INFO"):
            await client.get("/api/v1/test")

        assert "Request completed" in caplog.text
        assert "200" in caplog.text

    async def test_excludes_health_live_from_logging(self, client, caplog):
        """Test that /health/live is excluded from logging."""
        with caplog.at_level("INFO"):
            response = await client.get("/health/live")

        assert response.status_code == 200
        assert "X-Request-ID" not in response.headers
        assert "Request started" not in caplog.text

    async def test_logs_client_ip_from_forwarded_header(self, client, caplog):
        """Test that X-Forwarded-For header is used for client IP."""
        with caplog.at_level("INFO"):
            await client.get(
                "/api/v1/test",
                headers={"X-Forwarded-For": "203.0.113.50, 70.41.3.18"}
            )

        assert "203.0.113.50" in caplog.text

    async def test_logs_warning_for_4xx(self, app, caplog):
        """Test that 4xx responses are logged as WARNING."""
        @app.get("/api/v1/notfound")
        async def not_found():
            from fastapi import HTTPException
            raise HTTPException(status_code=404)

        async with AsyncClient(app=app, base_url="http://test") as client:
            with caplog.at_level("WARNING"):
                await client.get("/api/v1/notfound")

        # Check WARNING level was used
        assert any(record.levelname == "WARNING" for record in caplog.records)

    async def test_logs_error_for_5xx(self, app, caplog):
        """Test that 5xx responses are logged as ERROR."""
        @app.get("/api/v1/servererror")
        async def server_error():
            from fastapi import HTTPException
            raise HTTPException(status_code=500)

        async with AsyncClient(app=app, base_url="http://test") as client:
            with caplog.at_level("ERROR"):
                await client.get("/api/v1/servererror")

        assert any(record.levelname == "ERROR" for record in caplog.records)

    async def test_logs_duration_in_milliseconds(self, client, caplog):
        """Test that duration is logged in milliseconds."""
        with caplog.at_level("INFO"):
            await client.get("/api/v1/test")

        assert "duration_ms" in caplog.text

    async def test_request_id_stored_in_state(self, app):
        """Test that request ID is accessible via request.state."""
        captured_request_id = None

        @app.get("/api/v1/capture")
        async def capture_endpoint(request):
            nonlocal captured_request_id
            captured_request_id = getattr(request.state, "request_id", None)
            return {"captured": captured_request_id}

        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.get("/api/v1/capture")

        assert captured_request_id is not None
        assert response.headers["X-Request-ID"] == captured_request_id


class TestRequestLoggingMiddlewareHelpers:
    """Tests for helper methods."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return RequestLoggingMiddleware(app=MagicMock())

    def test_should_skip_excluded_paths(self, middleware):
        """Test path exclusion logic."""
        assert middleware._should_skip("/health/live") is True
        assert middleware._should_skip("/docs") is True
        assert middleware._should_skip("/docs/oauth2-redirect") is True
        assert middleware._should_skip("/redoc") is True
        assert middleware._should_skip("/openapi.json") is True
        assert middleware._should_skip("/favicon.ico") is True

    def test_should_not_skip_api_paths(self, middleware):
        """Test that API paths are not skipped."""
        assert middleware._should_skip("/api/v1/decks") is False
        assert middleware._should_skip("/health") is False
        assert middleware._should_skip("/health/ready") is False
        assert middleware._should_skip("/api/v1/auth/login") is False

    def test_get_log_level_success(self, middleware):
        """Test log level for successful responses."""
        import logging
        assert middleware._get_log_level(200) == logging.INFO
        assert middleware._get_log_level(201) == logging.INFO
        assert middleware._get_log_level(204) == logging.INFO
        assert middleware._get_log_level(301) == logging.INFO
        assert middleware._get_log_level(302) == logging.INFO

    def test_get_log_level_client_error(self, middleware):
        """Test log level for client errors."""
        import logging
        assert middleware._get_log_level(400) == logging.WARNING
        assert middleware._get_log_level(401) == logging.WARNING
        assert middleware._get_log_level(403) == logging.WARNING
        assert middleware._get_log_level(404) == logging.WARNING
        assert middleware._get_log_level(422) == logging.WARNING
        assert middleware._get_log_level(429) == logging.WARNING

    def test_get_log_level_server_error(self, middleware):
        """Test log level for server errors."""
        import logging
        assert middleware._get_log_level(500) == logging.ERROR
        assert middleware._get_log_level(502) == logging.ERROR
        assert middleware._get_log_level(503) == logging.ERROR

    def test_get_client_ip_from_forwarded_for(self, middleware):
        """Test IP extraction from X-Forwarded-For."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": "203.0.113.50, 70.41.3.18",
            "X-Real-IP": None,
        }.get(k)
        request.client = None

        ip = middleware._get_client_ip(request)
        assert ip == "203.0.113.50"

    def test_get_client_ip_from_real_ip(self, middleware):
        """Test IP extraction from X-Real-IP."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": None,
            "X-Real-IP": "10.0.0.1",
        }.get(k)
        request.client = None

        ip = middleware._get_client_ip(request)
        assert ip == "10.0.0.1"

    def test_get_client_ip_from_client(self, middleware):
        """Test IP extraction from request.client."""
        request = MagicMock()
        request.headers.get.return_value = None
        request.client.host = "127.0.0.1"

        ip = middleware._get_client_ip(request)
        assert ip == "127.0.0.1"

    def test_get_client_ip_none(self, middleware):
        """Test IP extraction when no source available."""
        request = MagicMock()
        request.headers.get.return_value = None
        request.client = None

        ip = middleware._get_client_ip(request)
        assert ip is None
```

### Integration Tests

**File**: `tests/integration/middleware/test_logging_integration.py`

```python
import pytest
from httpx import AsyncClient

from src.main import app


class TestLoggingMiddlewareIntegration:
    """Integration tests for request logging middleware."""

    @pytest.fixture
    async def client(self):
        """Create async test client."""
        async with AsyncClient(app=app, base_url="http://test") as client:
            yield client

    async def test_request_id_propagates_through_chain(self, client, caplog):
        """Test request ID is consistent across all log entries."""
        response = await client.get("/api/v1/status")
        request_id = response.headers["X-Request-ID"]

        # All log entries should have the same request_id
        assert caplog.text.count(request_id) >= 2  # start + complete

    async def test_middleware_chain_preserves_response(self, client):
        """Test that middleware doesn't alter response body."""
        response = await client.get("/api/v1/status")

        assert response.status_code == 200
        data = response.json()
        assert "status" in data

    async def test_duration_is_reasonable(self, client, caplog):
        """Test that logged duration is within expected range."""
        import re

        await client.get("/api/v1/status")

        # Extract duration from logs
        match = re.search(r"duration_ms['\"]:\s*([\d.]+)", caplog.text)
        assert match is not None
        duration = float(match.group(1))

        # Should be positive and reasonable (< 5 seconds)
        assert 0 < duration < 5000
```

---

## Success Criteria

### Functional Requirements

- [ ] Request ID generated for each request (8-character UUID prefix)
- [ ] Request ID stored in `request.state.request_id`
- [ ] Request ID added to response as `X-Request-ID` header
- [ ] Request start logged with: method, path, query, client_ip, user_agent
- [ ] Request completion logged with: status_code, duration_ms
- [ ] Excluded paths skip logging entirely
- [ ] Client IP correctly extracted from proxy headers
- [ ] Log level matches response status code

### Non-Functional Requirements

- [ ] Middleware overhead < 1ms per request
- [ ] No memory leaks from request state
- [ ] Graceful handling of missing headers
- [ ] Thread-safe request ID generation

### Test Coverage

- [ ] Unit test coverage >= 95%
- [ ] All helper methods tested
- [ ] Integration test with full middleware chain
- [ ] Edge cases: missing headers, exceptions, excluded paths

---

## Dependencies

### Internal Dependencies

- `src/config.py` - For future configurable exclusion paths
- CORS configuration (Task 05.01) - For exposing `X-Request-ID` header

### External Dependencies

- `starlette.middleware.base.BaseHTTPMiddleware` - Base class
- `uuid` - Request ID generation
- `time` - Performance timing
- `logging` - Structured logging

---

## Security Considerations

1. **No Sensitive Data Logging**: Request bodies, auth tokens, and passwords are NOT logged
2. **IP Address Handling**: Client IPs logged for security auditing, subject to privacy policy
3. **User Agent**: Logged for analytics, not for fingerprinting
4. **Query Parameters**: Logged but may contain sensitive data in poorly designed APIs - consider filtering in production

---

## Future Enhancements

1. **Configurable Exclusions**: Allow configuration of excluded paths via settings
2. **Request Body Logging**: Optional logging of request body for debugging (with size limits)
3. **Correlation ID**: Support incoming `X-Correlation-ID` header for distributed tracing
4. **Structured Logging Format**: JSON formatter integration for log aggregation
5. **Metrics Integration**: Prometheus metrics for request duration histograms

---

## References

- **Parent Document**: [05-api-foundation-middleware-plan.md](./05-api-foundation-middleware-plan.md)
- **FastAPI Middleware**: https://fastapi.tiangolo.com/tutorial/middleware/
- **Starlette BaseHTTPMiddleware**: https://www.starlette.io/middleware/

---

**Document Version**: 1.0
**Created**: 2025-12-05
**Author**: Architecture Agent
**Status**: Ready for Implementation
