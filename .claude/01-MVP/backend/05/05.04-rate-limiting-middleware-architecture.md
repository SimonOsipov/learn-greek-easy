# Task 05.04: Rate Limiting Middleware - Technical Architecture Document

**Status**: ✅ COMPLETED (2025-12-06)
**PR**: [#13](https://github.com/SimonOsipov/learn-greek-easy/pull/13)
**Branch**: `feature/05.04-rate-limiting-middleware`

## Overview

**Feature**: Rate Limiting Middleware
**Architecture Pattern**: Redis-based Sliding Window Rate Limiting with Graceful Degradation
**Parent Task**: Task 05 - API Foundation & Middleware
**Dependencies**:
- Task 05.02 (Request Logging Middleware) - COMPLETED - provides `request.state.request_id`
- Task 05.03 (Error Handling Middleware) - COMPLETED - handles middleware exceptions
- Redis connection via `src/core/redis.py`

### Objectives

1. Protect API from abuse with configurable rate limits
2. Implement sliding window algorithm using Redis Sorted Sets for accurate rate limiting
3. Apply stricter limits to authentication endpoints (brute-force protection)
4. Provide graceful degradation when Redis is unavailable
5. Return standardized rate limit headers in all responses
6. Support IP-based client identification with proxy header support
7. Allow configuration via settings with feature flag to enable/disable

---

## Current State Analysis

### Existing Infrastructure

#### Redis Client (`src/core/redis.py`)
```python
# Global async Redis client with connection pooling
_redis_client: Optional[Redis] = None

async def init_redis() -> None:
    """Initialize Redis connection pool on application startup."""
    _connection_pool = ConnectionPool.from_url(
        settings.redis_url,
        max_connections=10,
        decode_responses=True,  # Returns strings instead of bytes
        socket_timeout=settings.health_check_redis_timeout,
        socket_connect_timeout=settings.health_check_redis_timeout,
    )
    _redis_client = Redis(connection_pool=_connection_pool)

def get_redis() -> Optional[Redis]:
    """Get the global Redis client instance."""
    return _redis_client
```

**Key Observations**:
- Redis client is initialized during app startup via lifespan
- Connection uses `decode_responses=True` - important for sorted set operations
- `get_redis()` returns `None` if Redis is not initialized/unavailable
- Connection pool with max 10 connections

#### Configuration (`src/config.py`)
```python
# Rate Limiting - Lines 244-246
rate_limit_enabled: bool = Field(default=True, description="Enable rate limiting")
rate_limit_per_minute: int = Field(default=60, description="General rate limit")
rate_limit_auth_per_minute: int = Field(default=5, description="Auth endpoint rate limit")

# Feature Flag - Line 278
feature_rate_limiting: bool = Field(default=True, description="Enable rate limiting")
```

**Note**: The task requires updating these defaults:
- `rate_limit_per_minute`: 60 -> 100
- `rate_limit_auth_per_minute`: 5 -> 10

#### Existing Middleware Pattern (`src/middleware/`)
The project follows a consistent middleware pattern:
- Extends `BaseHTTPMiddleware` from Starlette
- Uses `dispatch()` method with async/await
- Logs via `logging.getLogger(__name__)`
- Accesses `request.state.request_id` from `RequestLoggingMiddleware`
- Returns `JSONResponse` for error cases

#### Middleware Registration Order (`src/main.py`)
```python
# Current order (lines 76-102):
app.add_middleware(CORSMiddleware, ...)          # First registered
app.add_middleware(TrustedHostMiddleware, ...)   # Production only
app.add_middleware(AuthLoggingMiddleware)
app.add_middleware(ErrorHandlingMiddleware)
app.add_middleware(RequestLoggingMiddleware)     # Last registered

# Starlette execution order: RequestLogging -> Error -> Auth -> Trusted -> CORS
# Rate limiting should be added between Error and Auth
```

#### Auth Endpoints That Need Stricter Limits
From `src/api/v1/auth.py`:
- `POST /api/v1/auth/register` - User registration
- `POST /api/v1/auth/login` - User login
- `POST /api/v1/auth/google` - Google OAuth login
- `POST /api/v1/auth/refresh` - Token refresh (also sensitive)

---

## Technical Design

### Rate Limiting Algorithm: Sliding Window with Redis Sorted Sets

The sliding window algorithm provides more accurate rate limiting than fixed windows by avoiding the "burst at window boundary" problem.

**How it works**:
1. Use a Redis Sorted Set where:
   - **Key**: `ratelimit:{type}:{client_identifier}`
   - **Score**: Unix timestamp of the request
   - **Member**: Unique identifier (timestamp string is sufficient)
2. On each request:
   - Remove entries older than the window (ZREMRANGEBYSCORE)
   - Count remaining entries (ZCARD)
   - If count < limit: Add current request (ZADD), allow request
   - If count >= limit: Reject with 429
3. Set TTL on key equal to window duration to auto-cleanup

**Example**:
```
Window: 60 seconds, Limit: 100 requests
Time: 12:00:45, Client: 192.168.1.1

Key: ratelimit:api:192.168.1.1
Sorted Set Contents (after cleanup):
  Score       Member
  ------      ------
  1701867630  "1701867630.123456"  (12:00:30)
  1701867635  "1701867635.789012"  (12:00:35)
  1701867640  "1701867640.456789"  (12:00:40)

Count: 3 entries < 100 limit -> ALLOW
Add: 1701867645 "1701867645...." -> 4 entries
Remaining: 100 - 4 = 96
```

### Implementation

#### File: `src/middleware/rate_limit.py`

```python
"""Rate limiting middleware with Redis backend.

This middleware provides protection against API abuse by limiting the number
of requests a client can make within a time window. It uses a sliding window
algorithm with Redis Sorted Sets for accurate rate limiting.

Features:
- Redis-based sliding window algorithm for accurate limiting
- Different limits for auth endpoints vs general API
- Graceful degradation when Redis is unavailable (allows requests)
- Rate limit headers in all responses
- IP-based client identification with proxy header support
- Configurable via settings with feature flag

Rate Limit Headers:
- X-RateLimit-Limit: Maximum requests allowed in window
- X-RateLimit-Remaining: Requests remaining in current window
- X-RateLimit-Reset: Unix timestamp when window resets

Usage:
    from src.middleware.rate_limit import RateLimitingMiddleware

    app.add_middleware(RateLimitingMiddleware)

Example Response Headers:
    X-RateLimit-Limit: 100
    X-RateLimit-Remaining: 95
    X-RateLimit-Reset: 1701867700
"""

import logging
import time
from dataclasses import dataclass
from typing import Callable, Optional, Tuple

from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

from src.config import settings
from src.core.redis import get_redis

logger = logging.getLogger(__name__)


@dataclass
class RateLimitConfig:
    """Configuration for rate limiting on a specific path type.

    Attributes:
        limit: Maximum number of requests allowed in the window.
        window_seconds: Time window in seconds (default: 60).
        key_prefix: Redis key prefix for this rate limit type.
    """
    limit: int
    window_seconds: int = 60
    key_prefix: str = "ratelimit"


class RateLimitingMiddleware(BaseHTTPMiddleware):
    """Middleware for rate limiting API requests.

    Uses Redis Sorted Sets to implement a sliding window rate limiting
    algorithm. This provides accurate rate limiting without the "burst
    at window boundary" problem of fixed window algorithms.

    The middleware:
    1. Checks if rate limiting is enabled via settings.feature_rate_limiting
    2. Skips exempt paths (health checks, docs)
    3. Determines the appropriate rate limit based on path
    4. Checks current request count against limit using Redis
    5. Either allows the request or returns HTTP 429
    6. Adds rate limit headers to all responses

    When Redis is unavailable, the middleware gracefully degrades by
    allowing all requests and logging a warning.

    Attributes:
        AUTH_PATHS: Paths that receive stricter rate limiting.
        EXEMPT_PATHS: Paths exempt from rate limiting entirely.
    """

    # Auth endpoints receive stricter rate limiting
    # These are sensitive endpoints vulnerable to brute force attacks
    AUTH_PATHS: list[str] = [
        "/api/v1/auth/login",
        "/api/v1/auth/register",
        "/api/v1/auth/google",
        "/api/v1/auth/refresh",
    ]

    # Paths exempt from rate limiting
    # Health checks must always be accessible for monitoring
    # Docs/OpenAPI are static and don't need protection
    EXEMPT_PATHS: list[str] = [
        "/health",
        "/health/live",
        "/health/ready",
        "/docs",
        "/redoc",
        "/openapi.json",
    ]

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        """Process request with rate limiting.

        Args:
            request: The incoming HTTP request.
            call_next: The next middleware/handler in the chain.

        Returns:
            Either the normal response with rate limit headers,
            or a 429 response if rate limit is exceeded.
        """
        # Skip if rate limiting is disabled
        if not settings.feature_rate_limiting:
            return await call_next(request)

        path = request.url.path

        # Skip exempt paths
        if self._is_exempt(path):
            return await call_next(request)

        # Get rate limit configuration for this path
        rate_config = self._get_rate_config(path)

        # Get client identifier (IP-based)
        client_id = self._get_client_id(request)

        # Check rate limit using Redis
        allowed, remaining, reset_at = await self._check_rate_limit(
            client_id=client_id,
            rate_config=rate_config,
        )

        if not allowed:
            # Rate limit exceeded
            request_id = getattr(request.state, "request_id", "unknown")

            logger.warning(
                "Rate limit exceeded",
                extra={
                    "request_id": request_id,
                    "client_id": client_id,
                    "path": path,
                    "limit": rate_config.limit,
                    "window_seconds": rate_config.window_seconds,
                },
            )

            return self._rate_limit_response(rate_config, reset_at, request_id)

        # Process request normally
        response: Response = await call_next(request)

        # Add rate limit headers to response
        response.headers["X-RateLimit-Limit"] = str(rate_config.limit)
        response.headers["X-RateLimit-Remaining"] = str(max(0, remaining))
        response.headers["X-RateLimit-Reset"] = str(int(reset_at))

        return response

    def _is_exempt(self, path: str) -> bool:
        """Check if path is exempt from rate limiting.

        Args:
            path: The request URL path.

        Returns:
            True if the path should skip rate limiting.
        """
        return any(path.startswith(exempt) for exempt in self.EXEMPT_PATHS)

    def _get_rate_config(self, path: str) -> RateLimitConfig:
        """Get rate limit configuration for the given path.

        Auth endpoints receive stricter limits to protect against
        brute force attacks. All other endpoints use the general limit.

        Args:
            path: The request URL path.

        Returns:
            RateLimitConfig with appropriate limit settings.
        """
        if any(path.startswith(auth_path) for auth_path in self.AUTH_PATHS):
            return RateLimitConfig(
                limit=settings.rate_limit_auth_per_minute,
                window_seconds=60,
                key_prefix="ratelimit:auth",
            )

        return RateLimitConfig(
            limit=settings.rate_limit_per_minute,
            window_seconds=60,
            key_prefix="ratelimit:api",
        )

    def _get_client_id(self, request: Request) -> str:
        """Get unique client identifier from request.

        Extracts client IP address, handling proxied requests by
        checking proxy headers in order of precedence:
        1. X-Forwarded-For (first IP in chain)
        2. X-Real-IP
        3. Direct client connection

        Args:
            request: The HTTP request.

        Returns:
            Client IP address or "unknown" if not determinable.
        """
        # Check X-Forwarded-For (standard proxy header)
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            # Take the first IP (original client)
            return forwarded_for.split(",")[0].strip()

        # Check X-Real-IP (nginx proxy header)
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip.strip()

        # Fall back to direct connection
        if request.client:
            return request.client.host

        return "unknown"

    async def _check_rate_limit(
        self,
        client_id: str,
        rate_config: RateLimitConfig,
    ) -> Tuple[bool, int, float]:
        """Check if request is within rate limit using Redis.

        Implements sliding window algorithm using Redis Sorted Sets:
        1. Remove entries older than the window
        2. Count remaining entries
        3. If under limit, add current request
        4. Return whether request is allowed

        Args:
            client_id: Unique client identifier (IP address).
            rate_config: Rate limit configuration for this request.

        Returns:
            Tuple of (allowed, remaining, reset_timestamp):
            - allowed: True if request should be processed
            - remaining: Number of requests remaining in window
            - reset_timestamp: Unix timestamp when window resets
        """
        redis = get_redis()

        if redis is None:
            # Graceful degradation - allow request if Redis unavailable
            logger.warning(
                "Redis unavailable for rate limiting, allowing request",
                extra={"client_id": client_id},
            )
            return True, rate_config.limit, time.time() + rate_config.window_seconds

        current_time = time.time()
        window_start = current_time - rate_config.window_seconds
        reset_at = current_time + rate_config.window_seconds

        # Redis key format: ratelimit:{type}:{client_id}
        key = f"{rate_config.key_prefix}:{client_id}"

        try:
            # Use pipeline for atomic operations
            pipe = redis.pipeline()

            # 1. Remove entries older than window (sliding window cleanup)
            pipe.zremrangebyscore(key, 0, window_start)

            # 2. Count requests in current window
            pipe.zcard(key)

            # 3. Add current request with timestamp as score and member
            # Using timestamp as member ensures uniqueness
            member = f"{current_time}"
            pipe.zadd(key, {member: current_time})

            # 4. Set key expiry to window duration (auto-cleanup)
            pipe.expire(key, rate_config.window_seconds)

            # Execute pipeline
            results = await pipe.execute()

            # results[1] is the count from ZCARD (before adding current request)
            request_count = results[1]
            remaining = rate_config.limit - request_count - 1  # -1 for current request

            # If count before adding was >= limit, we're over the limit
            if request_count >= rate_config.limit:
                # Remove the request we just added since it's over limit
                await redis.zrem(key, member)
                return False, 0, reset_at

            return True, max(0, remaining), reset_at

        except Exception as e:
            logger.error(
                "Rate limit check failed",
                extra={
                    "client_id": client_id,
                    "error": str(e),
                    "error_type": type(e).__name__,
                },
            )
            # Graceful degradation - allow request on Redis error
            return True, rate_config.limit, time.time() + rate_config.window_seconds

    def _rate_limit_response(
        self,
        rate_config: RateLimitConfig,
        reset_at: float,
        request_id: str,
    ) -> JSONResponse:
        """Generate HTTP 429 rate limit exceeded response.

        The response includes:
        - Standard error body format matching other API errors
        - Retry-After header (RFC 6585)
        - Rate limit headers for client information
        - X-Request-ID for correlation

        Args:
            rate_config: Rate limit configuration that was exceeded.
            reset_at: Unix timestamp when the client can retry.
            request_id: Request ID for correlation.

        Returns:
            JSONResponse with 429 status and appropriate headers.
        """
        retry_after = max(1, int(reset_at - time.time()))

        return JSONResponse(
            status_code=429,
            content={
                "success": False,
                "error": {
                    "code": "RATE_LIMIT_EXCEEDED",
                    "message": "Too many requests. Please try again later.",
                    "request_id": request_id,
                    "retry_after": retry_after,
                },
            },
            headers={
                "X-RateLimit-Limit": str(rate_config.limit),
                "X-RateLimit-Remaining": "0",
                "X-RateLimit-Reset": str(int(reset_at)),
                "Retry-After": str(retry_after),
                "X-Request-ID": request_id,
            },
        )
```

---

## Configuration Updates

### File: `src/config.py`

Update the default rate limits as specified in the requirements:

```python
# Rate Limiting (around line 244)
rate_limit_enabled: bool = Field(default=True, description="Enable rate limiting")
rate_limit_per_minute: int = Field(
    default=100,  # Changed from 60
    description="General API rate limit per minute",
)
rate_limit_auth_per_minute: int = Field(
    default=10,  # Changed from 5
    description="Auth endpoint rate limit per minute (stricter for brute force protection)",
)
```

---

## Middleware Registration

### File: `src/main.py`

Update middleware imports and registration:

```python
# Update import (line 21)
from src.middleware import (
    AuthLoggingMiddleware,
    ErrorHandlingMiddleware,
    RateLimitingMiddleware,
    RequestLoggingMiddleware,
)

# Middleware registration section (around line 93-106)
# Order matters: Last registered = First to execute on request

# Auth logging middleware for security monitoring
app.add_middleware(AuthLoggingMiddleware)

# Rate limiting middleware - checks limits before processing
# Registered after AuthLogging so it executes BEFORE auth logging
app.add_middleware(RateLimitingMiddleware)

# Error handling middleware - catches exceptions from downstream middleware
app.add_middleware(ErrorHandlingMiddleware)

# Request logging middleware for comprehensive API observability
# Registered last so it executes first on requests (sets request_id)
app.add_middleware(RequestLoggingMiddleware)

# Remove the TODO comment about rate limiting (line 104-105)
```

### File: `src/middleware/__init__.py`

Update exports:

```python
"""Middleware package for Learn Greek Easy backend.

This package contains custom middleware components for:
- Authentication logging and security monitoring
- Request logging with timing and request ID correlation
- Error handling for middleware-level exceptions
- Rate limiting for API protection
"""

from src.middleware.auth import AuthLoggingMiddleware
from src.middleware.error_handler import ErrorHandlingMiddleware
from src.middleware.logging import RequestLoggingMiddleware
from src.middleware.rate_limit import RateLimitingMiddleware

__all__ = [
    "AuthLoggingMiddleware",
    "ErrorHandlingMiddleware",
    "RateLimitingMiddleware",
    "RequestLoggingMiddleware",
]
```

---

## Middleware Execution Order

With the rate limiting middleware added, the full execution order is:

```
Request Flow:
  Client
    │
    ▼
  RequestLoggingMiddleware (generates request_id, starts timing)
    │
    ▼
  ErrorHandlingMiddleware (catches any exceptions)
    │
    ▼
  RateLimitingMiddleware (checks rate limits, may return 429)
    │
    ▼
  AuthLoggingMiddleware (logs auth-specific requests)
    │
    ▼
  CORSMiddleware / TrustedHostMiddleware
    │
    ▼
  Router/Endpoints
    │
    ▼
  Response flows back through middleware in reverse
```

---

## Testing Strategy

### File: `tests/unit/middleware/test_rate_limit_middleware.py`

```python
"""Unit tests for rate limiting middleware.

Tests cover:
- Rate limit enforcement for general API endpoints
- Stricter limits for auth endpoints
- Rate limit headers in responses
- 429 response format when limit exceeded
- Path exemption logic
- Client IP extraction from headers
- Graceful degradation when Redis unavailable
- Sliding window algorithm behavior
"""

import time
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient

from src.middleware.rate_limit import RateLimitConfig, RateLimitingMiddleware


class TestRateLimitEnforcement:
    """Tests for rate limit enforcement."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        @app.post("/api/v1/auth/login")
        async def login_endpoint():
            return {"status": "logged_in"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    def test_allows_requests_under_limit(self, client: TestClient):
        """Test that requests within limit are allowed."""
        with patch("src.middleware.rate_limit.get_redis") as mock_get_redis:
            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 5, True, True])  # 5 requests so far
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert response.status_code == 200
            assert response.json() == {"status": "ok"}

    def test_includes_rate_limit_headers(self, client: TestClient):
        """Test that rate limit headers are present in response."""
        with patch("src.middleware.rate_limit.get_redis") as mock_get_redis:
            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 10, True, True])
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert "X-RateLimit-Limit" in response.headers
            assert "X-RateLimit-Remaining" in response.headers
            assert "X-RateLimit-Reset" in response.headers

    def test_blocks_requests_over_limit(self, client: TestClient):
        """Test that requests exceeding limit are blocked."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 100, True, True])  # At limit
            mock_redis.zrem = AsyncMock()
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert response.status_code == 429
            data = response.json()
            assert data["success"] is False
            assert data["error"]["code"] == "RATE_LIMIT_EXCEEDED"

    def test_429_response_includes_retry_after(self, client: TestClient):
        """Test that 429 response includes Retry-After header."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 100, True, True])
            mock_redis.zrem = AsyncMock()
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert response.status_code == 429
            assert "Retry-After" in response.headers
            retry_after = int(response.headers["Retry-After"])
            assert retry_after > 0
            assert retry_after <= 60


class TestAuthEndpointLimits:
    """Tests for stricter auth endpoint rate limits."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        @app.post("/api/v1/auth/login")
        async def login_endpoint():
            return {"status": "logged_in"}

        @app.post("/api/v1/auth/register")
        async def register_endpoint():
            return {"status": "registered"}

        @app.post("/api/v1/auth/google")
        async def google_endpoint():
            return {"status": "google_auth"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    def test_auth_endpoint_has_stricter_limit(self, client: TestClient):
        """Test that auth endpoints use stricter rate limit."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100
            mock_settings.rate_limit_auth_per_minute = 10

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 0, True, True])
            mock_get_redis.return_value = mock_redis

            response = client.post("/api/v1/auth/login")

            assert response.status_code == 200
            # Auth limit should be 10, not 100
            assert response.headers["X-RateLimit-Limit"] == "10"

    def test_general_endpoint_has_higher_limit(self, client: TestClient):
        """Test that general endpoints use higher rate limit."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100
            mock_settings.rate_limit_auth_per_minute = 10

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 0, True, True])
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert response.status_code == 200
            # General limit should be 100
            assert response.headers["X-RateLimit-Limit"] == "100"


class TestPathExemption:
    """Tests for path exemption logic."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return RateLimitingMiddleware(app=MagicMock())

    def test_health_endpoints_are_exempt(self, middleware):
        """Test that health check endpoints are exempt."""
        assert middleware._is_exempt("/health") is True
        assert middleware._is_exempt("/health/live") is True
        assert middleware._is_exempt("/health/ready") is True

    def test_docs_endpoints_are_exempt(self, middleware):
        """Test that documentation endpoints are exempt."""
        assert middleware._is_exempt("/docs") is True
        assert middleware._is_exempt("/redoc") is True
        assert middleware._is_exempt("/openapi.json") is True

    def test_api_endpoints_are_not_exempt(self, middleware):
        """Test that API endpoints are not exempt."""
        assert middleware._is_exempt("/api/v1/test") is False
        assert middleware._is_exempt("/api/v1/auth/login") is False
        assert middleware._is_exempt("/api/v1/decks") is False

    def test_root_endpoint_is_not_exempt(self, middleware):
        """Test that root endpoint is not exempt."""
        assert middleware._is_exempt("/") is False


class TestClientIPExtraction:
    """Tests for client IP extraction from headers."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return RateLimitingMiddleware(app=MagicMock())

    def test_extracts_ip_from_x_forwarded_for_single(self, middleware):
        """Test IP extraction from X-Forwarded-For with single IP."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": "203.0.113.50",
            "X-Real-IP": None,
        }.get(k)
        request.client = None

        ip = middleware._get_client_id(request)
        assert ip == "203.0.113.50"

    def test_extracts_first_ip_from_x_forwarded_for_chain(self, middleware):
        """Test IP extraction from X-Forwarded-For with multiple IPs."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": "203.0.113.50, 70.41.3.18, 192.0.2.1",
            "X-Real-IP": None,
        }.get(k)
        request.client = None

        ip = middleware._get_client_id(request)
        assert ip == "203.0.113.50"

    def test_extracts_ip_from_x_real_ip(self, middleware):
        """Test IP extraction from X-Real-IP header."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": None,
            "X-Real-IP": "10.0.0.1",
        }.get(k)
        request.client = None

        ip = middleware._get_client_id(request)
        assert ip == "10.0.0.1"

    def test_x_forwarded_for_takes_precedence(self, middleware):
        """Test that X-Forwarded-For takes precedence over X-Real-IP."""
        request = MagicMock()
        request.headers.get.side_effect = lambda k: {
            "X-Forwarded-For": "203.0.113.50",
            "X-Real-IP": "192.168.1.1",
        }.get(k)
        request.client = None

        ip = middleware._get_client_id(request)
        assert ip == "203.0.113.50"

    def test_falls_back_to_client_host(self, middleware):
        """Test fallback to request.client.host."""
        request = MagicMock()
        request.headers.get.return_value = None
        request.client.host = "127.0.0.1"

        ip = middleware._get_client_id(request)
        assert ip == "127.0.0.1"

    def test_returns_unknown_when_no_source(self, middleware):
        """Test returns 'unknown' when no IP source available."""
        request = MagicMock()
        request.headers.get.return_value = None
        request.client = None

        ip = middleware._get_client_id(request)
        assert ip == "unknown"


class TestGracefulDegradation:
    """Tests for graceful degradation when Redis unavailable."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    def test_allows_requests_when_redis_unavailable(self, client: TestClient):
        """Test that requests are allowed when Redis is unavailable."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100
            mock_get_redis.return_value = None

            response = client.get("/api/v1/test")

            assert response.status_code == 200

    def test_logs_warning_when_redis_unavailable(self, client: TestClient):
        """Test that warning is logged when Redis is unavailable."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
            patch("src.middleware.rate_limit.logger") as mock_logger,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100
            mock_get_redis.return_value = None

            client.get("/api/v1/test")

            mock_logger.warning.assert_called()
            call_args = mock_logger.warning.call_args
            assert "Redis unavailable" in call_args.args[0]

    def test_allows_requests_on_redis_error(self, client: TestClient):
        """Test that requests are allowed when Redis operation fails."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(side_effect=Exception("Redis connection error"))
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            assert response.status_code == 200


class TestFeatureFlag:
    """Tests for rate limiting feature flag."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    def test_skips_rate_limiting_when_disabled(self, client: TestClient):
        """Test that rate limiting is skipped when feature flag is disabled."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.feature_rate_limiting = False

            response = client.get("/api/v1/test")

            assert response.status_code == 200
            # No rate limit headers when disabled
            assert "X-RateLimit-Limit" not in response.headers


class TestRateLimitConfig:
    """Tests for RateLimitConfig dataclass."""

    def test_default_values(self):
        """Test default values for RateLimitConfig."""
        config = RateLimitConfig(limit=100)

        assert config.limit == 100
        assert config.window_seconds == 60
        assert config.key_prefix == "ratelimit"

    def test_custom_values(self):
        """Test custom values for RateLimitConfig."""
        config = RateLimitConfig(
            limit=10,
            window_seconds=30,
            key_prefix="ratelimit:auth",
        )

        assert config.limit == 10
        assert config.window_seconds == 30
        assert config.key_prefix == "ratelimit:auth"


class TestGetRateConfig:
    """Tests for _get_rate_config method."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return RateLimitingMiddleware(app=MagicMock())

    def test_auth_login_gets_auth_config(self, middleware):
        """Test that auth/login gets auth rate config."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.rate_limit_auth_per_minute = 10

            config = middleware._get_rate_config("/api/v1/auth/login")

            assert config.limit == 10
            assert config.key_prefix == "ratelimit:auth"

    def test_auth_register_gets_auth_config(self, middleware):
        """Test that auth/register gets auth rate config."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.rate_limit_auth_per_minute = 10

            config = middleware._get_rate_config("/api/v1/auth/register")

            assert config.limit == 10

    def test_auth_google_gets_auth_config(self, middleware):
        """Test that auth/google gets auth rate config."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.rate_limit_auth_per_minute = 10

            config = middleware._get_rate_config("/api/v1/auth/google")

            assert config.limit == 10

    def test_auth_refresh_gets_auth_config(self, middleware):
        """Test that auth/refresh gets auth rate config."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.rate_limit_auth_per_minute = 10

            config = middleware._get_rate_config("/api/v1/auth/refresh")

            assert config.limit == 10

    def test_general_endpoint_gets_general_config(self, middleware):
        """Test that general endpoints get general rate config."""
        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.rate_limit_per_minute = 100

            config = middleware._get_rate_config("/api/v1/decks")

            assert config.limit == 100
            assert config.key_prefix == "ratelimit:api"


class TestRateLimitResponse:
    """Tests for _rate_limit_response method."""

    @pytest.fixture
    def middleware(self):
        """Create middleware instance."""
        return RateLimitingMiddleware(app=MagicMock())

    def test_response_has_429_status(self, middleware):
        """Test that response has 429 status code."""
        config = RateLimitConfig(limit=100)
        reset_at = time.time() + 60

        response = middleware._rate_limit_response(config, reset_at, "test-req-id")

        assert response.status_code == 429

    def test_response_has_correct_body(self, middleware):
        """Test that response body has correct format."""
        config = RateLimitConfig(limit=100)
        reset_at = time.time() + 60

        response = middleware._rate_limit_response(config, reset_at, "test-req-id")
        body = response.body.decode()

        import json
        data = json.loads(body)

        assert data["success"] is False
        assert data["error"]["code"] == "RATE_LIMIT_EXCEEDED"
        assert data["error"]["request_id"] == "test-req-id"
        assert "retry_after" in data["error"]

    def test_response_has_required_headers(self, middleware):
        """Test that response has all required headers."""
        config = RateLimitConfig(limit=100)
        reset_at = time.time() + 60

        response = middleware._rate_limit_response(config, reset_at, "test-req-id")

        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers
        assert "X-RateLimit-Reset" in response.headers
        assert "Retry-After" in response.headers
        assert "X-Request-ID" in response.headers

    def test_retry_after_is_positive(self, middleware):
        """Test that Retry-After is a positive integer."""
        config = RateLimitConfig(limit=100)
        reset_at = time.time() + 30

        response = middleware._rate_limit_response(config, reset_at, "test-req-id")

        retry_after = int(response.headers["Retry-After"])
        assert retry_after > 0
        assert retry_after <= 60


class TestMiddlewareIntegration:
    """Integration tests for middleware with full request flow."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware stack."""
        from src.middleware.logging import RequestLoggingMiddleware
        from src.middleware.error_handler import ErrorHandlingMiddleware

        app = FastAPI()
        # Simulate production middleware stack
        app.add_middleware(RateLimitingMiddleware)
        app.add_middleware(ErrorHandlingMiddleware)
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    def test_request_id_flows_to_rate_limit_response(self, client: TestClient):
        """Test that request ID from logging middleware is in rate limit response."""
        with (
            patch("src.middleware.rate_limit.get_redis") as mock_get_redis,
            patch("src.middleware.rate_limit.settings") as mock_settings,
        ):
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 100

            mock_redis = AsyncMock()
            mock_redis.pipeline.return_value = mock_redis
            mock_redis.execute = AsyncMock(return_value=[0, 100, True, True])
            mock_redis.zrem = AsyncMock()
            mock_get_redis.return_value = mock_redis

            response = client.get("/api/v1/test")

            # Request ID should be in both header and body
            if response.status_code == 429:
                header_id = response.headers.get("X-Request-ID")
                body_id = response.json()["error"]["request_id"]
                assert header_id is not None
                assert header_id == body_id
```

---

## Integration Tests

### File: `tests/integration/api/test_rate_limiting.py`

```python
"""Integration tests for rate limiting with Redis.

These tests require a running Redis instance and test the full
rate limiting flow including Redis operations.

Mark tests with @pytest.mark.integration for CI/CD filtering.
"""

import asyncio
import time

import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient

from src.middleware.rate_limit import RateLimitingMiddleware


@pytest.mark.integration
class TestRateLimitingWithRedis:
    """Integration tests for rate limiting with actual Redis."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with middleware."""
        app = FastAPI()
        app.add_middleware(RateLimitingMiddleware)

        @app.get("/api/v1/test")
        async def test_endpoint():
            return {"status": "ok"}

        @app.post("/api/v1/auth/login")
        async def login_endpoint():
            return {"status": "logged_in"}

        return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    @pytest.mark.asyncio
    async def test_rate_limit_headers_with_real_redis(self, client: TestClient):
        """Test that rate limit headers are correct with real Redis."""
        # First request should show full remaining count
        response = client.get("/api/v1/test")

        if response.status_code == 200:
            limit = int(response.headers["X-RateLimit-Limit"])
            remaining = int(response.headers["X-RateLimit-Remaining"])
            reset = int(response.headers["X-RateLimit-Reset"])

            assert limit == 100  # General API limit
            assert remaining >= 0
            assert remaining < limit
            assert reset > time.time()

    @pytest.mark.asyncio
    async def test_remaining_decreases_with_requests(self, client: TestClient):
        """Test that remaining count decreases with each request."""
        # Make first request
        response1 = client.get(
            "/api/v1/test",
            headers={"X-Forwarded-For": "192.0.2.100"},  # Use unique IP
        )

        if response1.status_code == 200:
            remaining1 = int(response1.headers["X-RateLimit-Remaining"])

            # Make second request
            response2 = client.get(
                "/api/v1/test",
                headers={"X-Forwarded-For": "192.0.2.100"},
            )

            if response2.status_code == 200:
                remaining2 = int(response2.headers["X-RateLimit-Remaining"])

                # Remaining should have decreased
                assert remaining2 < remaining1

    @pytest.mark.asyncio
    async def test_different_ips_have_separate_limits(self, client: TestClient):
        """Test that different IPs have independent rate limits."""
        # Request from IP 1
        response1 = client.get(
            "/api/v1/test",
            headers={"X-Forwarded-For": "192.0.2.1"},
        )

        # Request from IP 2
        response2 = client.get(
            "/api/v1/test",
            headers={"X-Forwarded-For": "192.0.2.2"},
        )

        # Both should succeed (independent limits)
        assert response1.status_code == 200
        assert response2.status_code == 200

        # Both should have high remaining counts (only 1 request each)
        remaining1 = int(response1.headers["X-RateLimit-Remaining"])
        remaining2 = int(response2.headers["X-RateLimit-Remaining"])

        assert remaining1 >= 98  # Close to limit
        assert remaining2 >= 98


@pytest.mark.integration
@pytest.mark.slow
class TestRateLimitExhaustion:
    """Tests for rate limit exhaustion (may be slow)."""

    @pytest.fixture
    def app(self) -> FastAPI:
        """Create test FastAPI app with low limit for testing."""
        from unittest.mock import patch

        with patch("src.middleware.rate_limit.settings") as mock_settings:
            mock_settings.feature_rate_limiting = True
            mock_settings.rate_limit_per_minute = 5  # Low limit for testing
            mock_settings.rate_limit_auth_per_minute = 3

            app = FastAPI()
            app.add_middleware(RateLimitingMiddleware)

            @app.get("/api/v1/test")
            async def test_endpoint():
                return {"status": "ok"}

            return app

    @pytest.fixture
    def client(self, app: FastAPI) -> TestClient:
        """Create test client."""
        return TestClient(app)

    @pytest.mark.asyncio
    async def test_returns_429_when_limit_exceeded(self, client: TestClient):
        """Test that 429 is returned when limit is exceeded."""
        unique_ip = f"192.0.2.{int(time.time()) % 255}"

        # Make requests until limit is exceeded
        for i in range(10):  # More than limit
            response = client.get(
                "/api/v1/test",
                headers={"X-Forwarded-For": unique_ip},
            )

            if response.status_code == 429:
                # Verify 429 response format
                data = response.json()
                assert data["success"] is False
                assert data["error"]["code"] == "RATE_LIMIT_EXCEEDED"
                assert "retry_after" in data["error"]
                return

        # If we get here without 429, the test setup may be wrong
        # This is acceptable if Redis isn't available (graceful degradation)
        pass
```

---

## Implementation Checklist

### Pre-Implementation
- [ ] Verify Redis is running and accessible
- [ ] Confirm Task 05.02 (RequestLoggingMiddleware) is complete and merged
- [ ] Confirm Task 05.03 (ErrorHandlingMiddleware) is complete and merged

### Implementation Steps
1. [ ] Update `src/config.py`:
   - [ ] Change `rate_limit_per_minute` default from 60 to 100
   - [ ] Change `rate_limit_auth_per_minute` default from 5 to 10

2. [ ] Create `src/middleware/rate_limit.py`:
   - [ ] Implement `RateLimitConfig` dataclass
   - [ ] Implement `RateLimitingMiddleware` class
   - [ ] Implement `_is_exempt()` method
   - [ ] Implement `_get_rate_config()` method
   - [ ] Implement `_get_client_id()` method
   - [ ] Implement `_check_rate_limit()` method with Redis
   - [ ] Implement `_rate_limit_response()` method

3. [ ] Update `src/middleware/__init__.py`:
   - [ ] Add `RateLimitingMiddleware` import
   - [ ] Add to `__all__` list
   - [ ] Update module docstring

4. [ ] Update `src/main.py`:
   - [ ] Update middleware import
   - [ ] Add `RateLimitingMiddleware` in correct order
   - [ ] Remove TODO comment about rate limiting

5. [ ] Create `tests/unit/middleware/test_rate_limit_middleware.py`:
   - [ ] All test classes and methods as specified
   - [ ] Run tests and verify passing

6. [ ] Create `tests/integration/api/test_rate_limiting.py`:
   - [ ] Integration tests with Redis
   - [ ] Mark with `@pytest.mark.integration`

### Post-Implementation
- [ ] Run full test suite: `poetry run pytest -n auto`
- [ ] Run linting: `poetry run ruff check src/middleware/rate_limit.py`
- [ ] Run type checking: `poetry run mypy src/middleware/rate_limit.py`
- [ ] Test manually with curl:
  ```bash
  # Test rate limit headers
  curl -v http://localhost:8000/api/v1/status

  # Test 429 response (run many times quickly)
  for i in {1..120}; do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:8000/api/v1/status; done
  ```

---

## Success Criteria

### Functional Requirements

1. **Rate Limit Enforcement**
   - [ ] General API endpoints limited to 100 requests/minute
   - [ ] Auth endpoints limited to 10 requests/minute
   - [ ] Limits are per-client (IP-based)
   - [ ] Sliding window algorithm provides accurate limiting

2. **Rate Limit Headers**
   - [ ] `X-RateLimit-Limit` shows maximum allowed requests
   - [ ] `X-RateLimit-Remaining` shows requests left in window
   - [ ] `X-RateLimit-Reset` shows Unix timestamp of window reset
   - [ ] Headers present in all non-exempt responses

3. **429 Response**
   - [ ] HTTP 429 status code when limit exceeded
   - [ ] `Retry-After` header with seconds until retry
   - [ ] Standard error body format with `RATE_LIMIT_EXCEEDED` code
   - [ ] Request ID included in response

4. **Path Exemptions**
   - [ ] `/health`, `/health/live`, `/health/ready` exempt
   - [ ] `/docs`, `/redoc`, `/openapi.json` exempt
   - [ ] All other paths subject to rate limiting

5. **Client Identification**
   - [ ] Extracts IP from `X-Forwarded-For` header
   - [ ] Falls back to `X-Real-IP` header
   - [ ] Falls back to direct connection IP
   - [ ] Returns "unknown" if no IP available

6. **Graceful Degradation**
   - [ ] Allows requests when Redis unavailable
   - [ ] Logs warning when degraded
   - [ ] Does not crash or error on Redis failure

7. **Configuration**
   - [ ] `feature_rate_limiting` flag enables/disables
   - [ ] `rate_limit_per_minute` configures general limit
   - [ ] `rate_limit_auth_per_minute` configures auth limit

### Non-Functional Requirements

1. **Performance**
   - [ ] Rate limit check < 10ms (Redis operation)
   - [ ] Minimal impact on request latency

2. **Reliability**
   - [ ] Graceful degradation on Redis failure
   - [ ] No request failures due to rate limiter errors

3. **Testing**
   - [ ] Unit test coverage >= 90%
   - [ ] All edge cases tested
   - [ ] Integration tests pass with Redis

---

## Security Considerations

### Brute Force Protection
- Auth endpoints have 10x stricter limits (10 vs 100 per minute)
- Protects against password guessing attacks
- Protects against account enumeration

### IP Spoofing Mitigation
- Trusts `X-Forwarded-For` only when behind trusted proxy
- In production, ensure proxy configuration is correct
- Consider adding trusted proxy validation in future

### Rate Limit Bypass
- Each client IP gets independent limit
- Distributed attacks from multiple IPs still possible
- Consider adding user-based limits for authenticated requests (future enhancement)

---

## Open Questions

### Resolved
1. **Rate limits**: Updated to 100/min general, 10/min auth as specified
2. **Algorithm**: Using sliding window with Redis Sorted Sets
3. **Client ID**: IP-based with proxy header support

### Future Enhancements
1. **User-based limits**: For authenticated requests, could use user ID instead of IP
2. **Endpoint-specific limits**: Could allow per-endpoint configuration
3. **Rate limit tiers**: Could support different limits for different user roles
4. **Distributed bypass protection**: Could add global rate limiting across all IPs

---

## References

- **Parent Task**: `/Users/samosipov/Downloads/learn-greek-easy/.claude/01-MVP/backend/05/05-api-foundation-middleware-plan.md`
- **Redis Client**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/redis.py`
- **Configuration**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/config.py`
- **Logging Middleware**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/middleware/logging.py`
- **Error Handler**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/middleware/error_handler.py`
- **Auth Endpoints**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/api/v1/auth.py`

---

**Document Version**: 1.0
**Created**: 2025-12-06
**Author**: Architect Agent
**Status**: Ready for Implementation
