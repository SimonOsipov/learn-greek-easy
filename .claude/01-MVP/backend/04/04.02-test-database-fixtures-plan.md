# Subtask 04.02: Setup Test Database with Fixtures - PostgreSQL Only

**Document Version**: 2.1
**Created**: 2025-11-30
**Updated**: 2025-11-30
**Completed**: 2025-11-30
**Status**: âœ… COMPLETED
**Actual Duration**: ~60 minutes
**Priority**: Critical (Foundation for all database tests)
**Dependencies**: Task 02 (Database Models), Task 04.01 (Pytest Async Configuration)
**QA Report**: [task-04.02-verification.md](../../../qa/task-04.02-verification.md)

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites Verification](#prerequisites-verification)
3. [Step-by-Step Implementation](#step-by-step-implementation)
4. [Testing Instructions](#testing-instructions)
5. [Validation Checklist](#validation-checklist)
6. [Troubleshooting Guide](#troubleshooting-guide)
7. [Technical Considerations](#technical-considerations)
8. [Next Steps](#next-steps)

---

## Overview

### Objective

Setup a PostgreSQL-based test database infrastructure with fixtures for all database testing. This project uses PostgreSQL-specific features (native enums, `uuid_generate_v4()`, etc.) that are incompatible with SQLite, so we use PostgreSQL exclusively for both unit and integration tests.

### Architecture Decision: PostgreSQL Only

**Why PostgreSQL for all tests (no SQLite)?**

1. **PostgreSQL-specific features in models**:
   - Native PostgreSQL enums: `DeckLevel`, `CardDifficulty`, `CardStatus`, `ReviewRating`
   - Server-side UUID generation: `server_default=func.uuid_generate_v4()`
   - PostgreSQL-specific column options and indexing

2. **Test fidelity**: Tests run against the same database as production, catching database-specific issues early.

3. **Simplified codebase**: No conditional logic for different databases, no enum workarounds.

4. **Docker already available**: PostgreSQL container is already part of the development environment.

### What You'll Build

**New Files**:
1. `tests/fixtures/database.py` - Core database fixtures (engine, session, cleanup)
2. `tests/helpers/database.py` - Database test utilities and helpers

**Modified Files**:
1. `tests/conftest.py` - Import and expose database fixtures globally
2. `tests/fixtures/__init__.py` - Export database fixtures
3. `docker-compose.yml` - Add test database initialization

**Key Configurations**:
- Test database: `test_learn_greek`
- Connection URL: `postgresql+asyncpg://postgres:postgres@localhost:5433/test_learn_greek`
- Transaction rollback pattern for test isolation
- Automatic table creation/teardown between tests
- PostgreSQL health check before test runs

### Success Criteria

- [x] Test database `test_learn_greek` is created automatically
- [x] All existing tests continue to pass
- [x] New database fixture tests pass (24/24 tests)
- [x] Each test runs in isolation (no cross-test pollution)
- [x] Proper cleanup after each test
- [x] Session rollback pattern implemented correctly
- [x] PostgreSQL health check works before tests run

### Current State Analysis

**Existing Infrastructure**:
- PostgreSQL 16 Alpine in Docker (`learn-greek-postgres` container)
- Main database: `learn_greek_easy`
- Port: 5433 (mapped from container's 5432)
- Extensions: `uuid-ossp`, `pg_stat_statements`

**PostgreSQL-specific model features**:
- `server_default=func.uuid_generate_v4()` - UUID generation
- `DeckLevel` enum (A1, A2, B1, B2, C1, C2)
- `CardDifficulty` enum (easy, medium, hard)
- `CardStatus` enum (new, learning, review, mastered)
- `ReviewRating` enum (0-5)

---

## Prerequisites Verification

### Step 1: Verify PostgreSQL Container is Running

```bash
docker ps --filter "name=learn-greek-postgres"
```

**Expected Output**: Container `learn-greek-postgres` is running.

**If not running**, start it:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose up -d postgres
```

### Step 2: Verify Required Dependencies

Run this command to check that all required packages are installed:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry show | grep -E "(asyncpg|sqlalchemy|pytest)"
```

**Expected Output**:
```
asyncpg           0.30.x   An asyncio PostgreSQL client library
pytest            8.x.x    pytest: simple powerful testing with Python
pytest-asyncio    0.23.x   pytest support for asyncio
sqlalchemy        2.0.x    Database Abstraction Library
```

### Step 3: Verify Existing Tests Pass

Run existing tests to ensure we don't break anything:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/ -q --tb=no
```

**Expected**: All tests pass

### Step 4: Verify Database Models Import

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.db.models import User, Deck, Card, DeckLevel, CardDifficulty; from src.db.base import Base; print('Models imported successfully')"
```

**Expected**: "Models imported successfully"

### Step 5: Verify PostgreSQL Connection

```bash
docker exec -it learn-greek-postgres psql -U postgres -c "SELECT version();"
```

**Expected**: PostgreSQL 16.x version information

---

## Step-by-Step Implementation

### STEP 1: Create Test Database via Docker Initialization

**Option A: Create manually (one-time setup)**

```bash
docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
```

**Option B: Add initialization script (recommended for team/CI)**

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/docker/postgres/init-test-db.sql`

```sql
-- Create test database if it doesn't exist
SELECT 'CREATE DATABASE test_learn_greek'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'test_learn_greek')\gexec

-- Connect to test database and create extensions
\c test_learn_greek

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";
```

**Update docker-compose.yml** to mount the init script:

Add to the postgres service volumes:
```yaml
volumes:
  - postgres_data:/var/lib/postgresql/data
  - ./docker/postgres:/docker-entrypoint-initdb.d:ro
```

**Note**: The init script only runs on first container creation. For existing containers, use Option A.

### STEP 2: Create Database Helpers Module

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/helpers/__init__.py`

```python
"""Test helpers package.

This package contains utility functions and helpers for testing:
- database.py: Database setup, teardown, and utility functions
- assertions.py: Custom assertion helpers (future)
- mocks.py: Common mock objects and factories (future)
"""

__all__: list[str] = []
```

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/helpers/database.py`

```python
"""Database test utilities and helpers for PostgreSQL.

This module provides utility functions for database testing:
- Test database URL configuration
- Database state inspection utilities
- Connection testing helpers
- Test data timestamp utilities

Note: This project uses PostgreSQL exclusively for all tests.
      SQLite is not supported due to PostgreSQL-specific features
      (native enums, uuid_generate_v4, etc.).
"""

import os
from datetime import datetime, timedelta
from typing import Any

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession


# =============================================================================
# Test Database URL Configuration
# =============================================================================

# Default test database URL (PostgreSQL only)
DEFAULT_TEST_DATABASE_URL = (
    "postgresql+asyncpg://postgres:postgres@localhost:5433/test_learn_greek"
)


def get_test_database_url() -> str:
    """Get the test database URL.

    Priority:
    1. TEST_DATABASE_URL environment variable (if set)
    2. Default PostgreSQL test database URL

    Returns:
        str: PostgreSQL database URL for testing.

    Example:
        >>> url = get_test_database_url()
        >>> url.startswith("postgresql")
        True
    """
    return os.environ.get("TEST_DATABASE_URL", DEFAULT_TEST_DATABASE_URL)


# =============================================================================
# Database State Utilities
# =============================================================================


async def count_table_rows(session: AsyncSession, table_name: str) -> int:
    """Count rows in a table.

    Useful for verifying test data setup/cleanup.

    Args:
        session: Database session.
        table_name: Name of the table to count.

    Returns:
        int: Number of rows in the table.
    """
    result = await session.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
    return result.scalar() or 0


async def table_exists(session: AsyncSession, table_name: str) -> bool:
    """Check if a table exists in the database.

    Args:
        session: Database session.
        table_name: Name of the table to check.

    Returns:
        bool: True if table exists, False otherwise.
    """
    result = await session.execute(
        text(
            """
            SELECT EXISTS (
                SELECT FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_name = :table_name
            )
            """
        ),
        {"table_name": table_name},
    )
    return result.scalar() or False


async def clear_table(session: AsyncSession, table_name: str) -> None:
    """Delete all rows from a table using TRUNCATE.

    WARNING: Use with caution. Only for test cleanup.
    Uses TRUNCATE for better performance with PostgreSQL.

    Args:
        session: Database session.
        table_name: Name of the table to clear.
    """
    await session.execute(text(f"TRUNCATE TABLE {table_name} CASCADE"))
    await session.commit()


async def get_table_names(engine: AsyncEngine) -> list[str]:
    """Get all table names in the database.

    Args:
        engine: Database engine.

    Returns:
        list[str]: List of table names.
    """
    async with engine.connect() as conn:
        result = await conn.execute(
            text(
                """
                SELECT table_name FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_type = 'BASE TABLE'
                ORDER BY table_name
                """
            )
        )
        return [row[0] for row in result.fetchall()]


# =============================================================================
# Connection Testing
# =============================================================================


async def verify_connection(engine: AsyncEngine) -> bool:
    """Verify that database connection works.

    Args:
        engine: Database engine to test.

    Returns:
        bool: True if connection successful, False otherwise.
    """
    try:
        async with engine.connect() as conn:
            await conn.execute(text("SELECT 1"))
        return True
    except Exception:
        return False


async def verify_extensions(engine: AsyncEngine) -> dict[str, bool]:
    """Verify required PostgreSQL extensions are installed.

    Args:
        engine: Database engine.

    Returns:
        dict: Extension name to installed status mapping.
    """
    extensions_to_check = ["uuid-ossp", "pg_stat_statements"]
    results = {}

    async with engine.connect() as conn:
        for ext in extensions_to_check:
            result = await conn.execute(
                text(
                    """
                    SELECT EXISTS (
                        SELECT 1 FROM pg_extension WHERE extname = :ext
                    )
                    """
                ),
                {"ext": ext},
            )
            results[ext] = result.scalar() or False

    return results


async def get_database_info(engine: AsyncEngine) -> dict[str, Any]:
    """Get information about the database connection.

    Args:
        engine: Database engine.

    Returns:
        dict: Database information including version, extensions, etc.
    """
    info: dict[str, Any] = {
        "dialect": engine.dialect.name,
        "driver": engine.dialect.driver,
    }

    async with engine.connect() as conn:
        # Get PostgreSQL version
        result = await conn.execute(text("SELECT version()"))
        info["version"] = result.scalar()

        # Get database name
        result = await conn.execute(text("SELECT current_database()"))
        info["database"] = result.scalar()

        # Get extensions
        info["extensions"] = await verify_extensions(engine)

    return info


# =============================================================================
# Test Data Timestamps
# =============================================================================


def utc_now() -> datetime:
    """Get current UTC datetime for test data.

    Returns:
        datetime: Current UTC datetime.
    """
    return datetime.utcnow()


def days_ago(days: int) -> datetime:
    """Get datetime for N days ago.

    Args:
        days: Number of days ago.

    Returns:
        datetime: Datetime for N days ago.
    """
    return datetime.utcnow() - timedelta(days=days)


def days_from_now(days: int) -> datetime:
    """Get datetime for N days from now.

    Args:
        days: Number of days from now.

    Returns:
        datetime: Datetime for N days from now.
    """
    return datetime.utcnow() + timedelta(days=days)


# =============================================================================
# PostgreSQL-Specific Utilities
# =============================================================================


async def reset_sequences(session: AsyncSession, table_name: str) -> None:
    """Reset auto-increment sequences for a table.

    Note: Not typically needed for UUID primary keys, but useful
    for tables with serial columns.

    Args:
        session: Database session.
        table_name: Name of the table.
    """
    await session.execute(
        text(
            f"""
            SELECT setval(pg_get_serial_sequence('{table_name}', 'id'), 1, false)
            WHERE pg_get_serial_sequence('{table_name}', 'id') IS NOT NULL
            """
        )
    )


async def get_enum_values(session: AsyncSession, enum_name: str) -> list[str]:
    """Get values for a PostgreSQL enum type.

    Args:
        session: Database session.
        enum_name: Name of the enum type.

    Returns:
        list[str]: List of enum values.
    """
    result = await session.execute(
        text(
            """
            SELECT enumlabel FROM pg_enum
            WHERE enumtypid = (
                SELECT oid FROM pg_type WHERE typname = :enum_name
            )
            ORDER BY enumsortorder
            """
        ),
        {"enum_name": enum_name},
    )
    return [row[0] for row in result.fetchall()]
```

### STEP 3: Create Core Database Fixtures

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/fixtures/database.py`

```python
"""Database fixtures for testing with PostgreSQL.

This module provides comprehensive database fixtures for testing:
- db_engine: Creates async PostgreSQL engine
- db_session: Provides AsyncSession with automatic rollback
- test_db: Ensures test database exists and tables are created

All fixtures use PostgreSQL exclusively. SQLite is not supported
due to PostgreSQL-specific features (native enums, uuid_generate_v4, etc.).

Usage:
    # In test functions
    async def test_create_user(db_session: AsyncSession):
        user = User(email="test@example.com", ...)
        db_session.add(user)
        await db_session.commit()
        # Session automatically rolls back after test
"""

import os
from collections.abc import AsyncGenerator

import pytest
import pytest_asyncio
from sqlalchemy import text
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.pool import NullPool

from src.db.base import Base
from tests.helpers.database import get_test_database_url, verify_connection


# =============================================================================
# Engine Configuration
# =============================================================================


def create_test_engine(database_url: str | None = None) -> AsyncEngine:
    """Create an async PostgreSQL engine configured for testing.

    Args:
        database_url: Database URL. If None, uses environment or default.

    Returns:
        AsyncEngine: Configured async engine for testing.

    Configuration details:
    - NullPool: Creates fresh connection for each request (clean isolation)
    - Echo disabled: Cleaner test output
    - Future mode: SQLAlchemy 2.0 API
    """
    url = database_url or get_test_database_url()

    engine = create_async_engine(
        url,
        echo=False,
        future=True,
        poolclass=NullPool,  # Clean connections for test isolation
    )

    return engine


def create_test_session_factory(
    engine: AsyncEngine,
) -> async_sessionmaker[AsyncSession]:
    """Create a session factory for testing.

    Args:
        engine: Async engine to bind sessions to.

    Returns:
        async_sessionmaker: Factory for creating test sessions.

    Configuration:
    - expire_on_commit=False: Keep objects accessible after commit
    - autoflush=False: Manual control over when to flush
    - autocommit=False: Explicit transaction control
    """
    return async_sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False,
        autoflush=False,
        autocommit=False,
    )


# =============================================================================
# Database Health Check
# =============================================================================


async def ensure_database_ready(engine: AsyncEngine) -> None:
    """Ensure database is ready for testing.

    Checks:
    1. Connection works
    2. Required extensions are installed

    Args:
        engine: Database engine to check.

    Raises:
        RuntimeError: If database is not ready.
    """
    # Check connection
    if not await verify_connection(engine):
        raise RuntimeError(
            f"Cannot connect to test database. "
            f"Ensure PostgreSQL is running: docker-compose up -d postgres"
        )

    # Check uuid-ossp extension (required for uuid_generate_v4)
    async with engine.connect() as conn:
        result = await conn.execute(
            text(
                """
                SELECT EXISTS (
                    SELECT 1 FROM pg_extension WHERE extname = 'uuid-ossp'
                )
                """
            )
        )
        has_uuid_extension = result.scalar()

        if not has_uuid_extension:
            # Try to create it
            try:
                await conn.execute(text('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"'))
                await conn.commit()
            except Exception as e:
                raise RuntimeError(
                    f"uuid-ossp extension not installed and cannot create: {e}"
                )


# =============================================================================
# Core Database Fixtures
# =============================================================================


@pytest_asyncio.fixture(scope="function")
async def db_engine() -> AsyncGenerator[AsyncEngine, None]:
    """Create a test database engine with table management.

    This fixture:
    1. Creates an async PostgreSQL engine
    2. Verifies database connection and extensions
    3. Creates all tables from Base.metadata
    4. Yields the engine for test use
    5. Drops all tables after the test
    6. Disposes the engine

    The scope is "function" to ensure complete isolation between tests.

    Yields:
        AsyncEngine: Test database engine.

    Raises:
        RuntimeError: If PostgreSQL is not available.

    Example:
        async def test_engine_works(db_engine: AsyncEngine):
            async with db_engine.connect() as conn:
                result = await conn.execute(text("SELECT 1"))
                assert result.scalar() == 1
    """
    engine = create_test_engine()

    # Ensure database is ready
    await ensure_database_ready(engine)

    # Create all tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    # Drop all tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    # Dispose engine
    await engine.dispose()


@pytest_asyncio.fixture(scope="function")
async def db_session(
    db_engine: AsyncEngine,
) -> AsyncGenerator[AsyncSession, None]:
    """Provide a test database session with automatic rollback.

    This fixture implements the "rollback after test" pattern:
    1. Creates a session from the engine
    2. Yields session for test use
    3. Rolls back ALL changes after the test

    This ensures each test starts with a clean database state,
    without the overhead of recreating tables.

    Args:
        db_engine: The test database engine fixture.

    Yields:
        AsyncSession: Database session that will be rolled back.

    Example:
        async def test_create_user(db_session: AsyncSession):
            user = User(email="test@example.com", password_hash="hash")
            db_session.add(user)
            await db_session.commit()
            # This commit is inside the test transaction
            # It will be rolled back after the test
    """
    session_factory = create_test_session_factory(db_engine)

    async with session_factory() as session:
        try:
            yield session
        finally:
            # Always rollback to ensure clean state
            await session.rollback()


@pytest_asyncio.fixture(scope="function")
async def db_session_with_savepoint(
    db_engine: AsyncEngine,
) -> AsyncGenerator[AsyncSession, None]:
    """Provide a database session using savepoint/nested transaction pattern.

    This is an alternative to db_session that uses savepoints for
    more granular transaction control. Useful when testing code that
    explicitly commits.

    The pattern:
    1. Begin outer transaction on connection
    2. Begin nested transaction (savepoint)
    3. Yield session
    4. Rollback to savepoint

    Args:
        db_engine: The test database engine fixture.

    Yields:
        AsyncSession: Session with savepoint-based isolation.
    """
    connection = await db_engine.connect()
    transaction = await connection.begin()

    session_factory = create_test_session_factory(db_engine)
    session = session_factory(bind=connection)

    # Start a savepoint (nested transaction)
    await connection.begin_nested()

    try:
        yield session
    finally:
        await session.close()
        await transaction.rollback()
        await connection.close()


# =============================================================================
# Session-Scoped Fixtures (for faster test suites)
# =============================================================================


@pytest_asyncio.fixture(scope="session")
async def session_db_engine() -> AsyncGenerator[AsyncEngine, None]:
    """Create a session-scoped database engine.

    WARNING: Use with caution. Tests sharing this engine must properly
    clean up after themselves to avoid test pollution.

    This is useful for test suites that need faster execution and can
    guarantee proper cleanup between tests.

    Yields:
        AsyncEngine: Shared database engine for the test session.
    """
    engine = create_test_engine()

    # Ensure database is ready
    await ensure_database_ready(engine)

    # Create all tables once
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    # Drop all tables once
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()


@pytest_asyncio.fixture(scope="function")
async def fast_db_session(
    session_db_engine: AsyncEngine,
) -> AsyncGenerator[AsyncSession, None]:
    """Provide a fast database session using shared engine.

    This fixture uses the session-scoped engine for faster test execution.
    Tables are not recreated between tests, so tests MUST clean up
    their own data or use unique identifiers.

    Args:
        session_db_engine: Session-scoped database engine.

    Yields:
        AsyncSession: Database session (will be rolled back).

    Example:
        async def test_fast(fast_db_session):
            # Use unique email to avoid conflicts
            user = User(email=f"test_{uuid4()}@example.com", ...)
    """
    session_factory = create_test_session_factory(session_db_engine)

    async with session_factory() as session:
        try:
            yield session
        finally:
            await session.rollback()


# =============================================================================
# Utility Fixtures
# =============================================================================


@pytest.fixture
def db_url() -> str:
    """Get the current test database URL.

    Returns:
        str: Database URL being used for tests.
    """
    return get_test_database_url()


@pytest_asyncio.fixture
async def clean_tables(db_session: AsyncSession) -> AsyncGenerator[None, None]:
    """Fixture that ensures tables are empty before and after test.

    This is useful for tests that need to start with a completely
    empty database and want to verify no data leaks.

    Yields:
        None: After ensuring tables are empty.
    """
    # Tables should already be empty from rollback pattern
    yield
    # Rollback happens automatically in db_session


@pytest_asyncio.fixture
async def verify_isolation(db_session: AsyncSession) -> AsyncGenerator[None, None]:
    """Fixture that verifies test isolation by checking table counts.

    Use this to debug test pollution issues.

    Yields:
        None: After verifying initial state.

    Raises:
        AssertionError: If tables are not empty at start.
    """
    from tests.helpers.database import count_table_rows

    # Check users table is empty (most common pollution source)
    try:
        count = await count_table_rows(db_session, "users")
        assert count == 0, f"Users table not empty at test start: {count} rows"
    except Exception:
        pass  # Table might not exist yet

    yield

    # Rollback happens automatically
```

### STEP 4: Update Tests Fixtures __init__.py

**File to Modify**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/fixtures/__init__.py`

```python
"""Test fixtures package.

This package contains reusable test fixtures:
- database.py: Database session and engine fixtures (PostgreSQL only)
- auth.py: Authentication-related fixtures (users, tokens, clients) - future
- data.py: Test data fixtures - future

Import fixtures in conftest.py to make them available globally.

Available Database Fixtures:
    db_engine: Async PostgreSQL engine (creates/drops tables per test)
    db_session: Async session with automatic rollback
    db_session_with_savepoint: Session using savepoint pattern
    session_db_engine: Shared engine across test session (faster)
    fast_db_session: Session using shared engine (faster, less isolated)

Note: All fixtures use PostgreSQL. SQLite is not supported due to
      PostgreSQL-specific features (native enums, uuid_generate_v4, etc.).

Usage:
    # In conftest.py
    from tests.fixtures.database import db_engine, db_session

    # In test files
    async def test_something(db_session: AsyncSession):
        ...
"""

from tests.fixtures.database import (
    clean_tables,
    create_test_engine,
    create_test_session_factory,
    db_engine,
    db_session,
    db_session_with_savepoint,
    db_url,
    fast_db_session,
    session_db_engine,
    verify_isolation,
)

__all__ = [
    # Core fixtures
    "db_engine",
    "db_session",
    "db_session_with_savepoint",
    # Fast fixtures (shared engine)
    "session_db_engine",
    "fast_db_session",
    # Utility fixtures
    "db_url",
    "clean_tables",
    "verify_isolation",
    # Factory functions (for custom engines/sessions)
    "create_test_engine",
    "create_test_session_factory",
]
```

### STEP 5: Update Global conftest.py

**File to Modify**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/conftest.py`

Replace the entire file with:

```python
"""Global test fixtures and configuration for Learn Greek Easy backend.

This module provides:
- Event loop configuration for async tests
- Pytest plugins and hooks
- Shared fixtures available to all tests
- Test markers registration
- Database fixtures for async testing (PostgreSQL only)

Fixture Organization:
- Database fixtures: tests/fixtures/database.py
- Auth fixtures: tests/integration/conftest.py
- Model fixtures: tests/unit/repositories/conftest.py

Note: All database fixtures use PostgreSQL exclusively.
      SQLite is not supported due to PostgreSQL-specific features.
"""

import asyncio
from collections.abc import AsyncGenerator, Generator
from typing import Any

import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

# Import database fixtures from fixtures package
from tests.fixtures.database import (
    db_engine,
    db_session,
    db_session_with_savepoint,
    session_db_engine,
    fast_db_session,
    db_url,
    clean_tables,
    verify_isolation,
)

# Re-export for backwards compatibility
__all__ = [
    "db_engine",
    "db_session",
    "db_session_with_savepoint",
    "session_db_engine",
    "fast_db_session",
    "db_url",
    "clean_tables",
    "verify_isolation",
]


# =============================================================================
# Event Loop Configuration
# =============================================================================


@pytest.fixture(scope="session")
def event_loop_policy():
    """Provide event loop policy for the test session.

    Uses the default asyncio event loop policy, which is appropriate for
    most cases. Override this fixture if you need a custom policy.

    Returns:
        asyncio.AbstractEventLoopPolicy: The event loop policy to use.
    """
    return asyncio.DefaultEventLoopPolicy()


# =============================================================================
# Pytest Configuration Hooks
# =============================================================================


def pytest_configure(config: pytest.Config) -> None:
    """Configure pytest with custom markers and settings.

    This hook runs during pytest's configuration phase, before test collection.
    We use it to:
    - Register custom markers (unit, integration, slow, auth, api, db)
    - Set up any global test configuration

    Args:
        config: The pytest configuration object.
    """
    # Register custom markers (also defined in pyproject.toml for IDE support)
    config.addinivalue_line(
        "markers", "unit: Unit tests (fast, isolated, mocked dependencies)"
    )
    config.addinivalue_line(
        "markers", "integration: Integration tests (slower, real database)"
    )
    config.addinivalue_line(
        "markers", "slow: Slow tests (>1s execution time)"
    )
    config.addinivalue_line(
        "markers", "auth: Authentication-related tests"
    )
    config.addinivalue_line(
        "markers", "api: API endpoint tests"
    )
    config.addinivalue_line(
        "markers", "db: Database-related tests"
    )


def pytest_collection_modifyitems(
    session: pytest.Session,
    config: pytest.Config,
    items: list[pytest.Item],
) -> None:
    """Modify collected test items.

    This hook runs after test collection. We use it to:
    - Auto-mark tests based on their location (unit/ or integration/)
    - Add default markers for test organization

    Args:
        session: The pytest session.
        config: The pytest configuration.
        items: List of collected test items.
    """
    for item in items:
        # Auto-mark tests based on directory
        test_path = str(item.fspath)
        if "unit/" in test_path:
            item.add_marker(pytest.mark.unit)
        elif "integration/" in test_path:
            item.add_marker(pytest.mark.integration)

        # Auto-mark auth-related tests
        if "auth" in item.name.lower() or "auth" in test_path.lower():
            item.add_marker(pytest.mark.auth)

        # Auto-mark middleware tests
        if "middleware" in test_path.lower():
            item.add_marker(pytest.mark.unit)

        # Auto-mark database tests
        if "db_session" in item.fixturenames or "db_engine" in item.fixturenames:
            item.add_marker(pytest.mark.db)


def pytest_report_header(config: pytest.Config) -> list[str]:
    """Add custom information to the pytest report header.

    This appears at the start of the test run output.

    Args:
        config: The pytest configuration.

    Returns:
        List of strings to add to the report header.
    """
    from tests.helpers.database import get_test_database_url

    db_url = get_test_database_url()

    return [
        "Learn Greek Easy Backend Test Suite",
        "Database: PostgreSQL (test_learn_greek)",
        f"URL: {db_url.split('@')[1] if '@' in db_url else db_url}",
        "Async Mode: auto (pytest-asyncio)",
        "=" * 50,
    ]


# =============================================================================
# HTTP Client Fixture
# =============================================================================


@pytest.fixture(scope="function")
async def client(db_session: AsyncSession) -> AsyncGenerator[AsyncClient, None]:
    """Create a test HTTP client.

    This client will use the test database session for all requests.

    Args:
        db_session: The test database session fixture.

    Yields:
        AsyncClient: The test HTTP client.
    """
    from src.db.dependencies import get_db
    from src.main import app

    # Override the get_db dependency to use our test session
    async def override_get_db() -> AsyncGenerator[AsyncSession, None]:
        yield db_session

    app.dependency_overrides[get_db] = override_get_db

    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

    # Clean up dependency overrides
    app.dependency_overrides.clear()


# =============================================================================
# Utility Fixtures
# =============================================================================


@pytest.fixture
def anyio_backend() -> str:
    """Specify the async backend for anyio-based tests.

    Returns:
        str: The backend name ("asyncio").
    """
    return "asyncio"


@pytest.fixture
def sample_password() -> str:
    """Provide a sample strong password for testing.

    This password meets all strength requirements:
    - 8+ characters
    - Uppercase and lowercase letters
    - Numbers
    - Special characters

    Returns:
        str: A valid strong password.
    """
    return "TestPassword123!"


@pytest.fixture
def sample_email() -> str:
    """Provide a sample email for testing.

    Returns:
        str: A valid test email address.
    """
    return "test@example.com"


@pytest.fixture
def sample_user_data(sample_email: str, sample_password: str) -> dict[str, Any]:
    """Provide sample user data for registration tests.

    Args:
        sample_email: The email fixture.
        sample_password: The password fixture.

    Returns:
        dict: User registration data.
    """
    return {
        "email": sample_email,
        "password": sample_password,
        "full_name": "Test User",
    }


# =============================================================================
# Test Environment Fixtures
# =============================================================================


@pytest.fixture(scope="session")
def test_settings() -> dict[str, Any]:
    """Provide test environment settings.

    Returns:
        dict: Configuration settings for tests.
    """
    from tests.helpers.database import get_test_database_url

    return {
        "testing": True,
        "debug": True,
        "database_url": get_test_database_url(),
        "jwt_secret": "test-secret-key-for-testing-only",
        "jwt_algorithm": "HS256",
        "access_token_expire_minutes": 30,
        "refresh_token_expire_days": 30,
    }


# =============================================================================
# Async Utility Fixtures
# =============================================================================


@pytest.fixture
async def async_sleep():
    """Provide an async sleep function for timing tests.

    Returns:
        Callable: An async sleep function.
    """
    async def _sleep(seconds: float) -> None:
        await asyncio.sleep(seconds)

    return _sleep


# =============================================================================
# Cleanup Fixtures
# =============================================================================


@pytest.fixture(autouse=True)
def reset_test_state() -> Generator[None, None, None]:
    """Reset any global test state between tests.

    This fixture runs automatically before and after each test,
    ensuring tests are isolated from each other.

    Yields:
        None: Allows the test to run.
    """
    # Setup: nothing to do yet
    yield
    # Teardown: nothing to do yet (database cleanup handled by db_session)
```

### STEP 6: Create Database Fixture Tests

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/unit/test_database_fixtures.py`

```python
"""Tests for database fixtures (PostgreSQL).

This module verifies that database fixtures work correctly:
- Engine creation and table management
- Session creation and rollback
- Test isolation between tests
- PostgreSQL-specific features (enums, UUIDs)

These tests ensure the testing infrastructure itself is working.
"""

import uuid

import pytest
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession

from src.db.models import User, Deck, Card, DeckLevel, CardDifficulty
from tests.helpers.database import (
    count_table_rows,
    get_test_database_url,
    table_exists,
    get_enum_values,
)


# =============================================================================
# Engine Fixture Tests
# =============================================================================


class TestDbEngine:
    """Tests for the db_engine fixture."""

    async def test_engine_is_created(self, db_engine: AsyncEngine):
        """Test that engine is created successfully."""
        assert db_engine is not None
        assert isinstance(db_engine, AsyncEngine)

    async def test_can_execute_query(self, db_engine: AsyncEngine):
        """Test that engine can execute queries."""
        async with db_engine.connect() as conn:
            result = await conn.execute(text("SELECT 1"))
            assert result.scalar() == 1

    async def test_tables_are_created(self, db_engine: AsyncEngine):
        """Test that all model tables are created."""
        async with db_engine.connect() as conn:
            result = await conn.execute(
                text(
                    """
                    SELECT table_name FROM information_schema.tables
                    WHERE table_schema = 'public'
                    AND table_type = 'BASE TABLE'
                    """
                )
            )
            tables = [row[0] for row in result.fetchall()]

            expected_tables = ["users", "decks", "cards", "reviews"]
            for table in expected_tables:
                assert table in tables, f"Table {table} not found"

    async def test_engine_uses_postgresql(self, db_engine: AsyncEngine):
        """Test that PostgreSQL is used."""
        assert db_engine.dialect.name == "postgresql"

    async def test_uuid_ossp_extension_available(self, db_engine: AsyncEngine):
        """Test that uuid-ossp extension is installed."""
        async with db_engine.connect() as conn:
            result = await conn.execute(
                text("SELECT uuid_generate_v4()")
            )
            uuid_value = result.scalar()
            assert uuid_value is not None
            # Should be a valid UUID string
            assert len(str(uuid_value)) == 36


# =============================================================================
# Session Fixture Tests
# =============================================================================


class TestDbSession:
    """Tests for the db_session fixture."""

    async def test_session_is_created(self, db_session: AsyncSession):
        """Test that session is created successfully."""
        assert db_session is not None
        assert isinstance(db_session, AsyncSession)

    async def test_can_add_and_query(self, db_session: AsyncSession):
        """Test that we can add and query data."""
        # Create a user
        user = User(
            email=f"test_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed_password",
            full_name="Test User",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()
        await db_session.refresh(user)

        # Query the user
        result = await db_session.execute(
            text("SELECT email FROM users WHERE id = :id"),
            {"id": str(user.id)},
        )
        row = result.fetchone()
        assert row is not None
        assert "test_" in row[0]

    async def test_commit_works(self, db_session: AsyncSession):
        """Test that commit persists data within the test."""
        # Create and commit
        user = User(
            email=f"commit_test_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="Commit Test",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()

        # Should be able to query
        count = await count_table_rows(db_session, "users")
        assert count >= 1


class TestSessionIsolation:
    """Tests for session isolation between tests.

    These tests verify that each test gets a clean database state.
    """

    async def test_isolation_part_1_create_user(self, db_session: AsyncSession):
        """Part 1: Create a user with a specific email."""
        user = User(
            email="isolation_test_user@example.com",
            password_hash="hashed",
            full_name="Isolation Test",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()

        # Verify user exists in this test
        count = await count_table_rows(db_session, "users")
        assert count >= 1

    async def test_isolation_part_2_check_clean_state(self, db_session: AsyncSession):
        """Part 2: Verify previous test's data is NOT present.

        This test runs after part 1 and verifies that the database
        was rolled back, so the user from part 1 should not exist.
        """
        # Check that the isolation_test_user does NOT exist
        result = await db_session.execute(
            text("SELECT COUNT(*) FROM users WHERE email = 'isolation_test_user@example.com'")
        )
        count = result.scalar()
        assert count == 0, "Data from previous test leaked through!"


# =============================================================================
# PostgreSQL-Specific Tests
# =============================================================================


class TestPostgreSQLFeatures:
    """Tests for PostgreSQL-specific features."""

    async def test_native_enum_deck_level(self, db_session: AsyncSession):
        """Test that DeckLevel enum works with PostgreSQL."""
        deck = Deck(
            name="Test Deck",
            description="Testing enums",
            level=DeckLevel.A1,
            is_active=True,
        )
        db_session.add(deck)
        await db_session.commit()
        await db_session.refresh(deck)

        assert deck.level == DeckLevel.A1

        # Query and verify
        result = await db_session.execute(
            text("SELECT level FROM decks WHERE id = :id"),
            {"id": str(deck.id)},
        )
        row = result.fetchone()
        assert row[0] == "A1"

    async def test_native_enum_card_difficulty(self, db_session: AsyncSession):
        """Test that CardDifficulty enum works with PostgreSQL."""
        deck = Deck(
            name="Test Deck",
            description="Testing card difficulty",
            level=DeckLevel.A1,
            is_active=True,
        )
        db_session.add(deck)
        await db_session.flush()

        card = Card(
            deck_id=deck.id,
            front_text="Hello",
            back_text="Yeia",
            difficulty=CardDifficulty.HARD,
            order_index=1,
        )
        db_session.add(card)
        await db_session.commit()
        await db_session.refresh(card)

        assert card.difficulty == CardDifficulty.HARD

    async def test_enum_values_in_database(self, db_session: AsyncSession):
        """Test that enum values are stored correctly in PostgreSQL."""
        enum_values = await get_enum_values(db_session, "decklevel")
        expected = ["A1", "A2", "B1", "B2", "C1", "C2"]
        assert enum_values == expected

    async def test_uuid_generation(self, db_session: AsyncSession):
        """Test that UUID primary keys are generated by PostgreSQL."""
        user = User(
            email=f"uuid_test_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="UUID Test",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()
        await db_session.refresh(user)

        # UUID should be generated by PostgreSQL
        assert user.id is not None
        # Should be a valid UUID
        assert len(str(user.id)) == 36


# =============================================================================
# Relationship Tests
# =============================================================================


class TestRelationships:
    """Test that SQLAlchemy relationships work correctly."""

    async def test_deck_cards_relationship(self, db_session: AsyncSession):
        """Test creating a deck with cards."""
        deck = Deck(
            name="Test Deck",
            description="A test deck",
            level=DeckLevel.A1,
            is_active=True,
        )
        db_session.add(deck)
        await db_session.flush()

        card = Card(
            deck_id=deck.id,
            front_text="Hello",
            back_text="Yeia",
            difficulty=CardDifficulty.EASY,
            order_index=1,
        )
        db_session.add(card)
        await db_session.commit()

        await db_session.refresh(deck)
        assert len(deck.cards) == 1
        assert deck.cards[0].front_text == "Hello"

    async def test_cascade_delete(self, db_session: AsyncSession):
        """Test that cascade deletes work."""
        # Create deck with cards
        deck = Deck(
            name="Cascade Test Deck",
            description="Testing cascades",
            level=DeckLevel.A1,
            is_active=True,
        )
        db_session.add(deck)
        await db_session.flush()

        card = Card(
            deck_id=deck.id,
            front_text="Hello",
            back_text="Yeia",
            difficulty=CardDifficulty.EASY,
            order_index=1,
        )
        db_session.add(card)
        await db_session.commit()

        card_id = card.id

        # Delete deck
        await db_session.delete(deck)
        await db_session.commit()

        # Card should be deleted too (CASCADE)
        result = await db_session.execute(
            text("SELECT COUNT(*) FROM cards WHERE id = :id"),
            {"id": str(card_id)},
        )
        count = result.scalar()
        assert count == 0


# =============================================================================
# Utility Function Tests
# =============================================================================


class TestDatabaseUtilities:
    """Tests for database utility functions."""

    def test_get_test_database_url(self):
        """Test that URL is PostgreSQL."""
        url = get_test_database_url()
        assert "postgresql" in url
        assert "test_learn_greek" in url

    async def test_count_table_rows(self, db_session: AsyncSession):
        """Test the count_table_rows helper."""
        # Add some users
        for i in range(3):
            user = User(
                email=f"count_test_{i}_{uuid.uuid4().hex[:4]}@example.com",
                password_hash="hashed",
                full_name=f"Count Test {i}",
                is_active=True,
            )
            db_session.add(user)
        await db_session.commit()

        count = await count_table_rows(db_session, "users")
        assert count >= 3

    async def test_table_exists(self, db_session: AsyncSession):
        """Test the table_exists helper."""
        assert await table_exists(db_session, "users") is True
        assert await table_exists(db_session, "nonexistent_table") is False


# =============================================================================
# Transaction Pattern Tests
# =============================================================================


class TestTransactionPatterns:
    """Tests for transaction handling patterns."""

    async def test_rollback_on_error(self, db_session: AsyncSession):
        """Test that session rollback works after errors."""
        user = User(
            email=f"rollback_test_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="Rollback Test",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()

        # This should work, verifying rollback didn't break anything
        result = await db_session.execute(text("SELECT COUNT(*) FROM users"))
        count = result.scalar()
        assert count >= 1

    async def test_multiple_commits(self, db_session: AsyncSession):
        """Test multiple commits within a single test."""
        # First commit
        user1 = User(
            email=f"multi_commit_1_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="Multi Commit 1",
            is_active=True,
        )
        db_session.add(user1)
        await db_session.commit()

        # Second commit
        user2 = User(
            email=f"multi_commit_2_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="Multi Commit 2",
            is_active=True,
        )
        db_session.add(user2)
        await db_session.commit()

        # Both should exist
        count = await count_table_rows(db_session, "users")
        assert count >= 2


# =============================================================================
# Edge Cases
# =============================================================================


class TestEdgeCases:
    """Test edge cases and potential issues."""

    async def test_empty_database_queries(self, db_session: AsyncSession):
        """Test queries on empty tables work correctly."""
        result = await db_session.execute(
            text("SELECT * FROM decks WHERE is_active = true")
        )
        rows = result.fetchall()
        assert isinstance(rows, list)

    async def test_timestamps_auto_generated(self, db_session: AsyncSession):
        """Test that created_at and updated_at are set."""
        user = User(
            email=f"timestamp_test_{uuid.uuid4().hex[:8]}@example.com",
            password_hash="hashed",
            full_name="Timestamp Test",
            is_active=True,
        )
        db_session.add(user)
        await db_session.commit()
        await db_session.refresh(user)

        # Timestamps should be set
        assert user.created_at is not None
        assert user.updated_at is not None

    async def test_unique_constraint_violation(self, db_session: AsyncSession):
        """Test that unique constraints work."""
        email = f"unique_test_{uuid.uuid4().hex[:8]}@example.com"

        user1 = User(
            email=email,
            password_hash="hashed",
            full_name="User 1",
            is_active=True,
        )
        db_session.add(user1)
        await db_session.commit()

        # Try to create another user with same email
        user2 = User(
            email=email,
            password_hash="hashed",
            full_name="User 2",
            is_active=True,
        )
        db_session.add(user2)

        with pytest.raises(Exception):  # IntegrityError
            await db_session.commit()

        await db_session.rollback()
```

### STEP 7: Create Verification Script

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/scripts/verify_database_fixtures.py`

```python
#!/usr/bin/env python3
"""Verify database fixtures are working correctly with PostgreSQL.

This script tests:
1. PostgreSQL connection
2. Test database exists
3. Required extensions are installed
4. Table creation/teardown
5. Session management
6. Test isolation

Run:
    cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
    /Users/samosipov/.local/bin/poetry run python scripts/verify_database_fixtures.py
"""

import asyncio
import subprocess
import sys
from uuid import uuid4


def print_header(text: str) -> None:
    """Print a section header."""
    print()
    print("=" * 70)
    print(text)
    print("=" * 70)


def print_result(check: str, passed: bool, details: str = "") -> None:
    """Print a check result."""
    status = "[PASS]" if passed else "[FAIL]"
    print(f"  {status} {check}")
    if details:
        print(f"         {details}")


async def main() -> int:
    """Run all verification checks."""
    print_header("DATABASE FIXTURES VERIFICATION (PostgreSQL)")
    print()
    print("This script verifies the test database infrastructure is working.")
    print("Note: PostgreSQL must be running (docker-compose up -d postgres)")
    print()

    all_passed = True

    # Check 1: Import fixtures
    print_header("Check 1: Import Database Fixtures")
    try:
        from tests.fixtures.database import (
            create_test_engine,
            create_test_session_factory,
        )
        from tests.helpers.database import (
            get_test_database_url,
            count_table_rows,
            verify_connection,
            verify_extensions,
        )
        print_result("Import fixtures", True)
    except ImportError as e:
        print_result("Import fixtures", False, str(e))
        all_passed = False
        return 1

    # Check 2: Test database URL configuration
    print_header("Check 2: Database URL Configuration")
    url = get_test_database_url()
    print_result("Get test URL", True, f"URL: ...{url.split('@')[1] if '@' in url else url}")

    if "postgresql" in url:
        print_result("PostgreSQL detected", True)
    else:
        print_result("PostgreSQL detected", False, f"Unexpected: {url}")
        all_passed = False
        return 1

    if "test_learn_greek" in url:
        print_result("Test database name", True)
    else:
        print_result("Test database name", False, "Expected 'test_learn_greek'")
        all_passed = False

    # Check 3: Create engine and verify connection
    print_header("Check 3: Create Test Engine")
    try:
        engine = create_test_engine()
        print_result("Create engine", True, f"Dialect: {engine.dialect.name}")

        if await verify_connection(engine):
            print_result("Database connection", True)
        else:
            print_result("Database connection", False, "Cannot connect to database")
            print()
            print("  HINT: Ensure PostgreSQL is running:")
            print("    docker-compose up -d postgres")
            print()
            print("  HINT: Create test database if needed:")
            print('    docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"')
            all_passed = False
            return 1

    except Exception as e:
        print_result("Create engine", False, str(e))
        all_passed = False
        return 1

    # Check 4: Verify extensions
    print_header("Check 4: Verify PostgreSQL Extensions")
    try:
        extensions = await verify_extensions(engine)
        for ext, installed in extensions.items():
            print_result(f"Extension: {ext}", installed)
            if not installed and ext == "uuid-ossp":
                print("  HINT: Create extension:")
                print('    docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \\"uuid-ossp\\";"')
                all_passed = False
    except Exception as e:
        print_result("Check extensions", False, str(e))
        all_passed = False

    # Check 5: Create tables
    print_header("Check 5: Create Tables")
    try:
        from src.db.base import Base

        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        print_result("Create tables", True)
    except Exception as e:
        print_result("Create tables", False, str(e))
        all_passed = False

    # Check 6: Create session and insert data
    print_header("Check 6: Session Operations")
    try:
        session_factory = create_test_session_factory(engine)
        async with session_factory() as session:
            print_result("Create session", True)

            # Execute simple query
            from sqlalchemy import text
            result = await session.execute(text("SELECT 1"))
            assert result.scalar() == 1
            print_result("Execute query", True)

            # Insert and query user
            from src.db.models import User
            user = User(
                email=f"verify_test_{uuid4().hex[:8]}@example.com",
                password_hash="hashed_password",
                full_name="Verify Test User",
                is_active=True,
            )
            session.add(user)
            await session.commit()
            await session.refresh(user)
            print_result("Insert user", True, f"User ID: {user.id}")

            # Count rows
            count = await count_table_rows(session, "users")
            print_result("Count rows", True, f"Users: {count}")

    except Exception as e:
        print_result("Session operations", False, str(e))
        all_passed = False

    # Check 7: Drop tables
    print_header("Check 7: Drop Tables")
    try:
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.drop_all)
        print_result("Drop tables", True)
    except Exception as e:
        print_result("Drop tables", False, str(e))
        all_passed = False

    # Check 8: Dispose engine
    print_header("Check 8: Dispose Engine")
    try:
        await engine.dispose()
        print_result("Dispose engine", True)
    except Exception as e:
        print_result("Dispose engine", False, str(e))
        all_passed = False

    # Check 9: Run actual fixture tests
    print_header("Check 9: Run Database Fixture Tests")
    result = subprocess.run(
        [
            sys.executable, "-m", "pytest",
            "tests/unit/test_database_fixtures.py",
            "-v", "--tb=short", "-q"
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode == 0:
        lines = result.stdout.split("\n")
        for line in lines:
            if "passed" in line:
                print_result("Run fixture tests", True, line.strip())
                break
    else:
        print_result("Run fixture tests", False)
        print("Output:")
        print(result.stdout)
        print(result.stderr)
        all_passed = False

    # Summary
    print_header("VERIFICATION SUMMARY")
    if all_passed:
        print()
        print("  ALL CHECKS PASSED!")
        print()
        print("  Database fixtures are properly configured:")
        print("  - PostgreSQL connection works")
        print("  - Test database (test_learn_greek) accessible")
        print("  - Required extensions installed (uuid-ossp)")
        print("  - Table creation/teardown works")
        print("  - Session management works")
        print("  - All fixture tests pass")
        print()
        return 0
    else:
        print()
        print("  SOME CHECKS FAILED!")
        print()
        print("  Common fixes:")
        print("  1. Start PostgreSQL: docker-compose up -d postgres")
        print('  2. Create test database: docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"')
        print('  3. Create extension: docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \\"uuid-ossp\\";"')
        print()
        return 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
```

---

## Testing Instructions

### Prerequisites: Ensure Test Database Exists

**Before running any tests**, ensure the test database is set up:

```bash
# 1. Start PostgreSQL container
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose up -d postgres

# 2. Wait for PostgreSQL to be ready (check health)
docker exec -it learn-greek-postgres pg_isready -U postgres

# 3. Create test database (if not exists)
docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"

# 4. Create required extension
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
```

### Test Suite 1: Run Verification Script

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python scripts/verify_database_fixtures.py
```

**Expected Output**: All checks pass

### Test Suite 2: Run Database Fixture Tests

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_database_fixtures.py -v
```

**Expected Output**: All tests pass (~25+ tests)

### Test Suite 3: Run All Existing Tests

Verify existing tests still pass with the updated fixtures:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/ -v --tb=short
```

**Expected Output**: All existing tests pass

### Test Suite 4: Run Repository Tests (Uses Database Fixtures)

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/repositories/ -v
```

**Expected Output**: All repository tests pass

### Test Suite 5: Test Isolation Verification

Run the isolation tests twice to verify no data leaks:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_database_fixtures.py::TestSessionIsolation -v && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_database_fixtures.py::TestSessionIsolation -v
```

**Expected Output**: Tests pass both times with no isolation failures

---

## Validation Checklist

Use this checklist to verify the implementation is complete:

### File Creation Checks
- [ ] `tests/helpers/__init__.py` created
- [ ] `tests/helpers/database.py` created (PostgreSQL utilities)
- [ ] `tests/fixtures/database.py` created (PostgreSQL fixtures)
- [ ] `tests/fixtures/__init__.py` updated
- [ ] `tests/conftest.py` updated
- [ ] `tests/unit/test_database_fixtures.py` created
- [ ] `scripts/verify_database_fixtures.py` created

### Database Setup Checks
- [ ] Test database `test_learn_greek` exists
- [ ] Extension `uuid-ossp` installed in test database
- [ ] PostgreSQL container is running

### Configuration Checks
- [ ] `TEST_DATABASE_URL` environment variable supported
- [ ] Default URL points to `test_learn_greek`
- [ ] NullPool used for test isolation
- [ ] Connection URL uses port 5433 (mapped port)

### Fixture Functionality Checks
- [ ] `db_engine` creates tables on setup
- [ ] `db_engine` drops tables on teardown
- [ ] `db_session` provides working session
- [ ] `db_session` rolls back after each test
- [ ] `client` fixture works with dependency override
- [ ] PostgreSQL health check works before tests

### PostgreSQL Feature Checks
- [ ] Native enums work (DeckLevel, CardDifficulty)
- [ ] `uuid_generate_v4()` works for primary keys
- [ ] CASCADE deletes work correctly

### Test Isolation Checks
- [ ] Tests don't share data between runs
- [ ] Isolation tests pass consecutively
- [ ] No foreign key constraint errors

### Code Quality Checks
- [ ] All imports resolve correctly
- [ ] Type hints are complete
- [ ] Docstrings follow Google style
- [ ] No syntax errors

---

## Troubleshooting Guide

### Issue 1: "database 'test_learn_greek' does not exist"

**Cause**: Test database hasn't been created.

**Solution**:
```bash
docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"
```

### Issue 2: "function uuid_generate_v4() does not exist"

**Cause**: uuid-ossp extension not installed in test database.

**Solution**:
```bash
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
```

### Issue 3: "Connection refused" or "could not connect to server"

**Cause**: PostgreSQL container not running.

**Solution**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose up -d postgres
# Wait a few seconds, then verify
docker exec -it learn-greek-postgres pg_isready -U postgres
```

### Issue 4: Tests interfering with each other (data pollution)

**Cause**: Session rollback not working correctly.

**Solution**:
1. Verify the `db_session` fixture properly rolls back in the finally block
2. Use unique identifiers (UUIDs) in test data
3. Run isolation tests to verify: `pytest tests/unit/test_database_fixtures.py::TestSessionIsolation -v`

### Issue 5: "enum type already exists" or "type 'decklevel' already exists"

**Cause**: Tables/enums not properly cleaned up between test runs.

**Solution**: Drop all tables and re-run:
```bash
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
```

### Issue 6: "ImportError: cannot import name 'db_session' from 'tests.fixtures.database'"

**Cause**: Missing exports or circular imports.

**Solution**:
1. Check `tests/fixtures/__init__.py` has all exports
2. Verify `tests/fixtures/database.py` defines the fixture
3. Check for circular imports between fixtures and helpers

### Issue 7: Port connection issues (wrong port)

**Cause**: Using wrong port (5432 vs 5433).

**Solution**: Check docker-compose.yml - the port mapping is `5433:5432`, so use port 5433 from the host:
```
postgresql+asyncpg://postgres:postgres@localhost:5433/test_learn_greek
```

### Issue 8: "asyncpg.exceptions.InvalidCatalogNameError"

**Cause**: Test database doesn't exist.

**Solution**:
```bash
docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"
```

---

## Technical Considerations

### Why PostgreSQL Only (No SQLite)?

| Aspect | PostgreSQL Only | SQLite Alternative |
|--------|-----------------|-------------------|
| **Test Fidelity** | High - same as production | Low - different behavior |
| **Enum Support** | Native PostgreSQL enums | Requires workarounds |
| **UUID Generation** | `uuid_generate_v4()` | Python-side generation |
| **Code Complexity** | Simple - no conditionals | Complex - dual paths |
| **Setup Time** | Requires Docker | Zero setup |
| **CI/CD** | Needs PostgreSQL service | Simpler |

**Decision**: PostgreSQL only, because:
1. Models already use PostgreSQL-specific features
2. Higher test fidelity catches more bugs
3. Simpler codebase with no conditional database logic

### NullPool for Test Isolation

Using `NullPool` ensures:
- Each test gets a fresh database connection
- No connection pooling artifacts between tests
- Clean state for each test
- Connections are properly closed

### Transaction Rollback Pattern

The `db_session` fixture uses rollback pattern:
```
Test starts -> Transaction begins -> Test runs -> Rollback -> Clean state
```

Benefits:
- Fast: No need to recreate tables
- Clean: Each test sees empty database
- Simple: No explicit cleanup needed

### Environment Variable Override

For CI/CD or custom setups:
```bash
TEST_DATABASE_URL="postgresql+asyncpg://user:pass@host:port/testdb" pytest tests/
```

---

## Next Steps

After completing this subtask:

1. **Run verification**:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python scripts/verify_database_fixtures.py
   ```

2. **Run all tests**:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/ -v
   ```

3. **Proceed to Subtask 04.03**: Create Base Test Classes
   - Create `BaseTestCase` with common setup/teardown
   - Create `AuthenticatedTestCase` with user fixtures
   - Create `DatabaseTestCase` with db_session utilities

4. **Update progress tracking**:
   - Mark Subtask 04.02 as COMPLETED
   - Update Backend-Tasks-Progress.md

---

## Quick Reference

### Setup Commands (One-Time)

```bash
# Start PostgreSQL
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose up -d postgres

# Create test database
docker exec -it learn-greek-postgres psql -U postgres -c "CREATE DATABASE test_learn_greek;"

# Create extension
docker exec -it learn-greek-postgres psql -U postgres -d test_learn_greek -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
```

### Test Commands

```bash
# Run database fixture tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_database_fixtures.py -v

# Run verification script
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python scripts/verify_database_fixtures.py

# Run all tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/ -v

# Run only database tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest -m db -v
```

### File Locations

| File | Purpose |
|------|---------|
| `tests/fixtures/database.py` | Core database fixtures (PostgreSQL) |
| `tests/helpers/database.py` | Database utilities |
| `tests/conftest.py` | Global fixture exports |
| `tests/unit/test_database_fixtures.py` | Fixture tests |
| `scripts/verify_database_fixtures.py` | Verification script |

### Fixture Hierarchy

```
tests/
â”œâ”€â”€ conftest.py                    <- Global fixtures (imports from fixtures/)
â”œâ”€â”€ fixtures/
â”‚   â”œâ”€â”€ __init__.py               <- Exports all fixtures
â”‚   â””â”€â”€ database.py               <- db_engine, db_session (PostgreSQL)
â”œâ”€â”€ helpers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ database.py               <- PostgreSQL utility functions
â””â”€â”€ unit/
    â””â”€â”€ test_database_fixtures.py <- Tests for fixtures themselves
```

---

**Document Version**: 2.0
**Created**: 2025-11-30
**Updated**: 2025-11-30
**Author**: Architecture Team
**Status**: Ready for Implementation
**Priority**: Critical Path
**Estimated Duration**: 45-60 minutes
**Database**: PostgreSQL Only (SQLite not supported)
