# Task 04.10: Document Testing Best Practices - Technical Architecture Plan

**Document Version**: 1.1
**Created**: 2025-12-01
**Updated**: 2025-12-01
**Status**: ✅ COMPLETED
**Priority**: Medium (Developer Experience & Knowledge Sharing)
**Dependencies**: 04.01-04.09 (All previous testing subtasks)
**Type**: Documentation-Only Task
**Actual Duration**: ~1 hour

**Completion Summary**:
- Expanded `TESTING.md` from 860 to 2054 lines (+1194 lines, Version 2.0)
- Added 7 new sections (12-18): Unit vs Integration Guide, Mocking Strategies, Test Data Management, Async Testing Patterns, Database Testing Patterns, Anti-Patterns (8 documented), Example Pattern Library (6 complete examples)
- Updated `CLAUDE.md` with Testing Quick Reference section (Version 1.1)
- QA Report: [task-04.10-verification.md](../../qa/task-04.10-verification.md)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Current State Analysis](#2-current-state-analysis)
3. [Documentation Architecture](#3-documentation-architecture)
4. [TESTING.md Expansion](#4-testingmd-expansion)
5. [Anti-Patterns Documentation](#5-anti-patterns-documentation)
6. [Example Pattern Library](#6-example-pattern-library)
7. [CLAUDE.md Updates](#7-claudemd-updates)
8. [Implementation Checklist](#8-implementation-checklist)
9. [Acceptance Criteria](#9-acceptance-criteria)
10. [Related Documents](#10-related-documents)

---

## 1. Overview

### 1.1 Task Description

This is the final subtask of Backend Task 04 (Backend Testing Framework). Task 04.10 focuses on expanding the existing TESTING.md documentation with advanced best practices, anti-patterns, and a comprehensive example pattern library. This is a **documentation-only task** - no code implementation required.

### 1.2 Context

The existing TESTING.md (created in Task 04.09) already covers:
- Quick Start (test commands)
- Test Structure (directory layout)
- Running Tests (basic, by marker, by location, parallel)
- Writing Tests (naming, AAA pattern, markers, async)
- Fixtures (database, auth, content, progress)
- Factories (usage, traits)
- Helpers and Utilities (assertions, time, API, mocks)
- Coverage (commands, targets)
- CI/CD (GitHub Actions)
- Best Practices (general guidelines)
- Troubleshooting (common issues)

### 1.3 Objectives

1. **Expand Best Practices Section**: Add advanced testing patterns specific to the Learn Greek Easy domain
2. **Create Anti-Patterns Documentation**: Document common testing mistakes and how to avoid them
3. **Build Example Pattern Library**: Provide copy-paste ready examples for common testing scenarios
4. **Update CLAUDE.md**: Add testing quick reference for AI assistants

### 1.4 Success Criteria

- [ ] TESTING.md expanded with 4+ new sections (~300 additional lines)
- [ ] Anti-patterns section with 8+ documented anti-patterns
- [ ] Example pattern library with 6+ complete examples
- [ ] CLAUDE.md updated with testing quick reference
- [ ] All documentation follows existing formatting conventions
- [ ] Examples are accurate and match existing codebase patterns

### 1.5 Deliverables

| Deliverable | Location | Type |
|-------------|----------|------|
| Expanded TESTING.md | `learn-greek-easy-backend/TESTING.md` | Update |
| Testing Quick Reference | `CLAUDE.md` | Update |

---

## 2. Current State Analysis

### 2.1 Existing TESTING.md Structure

**Current Sections** (860 lines):
1. Quick Start (~20 lines)
2. Test Structure (~50 lines)
3. Running Tests (~80 lines)
4. Writing Tests (~100 lines)
5. Fixtures (~130 lines)
6. Factories (~80 lines)
7. Helpers and Utilities (~100 lines)
8. Coverage (~70 lines)
9. CI/CD (~50 lines)
10. Best Practices (~80 lines)
11. Troubleshooting (~100 lines)

### 2.2 Current Best Practices Coverage

The existing "Best Practices" section covers:
- General guidelines (8 items)
- Test organization (nested classes pattern)
- Assertion best practices (3 examples)
- Fixture best practices (3 examples)

### 2.3 Gaps to Address

| Gap | Priority | Description |
|-----|----------|-------------|
| Unit vs Integration decision guide | High | When to use which type |
| Mocking strategies | High | When to mock, when not to |
| Test data management | High | Patterns for managing test data |
| Async testing patterns | High | Specific patterns for async code |
| Database testing patterns | Medium | Transaction handling, isolation |
| Anti-patterns | High | Common mistakes and solutions |
| Domain-specific examples | High | SM-2, authentication, deck/card |
| Error handling tests | Medium | Testing exceptions and errors |

### 2.4 Reference Architecture

The testing framework (04.01-04.09) provides:
- **333+ tests** across unit and integration
- **pytest-xdist** for parallel execution
- **Factory Boy** with async support
- **Custom assertions** for domain objects
- **Time utilities** for token/scheduling tests
- **Mock builders** for external dependencies
- **Test data builders** for complex scenarios

---

## 3. Documentation Architecture

### 3.1 New Sections to Add

```markdown
TESTING.md (Updated)
├── [Existing Sections 1-11]
├── 12. Unit vs Integration Testing Guide     # NEW
├── 13. Mocking Strategies                    # NEW
├── 14. Test Data Management                  # NEW
├── 15. Async Testing Patterns                # NEW
├── 16. Database Testing Patterns             # NEW
├── 17. Anti-Patterns (What NOT to Do)        # NEW
├── 18. Example Pattern Library               # NEW
└── Appendix: Quick Reference Card            # NEW
```

### 3.2 Documentation Principles

| Principle | Application |
|-----------|-------------|
| **Practical** | Every pattern has a copy-paste example |
| **Domain-specific** | Examples use Learn Greek Easy models |
| **Balanced** | Show both DO and DON'T |
| **Searchable** | Clear headings for quick navigation |
| **Consistent** | Follow existing document style |

---

## 4. TESTING.md Expansion

### 4.1 Section 12: Unit vs Integration Testing Guide

```markdown
## 12. Unit vs Integration Testing Guide

### When to Write Unit Tests

Unit tests are appropriate when:

| Scenario | Example |
|----------|---------|
| Testing pure logic | SM-2 algorithm calculations |
| Testing validation | Password strength validation |
| Testing transformations | Data formatting functions |
| Testing error conditions | Exception handling |
| Testing business rules | Card difficulty calculation |

**Characteristics of good unit test candidates:**
- Function has clear inputs and outputs
- Logic doesn't depend on database state
- External dependencies can be easily mocked
- Fast execution (< 10ms per test)

### When to Write Integration Tests

Integration tests are appropriate when:

| Scenario | Example |
|----------|---------|
| Testing API endpoints | POST /api/v1/auth/login |
| Testing database operations | User creation with settings |
| Testing authentication flows | Token refresh cycle |
| Testing cross-service logic | Deck progress with reviews |
| Testing cascading operations | Delete deck with cards |

**Characteristics of integration test candidates:**
- Multiple components interact
- Database transactions matter
- Real HTTP request/response cycle needed
- Testing actual SQL queries

### Decision Flowchart

```
Is the code under test:
├── A pure function with no side effects?
│   └── → Unit test
├── A database operation (CRUD)?
│   └── → Integration test (real DB)
├── An API endpoint?
│   └── → Integration test (with TestClient)
├── A service method with complex logic?
│   ├── Logic portion → Unit test (mocked DB)
│   └── DB interaction → Integration test
└── A utility/helper function?
    └── → Unit test
```

### Hybrid Approach Example

For `AuthService.login()`:

```python
# Unit tests (mocked DB) - test business logic
class TestAuthServiceLoginLogic:
    async def test_login_rejects_inactive_user(self, mock_db_session):
        # Test the logic: inactive users can't login
        mock_db_session.execute.return_value.scalar_one_or_none.return_value = inactive_user
        with pytest.raises(AuthenticationError):
            await auth_service.login("email", "password")

# Integration tests (real DB) - test actual flow
class TestAuthServiceLoginIntegration:
    async def test_login_creates_refresh_token_in_database(self, db_session, test_user):
        # Test the integration: token actually stored
        result = await AuthService(db_session).login(test_user.email, "password")
        token = await db_session.execute(select(RefreshToken).where(...))
        assert token is not None
```
```

### 4.2 Section 13: Mocking Strategies

```markdown
## 13. Mocking Strategies

### When to Mock

| Mock | Don't Mock |
|------|------------|
| External APIs (translation, email) | Your own code under test |
| Time-sensitive operations | Database in integration tests |
| Third-party services | Simple value objects |
| Expensive computations in unit tests | Core business logic |
| Random/UUID generation for determinism | Fixtures and factories |

### Mock Hierarchy

```
1. Fixture-level mocks (conftest.py)
   └── Shared across multiple tests in a scope

2. Test-level mocks (individual tests)
   └── Specific to one test scenario

3. Module-level patches (at import)
   └── Replace entire modules (rare)
```

### Mocking the Database in Unit Tests

```python
from tests.helpers.mocks import mock_async_session

class TestUserService:
    async def test_get_user_returns_user(self, mock_db_session):
        # Arrange
        expected_user = User(id=uuid4(), email="test@example.com")

        # Configure mock to return expected user
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = expected_user
        mock_db_session.execute.return_value = mock_result

        # Act
        service = UserService(mock_db_session)
        result = await service.get_user_by_email("test@example.com")

        # Assert
        assert result == expected_user
        mock_db_session.execute.assert_called_once()
```

### Mocking External Services

```python
from tests.helpers.mocks import mock_email_service, mock_redis_client

class TestRegistration:
    async def test_registration_sends_welcome_email(self, db_session, mocker):
        # Arrange
        email_mock = mock_email_service()
        mocker.patch("src.services.auth.email_service", email_mock)

        # Act
        await register_user(db_session, {"email": "new@example.com", ...})

        # Assert
        email_mock.send_welcome_email.assert_called_once_with("new@example.com")
```

### Mocking Time

```python
from tests.helpers.time import freeze_time, create_expired_token

class TestTokenExpiration:
    async def test_expired_token_rejected(self):
        with freeze_time("2025-01-15 12:00:00"):
            # Token created "now"
            token = create_access_token(user_id)

        with freeze_time("2025-01-16 12:00:00"):  # 24 hours later
            # Token should be expired
            with pytest.raises(ExpiredTokenError):
                verify_access_token(token)
```

### Partial Mocking

```python
async def test_service_with_partial_mock(self, db_session, mocker):
    """Mock only external call, use real DB."""
    # Only mock the external API call
    mocker.patch(
        "src.services.deck_service.fetch_word_definition",
        return_value={"definition": "hello"}
    )

    # Real database operations
    service = DeckService(db_session)
    result = await service.create_card_with_definition(deck_id, "word")

    # Verify DB state
    assert result.id is not None
    card = await db_session.get(Card, result.id)
    assert card is not None
```
```

### 4.3 Section 14: Test Data Management

```markdown
## 14. Test Data Management

### Data Creation Hierarchy

Use the simplest approach that works:

```
1. Inline data (simplest)
   user_data = {"email": "test@example.com"}

2. Fixtures (shared across tests)
   @pytest.fixture
   def test_user(db_session): ...

3. Factories (customizable)
   user = await UserFactory.create_async(db_session, admin=True)

4. Builders (complex scenarios)
   result = await ReviewSessionBuilder(db_session).for_user(user).build()
```

### When to Use Each Approach

| Approach | Use When |
|----------|----------|
| Inline | Single-use data, test is self-contained |
| Fixtures | Standard scenarios, shared setup |
| Factories | Need variations, traits, multiple instances |
| Builders | Complex multi-entity scenarios |

### Test Data Isolation

```python
# GOOD: Each test creates its own data
async def test_user_creation(self, db_session):
    user = await UserFactory.create_async(db_session)
    # Test with this user

async def test_another_feature(self, db_session):
    user = await UserFactory.create_async(db_session)  # Fresh user
    # Test with fresh user

# BAD: Shared mutable state
class TestFeature:
    user = None  # DON'T DO THIS

    async def test_one(self, db_session):
        self.user = await UserFactory.create_async(db_session)

    async def test_two(self, db_session):
        # Depends on test_one running first - FRAGILE
        assert self.user is not None
```

### Managing Related Entities

```python
# Create a deck with cards using fixtures
@pytest.fixture
async def deck_with_cards(db_session, test_user):
    deck = await DeckFactory.create_async(db_session, created_by_id=test_user.id)
    cards = await CardFactory.create_batch_async(db_session, 5, deck=deck)
    return DeckWithCards(deck=deck, cards=cards)

# Or use the builder for complex scenarios
async def test_review_session(self, db_session, test_user):
    result = await (
        ReviewSessionBuilder(db_session)
        .for_user(test_user)
        .with_cards(cards)
        .with_ratings([5, 4, 3, 4, 5])
        .build()
    )
    assert len(result.reviews) == 5
```

### Cleanup Considerations

The test framework handles cleanup automatically via rollback:

```python
@pytest_asyncio.fixture
async def db_session(session_db_engine):
    """Session rolls back after each test - automatic cleanup."""
    async with session_factory() as session:
        try:
            yield session
        finally:
            await session.rollback()  # All changes undone
```
```

### 4.4 Section 15: Async Testing Patterns

```markdown
## 15. Async Testing Patterns

### Basic Async Test

```python
# No decorator needed with asyncio_mode = "auto"
async def test_async_operation(self, db_session):
    result = await some_async_function(db_session)
    assert result is not None
```

### Testing Async Generators

```python
async def test_streaming_response(self, db_session):
    results = []
    async for item in get_cards_stream(db_session, deck_id):
        results.append(item)

    assert len(results) == expected_count
```

### Testing Concurrent Operations

```python
import asyncio

async def test_concurrent_reviews(self, db_session, test_user, cards):
    """Test that concurrent review submissions don't conflict."""
    # Create review tasks
    tasks = [
        submit_review(db_session, test_user.id, card.id, quality=4)
        for card in cards[:5]
    ]

    # Execute concurrently
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # Verify all succeeded
    assert all(not isinstance(r, Exception) for r in results)
```

### Testing Async Context Managers

```python
async def test_transaction_context(self, db_session):
    async with db_session.begin_nested():
        user = await UserFactory.create_async(db_session)
        assert user.id is not None
    # Savepoint committed

    # Verify user persisted
    result = await db_session.get(User, user.id)
    assert result is not None
```

### Testing Async Timeouts

```python
import asyncio

async def test_operation_completes_quickly(self, db_session):
    """Ensure operation doesn't hang."""
    async def timed_operation():
        return await slow_operation(db_session)

    # Should complete within 1 second
    result = await asyncio.wait_for(timed_operation(), timeout=1.0)
    assert result is not None
```

### Common Async Pitfalls

```python
# WRONG: Forgetting to await
async def test_bad_example(self, db_session):
    result = some_async_function(db_session)  # Missing await!
    assert result  # This asserts on coroutine object, not result

# CORRECT:
async def test_good_example(self, db_session):
    result = await some_async_function(db_session)
    assert result
```
```

### 4.5 Section 16: Database Testing Patterns

```markdown
## 16. Database Testing Patterns

### Transaction Isolation

Tests run in isolated transactions that rollback:

```python
async def test_user_creation_isolated(self, db_session):
    """Changes don't persist after test."""
    user = await UserFactory.create_async(db_session)
    await db_session.commit()  # Committed within test transaction

    # After test ends, rollback undoes this

async def test_next_test_clean_slate(self, db_session):
    """Previous test's data is not visible."""
    users = await db_session.execute(select(User))
    assert users.scalars().all() == []  # Clean slate
```

### Testing Unique Constraints

```python
async def test_duplicate_email_rejected(self, db_session):
    # Create first user
    await UserFactory.create_async(db_session, email="test@example.com")

    # Attempt duplicate
    with pytest.raises(IntegrityError):
        await UserFactory.create_async(db_session, email="test@example.com")
        await db_session.commit()
```

### Testing Cascading Deletes

```python
async def test_deck_deletion_removes_cards(self, db_session, deck_with_cards):
    deck = deck_with_cards.deck
    card_ids = [c.id for c in deck_with_cards.cards]

    # Delete deck
    await db_session.delete(deck)
    await db_session.commit()

    # Verify cards deleted (if CASCADE configured)
    for card_id in card_ids:
        card = await db_session.get(Card, card_id)
        assert card is None
```

### Testing Database Constraints

```python
async def test_foreign_key_constraint(self, db_session):
    """Card requires valid deck_id."""
    with pytest.raises(IntegrityError):
        card = Card(
            deck_id=uuid4(),  # Non-existent deck
            front_text="Hello",
            back_text="World"
        )
        db_session.add(card)
        await db_session.commit()
```

### Testing Enum Values

```python
async def test_card_difficulty_enum(self, db_session, test_deck):
    """Test PostgreSQL enum column."""
    # Valid enum value
    card = await CardFactory.create_async(
        db_session,
        deck=test_deck,
        difficulty=CardDifficulty.HARD
    )
    assert card.difficulty == CardDifficulty.HARD

    # Reload from DB
    await db_session.refresh(card)
    assert card.difficulty == CardDifficulty.HARD
```

### Testing Query Performance (Slow Tests)

```python
@pytest.mark.slow
async def test_large_dataset_query(self, db_session):
    """Test query performance with many records."""
    # Create 1000 cards
    deck = await DeckFactory.create_async(db_session)
    await CardFactory.create_batch_async(db_session, 1000, deck=deck)

    # Time the query
    import time
    start = time.time()
    result = await db_session.execute(
        select(Card).where(Card.deck_id == deck.id)
    )
    cards = result.scalars().all()
    elapsed = time.time() - start

    assert len(cards) == 1000
    assert elapsed < 1.0  # Should complete in under 1 second
```
```

---

## 5. Anti-Patterns Documentation

### 5.1 Section 17: Anti-Patterns (What NOT to Do)

```markdown
## 17. Anti-Patterns (What NOT to Do)

### Anti-Pattern 1: Test Interdependency

```python
# BAD: Tests depend on execution order
class TestUserWorkflow:
    created_user_id = None

    async def test_1_create_user(self, db_session):
        user = await create_user(db_session, ...)
        self.__class__.created_user_id = user.id

    async def test_2_update_user(self, db_session):
        # FAILS if test_1 doesn't run first
        await update_user(db_session, self.created_user_id, ...)

# GOOD: Independent tests with fixtures
class TestUserWorkflow:
    async def test_create_user(self, db_session):
        user = await create_user(db_session, ...)
        assert user.id is not None

    async def test_update_user(self, db_session, test_user):
        # Uses fixture, doesn't depend on other tests
        await update_user(db_session, test_user.id, ...)
```

### Anti-Pattern 2: Over-Mocking

```python
# BAD: Mocking the system under test
async def test_auth_service_overmocked(self, mocker):
    mocker.patch("src.services.auth.AuthService.login")  # Mocking what we're testing!
    result = await AuthService().login("email", "password")
    # This tests nothing useful

# GOOD: Mock dependencies, not the subject
async def test_auth_service(self, db_session, mocker):
    mocker.patch("src.services.auth.send_login_notification")  # External side effect
    service = AuthService(db_session)  # Real service
    result = await service.login("email", "password")  # Real login logic
```

### Anti-Pattern 3: Brittle Assertions

```python
# BAD: Testing implementation details
async def test_brittle(self, db_session):
    result = await get_user_stats(db_session, user_id)
    # Fails if internal structure changes
    assert result["_internal_cache_key"] == "user_123_stats"
    assert result["_query_count"] == 3

# GOOD: Test behavior/output
async def test_robust(self, db_session):
    result = await get_user_stats(db_session, user_id)
    assert result["cards_studied"] >= 0
    assert result["streak_days"] >= 0
```

### Anti-Pattern 4: Flaky Time-Based Tests

```python
# BAD: Depends on execution timing
async def test_flaky_timing(self):
    start = datetime.utcnow()
    await some_operation()
    end = datetime.utcnow()
    assert (end - start).total_seconds() < 0.1  # Might fail randomly

# GOOD: Use frozen time or relaxed assertions
async def test_stable_timing(self):
    with freeze_time("2025-01-15 12:00:00"):
        result = create_token_with_expiry()
        assert result.expires_at == datetime(2025, 1, 15, 13, 0, 0)  # Deterministic
```

### Anti-Pattern 5: Missing Error Case Tests

```python
# BAD: Only testing happy path
class TestLogin:
    async def test_login_success(self, db_session, test_user):
        result = await login(test_user.email, "password")
        assert result.access_token

# GOOD: Test error cases too
class TestLogin:
    async def test_login_success(self, db_session, test_user):
        result = await login(test_user.email, "password")
        assert result.access_token

    async def test_login_wrong_password(self, db_session, test_user):
        with pytest.raises(AuthenticationError):
            await login(test_user.email, "wrong_password")

    async def test_login_nonexistent_user(self, db_session):
        with pytest.raises(UserNotFoundError):
            await login("nobody@example.com", "password")

    async def test_login_inactive_user(self, db_session, test_inactive_user):
        with pytest.raises(AccountDisabledError):
            await login(test_inactive_user.email, "password")
```

### Anti-Pattern 6: Hardcoded Test Data

```python
# BAD: Hardcoded UUIDs and values
async def test_hardcoded(self, db_session):
    user_id = "550e8400-e29b-41d4-a716-446655440000"  # Will conflict
    user = User(id=user_id, email="test@test.com")
    db_session.add(user)

# GOOD: Let factories/database generate IDs
async def test_generated_ids(self, db_session):
    user = await UserFactory.create_async(db_session)  # UUID generated
    assert user.id is not None  # Don't care what it is
```

### Anti-Pattern 7: Testing Framework Code

```python
# BAD: Testing pytest/SQLAlchemy internals
async def test_sqlalchemy_works(self, db_session):
    assert hasattr(db_session, 'execute')
    assert db_session.is_active

# GOOD: Test your application code
async def test_user_repository(self, db_session):
    repo = UserRepository(db_session)
    user = await repo.create(email="test@example.com", ...)
    assert user.email == "test@example.com"
```

### Anti-Pattern 8: Giant Test Methods

```python
# BAD: One test doing too much
async def test_everything(self, db_session, client):
    # Create user
    user = await create_user(db_session, ...)
    assert user.id
    # Create deck
    deck = await create_deck(db_session, user.id, ...)
    assert deck.id
    # Add cards
    for i in range(10):
        card = await create_card(db_session, deck.id, ...)
        assert card.id
    # Test API endpoint
    response = await client.get(f"/decks/{deck.id}")
    assert response.status_code == 200
    # Test another endpoint
    response = await client.get(f"/decks/{deck.id}/cards")
    assert len(response.json()) == 10
    # ...50 more assertions...

# GOOD: Focused tests with fixtures
async def test_deck_creation(self, db_session, test_user):
    deck = await create_deck(db_session, test_user.id, name="Test")
    assert deck.name == "Test"

async def test_get_deck_endpoint(self, client, auth_headers, test_deck):
    response = await client.get(f"/decks/{test_deck.id}", headers=auth_headers)
    assert response.status_code == 200
```

### Anti-Pattern Summary Table

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| Test interdependency | Fragile, order-dependent | Use fixtures, independent tests |
| Over-mocking | Tests nothing real | Mock dependencies, not subject |
| Brittle assertions | Break on refactoring | Test behavior, not implementation |
| Flaky timing | Random failures | Freeze time, relax constraints |
| Missing error cases | Incomplete coverage | Test all code paths |
| Hardcoded data | ID conflicts, fragility | Use factories, generated values |
| Testing framework | Wasted effort | Focus on application code |
| Giant tests | Hard to maintain, debug | Split into focused tests |
```

---

## 6. Example Pattern Library

### 6.1 Section 18: Example Pattern Library

```markdown
## 18. Example Pattern Library

Copy-paste ready examples for common testing scenarios in Learn Greek Easy.

### Example 1: Testing API Endpoints with Authentication

```python
"""Testing protected API endpoints."""

import pytest
from httpx import AsyncClient

class TestDeckAPI:
    """API tests for deck endpoints."""

    @pytest.mark.integration
    async def test_create_deck_authenticated(
        self,
        client: AsyncClient,
        auth_headers: dict,
    ):
        """Authenticated user can create a deck."""
        response = await client.post(
            "/api/v1/decks",
            headers=auth_headers,
            json={
                "name": "Greek Basics",
                "description": "Basic Greek vocabulary",
                "level": "A1",
            },
        )

        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "Greek Basics"
        assert data["level"] == "A1"
        assert "id" in data

    @pytest.mark.integration
    async def test_create_deck_unauthenticated(
        self,
        client: AsyncClient,
    ):
        """Unauthenticated request returns 401."""
        response = await client.post(
            "/api/v1/decks",
            json={"name": "Test", "level": "A1"},
        )

        assert response.status_code == 401
        assert "detail" in response.json()

    @pytest.mark.integration
    async def test_get_own_decks(
        self,
        client: AsyncClient,
        auth_headers: dict,
        test_user,
        db_session,
    ):
        """User sees only their own decks."""
        # Create deck for test_user
        my_deck = await DeckFactory.create_async(
            db_session,
            created_by_id=test_user.id,
        )

        # Create deck for another user
        other_user = await UserFactory.create_async(db_session)
        other_deck = await DeckFactory.create_async(
            db_session,
            created_by_id=other_user.id,
        )

        response = await client.get(
            "/api/v1/decks",
            headers=auth_headers,
        )

        assert response.status_code == 200
        deck_ids = [d["id"] for d in response.json()["items"]]
        assert str(my_deck.id) in deck_ids
        assert str(other_deck.id) not in deck_ids
```

### Example 2: Testing SM-2 Algorithm Calculations

```python
"""Testing the SM-2 spaced repetition algorithm."""

import pytest
from datetime import date, timedelta
from tests.helpers.assertions import assert_sm2_calculation

class TestSM2Algorithm:
    """Tests for SM-2 algorithm implementation."""

    @pytest.mark.unit
    def test_first_successful_review(self):
        """First successful review (quality >= 3) sets interval to 1."""
        result = calculate_sm2(
            quality=4,
            repetitions=0,
            easiness_factor=2.5,
            interval=0,
        )

        assert result.interval == 1
        assert result.repetitions == 1
        assert result.easiness_factor >= 2.5

    @pytest.mark.unit
    def test_second_successful_review(self):
        """Second successful review sets interval to 6."""
        result = calculate_sm2(
            quality=4,
            repetitions=1,
            easiness_factor=2.5,
            interval=1,
        )

        assert result.interval == 6
        assert result.repetitions == 2

    @pytest.mark.unit
    def test_failed_review_resets_progress(self):
        """Quality < 3 resets repetitions and interval."""
        result = calculate_sm2(
            quality=2,  # Failed
            repetitions=5,
            easiness_factor=2.5,
            interval=30,
        )

        assert result.interval == 1
        assert result.repetitions == 0

    @pytest.mark.unit
    @pytest.mark.parametrize("quality,expected_ef_change", [
        (5, 0.10),   # Perfect: EF increases
        (4, 0.00),   # Good: EF unchanged
        (3, -0.14),  # Hard: EF decreases
        (2, -0.32),  # Failed: EF decreases more
    ])
    def test_easiness_factor_adjustment(self, quality, expected_ef_change):
        """EF adjusts based on quality rating."""
        initial_ef = 2.5
        result = calculate_sm2(
            quality=quality,
            repetitions=3,
            easiness_factor=initial_ef,
            interval=10,
        )

        # EF should change by approximately the expected amount
        actual_change = result.easiness_factor - initial_ef
        assert abs(actual_change - expected_ef_change) < 0.01

    @pytest.mark.unit
    def test_easiness_factor_minimum(self):
        """EF never drops below 1.3."""
        result = calculate_sm2(
            quality=0,  # Complete blackout
            repetitions=1,
            easiness_factor=1.3,  # Already at minimum
            interval=1,
        )

        assert result.easiness_factor >= 1.3

    @pytest.mark.integration
    async def test_sm2_integration_with_review(
        self,
        db_session,
        test_user,
        test_card,
    ):
        """Full integration: review updates card statistics."""
        # Initial state
        stats = await CardStatisticsFactory.create_async(
            db_session,
            user_id=test_user.id,
            card_id=test_card.id,
            interval=0,
            repetitions=0,
            easiness_factor=2.5,
        )

        # Submit review
        review_service = ReviewService(db_session)
        result = await review_service.submit_review(
            user_id=test_user.id,
            card_id=test_card.id,
            quality=4,
        )

        # Verify statistics updated
        await db_session.refresh(stats)
        assert stats.repetitions == 1
        assert stats.interval == 1
        assert stats.next_review_date == date.today() + timedelta(days=1)
```

### Example 3: Testing Database Transactions

```python
"""Testing database transaction behavior."""

import pytest
from sqlalchemy.exc import IntegrityError

class TestDatabaseTransactions:
    """Tests for transactional behavior."""

    @pytest.mark.integration
    async def test_successful_transaction(self, db_session):
        """Successful operations commit together."""
        # Create related entities
        user = await UserFactory.create_async(db_session)
        deck = await DeckFactory.create_async(db_session, created_by_id=user.id)
        card = await CardFactory.create_async(db_session, deck=deck)

        await db_session.commit()

        # All entities persisted
        assert await db_session.get(User, user.id) is not None
        assert await db_session.get(Deck, deck.id) is not None
        assert await db_session.get(Card, card.id) is not None

    @pytest.mark.integration
    async def test_failed_transaction_rollback(self, db_session):
        """Failed operation rolls back entire transaction."""
        user = await UserFactory.create_async(db_session)

        try:
            # This will fail (duplicate email)
            await UserFactory.create_async(db_session, email=user.email)
            await db_session.commit()
        except IntegrityError:
            await db_session.rollback()

        # Original user still exists after rollback
        result = await db_session.execute(
            select(User).where(User.id == user.id)
        )
        assert result.scalar_one_or_none() is not None

    @pytest.mark.integration
    async def test_savepoint_nested_transaction(self, db_session):
        """Savepoints allow partial rollback."""
        user = await UserFactory.create_async(db_session)

        async with db_session.begin_nested():  # Savepoint
            deck1 = await DeckFactory.create_async(db_session, created_by_id=user.id)
            # Savepoint commits

        try:
            async with db_session.begin_nested():  # Another savepoint
                deck2 = await DeckFactory.create_async(db_session, created_by_id=user.id)
                raise ValueError("Simulated error")
        except ValueError:
            pass  # Savepoint rolled back

        await db_session.commit()

        # deck1 persisted, deck2 rolled back
        assert await db_session.get(Deck, deck1.id) is not None
        # deck2 was never committed due to rollback
```

### Example 4: Testing Error Handling and Exceptions

```python
"""Testing error handling in services."""

import pytest
from src.exceptions import (
    AuthenticationError,
    CardNotFoundError,
    DeckNotFoundError,
    PermissionDeniedError,
)

class TestAuthenticationErrors:
    """Tests for authentication error handling."""

    @pytest.mark.unit
    async def test_invalid_credentials_raises_error(
        self,
        db_session,
        test_user,
    ):
        """Wrong password raises AuthenticationError."""
        service = AuthService(db_session)

        with pytest.raises(AuthenticationError) as exc_info:
            await service.authenticate(
                email=test_user.email,
                password="wrong_password",
            )

        assert "Invalid credentials" in str(exc_info.value)

    @pytest.mark.unit
    async def test_expired_token_error(self):
        """Expired token raises specific error."""
        from tests.helpers.time import create_expired_token

        token = create_expired_token(uuid4(), hours_ago=2)

        with pytest.raises(ExpiredTokenError):
            verify_access_token(token)

    @pytest.mark.integration
    async def test_not_found_error(
        self,
        client: AsyncClient,
        auth_headers: dict,
    ):
        """Non-existent resource returns 404."""
        fake_id = str(uuid4())
        response = await client.get(
            f"/api/v1/decks/{fake_id}",
            headers=auth_headers,
        )

        assert response.status_code == 404
        assert "not found" in response.json()["detail"].lower()

    @pytest.mark.integration
    async def test_permission_denied(
        self,
        client: AsyncClient,
        auth_headers: dict,
        db_session,
    ):
        """Cannot access another user's private resource."""
        # Create another user's deck
        other_user = await UserFactory.create_async(db_session)
        other_deck = await DeckFactory.create_async(
            db_session,
            created_by_id=other_user.id,
            is_public=False,
        )

        response = await client.get(
            f"/api/v1/decks/{other_deck.id}",
            headers=auth_headers,  # Different user
        )

        assert response.status_code == 403
```

### Example 5: Testing Background Tasks / Async Operations

```python
"""Testing asynchronous and background operations."""

import pytest
import asyncio
from unittest.mock import AsyncMock

class TestAsyncOperations:
    """Tests for async background operations."""

    @pytest.mark.unit
    async def test_concurrent_access(self, db_session, test_deck):
        """Multiple concurrent reads don't conflict."""
        async def read_deck():
            return await db_session.get(Deck, test_deck.id)

        # 10 concurrent reads
        results = await asyncio.gather(*[read_deck() for _ in range(10)])

        assert all(d.id == test_deck.id for d in results)

    @pytest.mark.unit
    async def test_background_task_triggered(self, mocker, db_session, test_user):
        """Background task is queued after action."""
        # Mock the task queue
        mock_enqueue = mocker.patch(
            "src.tasks.send_notification.delay",
            return_value=AsyncMock(),
        )

        # Action that triggers background task
        await complete_user_registration(db_session, test_user)

        # Verify task was queued
        mock_enqueue.assert_called_once_with(
            user_id=str(test_user.id),
            notification_type="welcome",
        )

    @pytest.mark.slow
    async def test_long_running_operation_completes(self, db_session):
        """Long operation completes within timeout."""
        async def long_operation():
            # Simulate processing 100 cards
            for _ in range(100):
                await asyncio.sleep(0.01)
            return "completed"

        result = await asyncio.wait_for(
            long_operation(),
            timeout=5.0,
        )

        assert result == "completed"

    @pytest.mark.unit
    async def test_retry_on_failure(self, mocker):
        """Operation retries on transient failure."""
        # Mock function that fails twice, then succeeds
        call_count = 0

        async def flaky_function():
            nonlocal call_count
            call_count += 1
            if call_count < 3:
                raise ConnectionError("Transient failure")
            return "success"

        result = await retry_async(flaky_function, max_retries=3)

        assert result == "success"
        assert call_count == 3
```

### Example 6: Testing with Complex Fixtures (Builders)

```python
"""Testing complex scenarios with data builders."""

import pytest
from tests.utils import (
    ReviewSessionBuilder,
    ProgressScenarioBuilder,
    StudyStreakBuilder,
)

class TestComplexScenarios:
    """Tests using data builders for complex scenarios."""

    @pytest.mark.integration
    async def test_review_session_updates_progress(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        """Complete review session updates all statistics."""
        # Build a review session
        session_result = await (
            ReviewSessionBuilder(db_session)
            .for_user(test_user)
            .for_deck(deck_with_cards.deck)
            .with_cards(deck_with_cards.cards[:5])
            .with_ratings([5, 4, 4, 3, 5])  # Average: 4.2
            .build()
        )

        # Verify session data
        assert len(session_result.reviews) == 5
        assert session_result.average_quality == 4.2

        # Verify statistics created
        for stats in session_result.statistics:
            assert stats.repetitions == 1
            assert stats.next_review_date is not None

    @pytest.mark.integration
    async def test_user_progress_scenario(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        """Build and verify user progress state."""
        result = await (
            ProgressScenarioBuilder(db_session)
            .for_user(test_user)
            .with_deck(
                deck_with_cards.deck,
                cards=deck_with_cards.cards,
                studied=10,
                mastered=5,
            )
            .as_intermediate()
            .build()
        )

        assert result.total_cards_studied >= 10
        assert result.total_cards_mastered >= 5

        # Verify in database
        progress = result.progress_records[0]
        assert progress.cards_studied == 10
        assert progress.cards_mastered == 5

    @pytest.mark.integration
    async def test_study_streak_calculation(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        """Verify streak calculation from review history."""
        result = await (
            StudyStreakBuilder(db_session)
            .for_user(test_user)
            .with_cards(deck_with_cards.cards)
            .with_streak(days=7)
            .ending_today()
            .with_cards_per_day(10)
            .build()
        )

        assert result.streak_days == 7
        assert len(result.study_dates) == 7

        # Verify streak calculation service
        streak_service = StreakService(db_session)
        calculated_streak = await streak_service.get_current_streak(test_user.id)
        assert calculated_streak == 7
```
```

---

## 7. CLAUDE.md Updates

### 7.1 Testing Quick Reference Section

Add the following section to `CLAUDE.md`:

```markdown
---

## Testing Quick Reference

### Running Tests

```bash
# Run all tests (parallel)
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest -n auto

# Run with coverage
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest --cov=src --cov-report=term-missing

# Run unit tests only
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest -m unit

# Run integration tests only
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest -m integration

# Run single test file
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/unit/core/test_security.py -v

# Run with verbose output (debugging)
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest -vv --tb=long -x
```

### Test Structure

```
tests/
├── unit/           # Fast, isolated tests (mocked DB)
├── integration/    # Tests with real database
├── fixtures/       # Pytest fixtures by domain
├── factories/      # Factory Boy factories
├── helpers/        # Test utilities (assertions, mocks)
└── utils/          # Data builders for complex scenarios
```

### Creating Test Data

```python
# Fixtures (in test functions)
async def test_example(self, db_session, test_user, auth_headers):
    # test_user and auth_headers are pre-created

# Factories (customizable)
user = await UserFactory.create_async(db_session, admin=True)
deck = await DeckFactory.create_async(db_session, a1=True)
cards = await CardFactory.create_batch_async(db_session, 10, deck=deck)

# Builders (complex scenarios)
result = await ReviewSessionBuilder(db_session).for_user(user).with_cards(cards).build()
```

### Key Test Files

| File | Purpose |
|------|---------|
| `tests/conftest.py` | Global fixtures |
| `tests/fixtures/database.py` | Database session fixtures |
| `tests/fixtures/auth.py` | User and token fixtures |
| `tests/factories/` | Factory classes for test data |
| `tests/helpers/assertions.py` | Custom assertions |
| `TESTING.md` | Full testing documentation |

### Coverage Target

- Overall: >= 90%
- Core modules: >= 95%

---
```

---

## 8. Implementation Checklist

### 8.1 Documentation Tasks

- [ ] **Section 12**: Add Unit vs Integration Testing Guide to TESTING.md
- [ ] **Section 13**: Add Mocking Strategies to TESTING.md
- [ ] **Section 14**: Add Test Data Management to TESTING.md
- [ ] **Section 15**: Add Async Testing Patterns to TESTING.md
- [ ] **Section 16**: Add Database Testing Patterns to TESTING.md
- [ ] **Section 17**: Add Anti-Patterns section to TESTING.md
- [ ] **Section 18**: Add Example Pattern Library to TESTING.md
- [ ] **Appendix**: Add Quick Reference Card to TESTING.md
- [ ] **CLAUDE.md**: Add Testing Quick Reference section

### 8.2 Quality Checks

- [ ] All code examples compile/parse correctly
- [ ] Examples match existing codebase patterns
- [ ] Formatting consistent with existing documentation
- [ ] Table of Contents updated
- [ ] All section links work

### 8.3 Verification Steps

```bash
# 1. Verify TESTING.md is readable
cat /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/TESTING.md | head -100

# 2. Verify markdown formatting
# (Manual review in markdown viewer)

# 3. Verify examples use correct imports
grep -E "^from|^import" /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/TESTING.md

# 4. Count total lines (target: ~1150 lines)
wc -l /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/TESTING.md
```

---

## 9. Acceptance Criteria

### 9.1 Documentation Requirements

| Requirement | Target | Notes |
|-------------|--------|-------|
| New sections added | 7 | Sections 12-18 + Appendix |
| Anti-patterns documented | 8+ | With DO/DON'T examples |
| Example patterns | 6+ | Copy-paste ready |
| TESTING.md total length | ~1150 lines | +~300 lines from current |
| CLAUDE.md updated | Yes | Testing quick reference |

### 9.2 Quality Requirements

| Requirement | Status |
|-------------|--------|
| All examples use project patterns | Pending |
| Consistent markdown formatting | Pending |
| Working Table of Contents links | Pending |
| No broken code examples | Pending |
| Examples match existing fixtures/factories | Pending |

### 9.3 Content Completeness

| Topic | Covered |
|-------|---------|
| Unit vs Integration decision | Pending |
| When to mock | Pending |
| Test data management | Pending |
| Async testing patterns | Pending |
| Database testing patterns | Pending |
| Flaky test prevention | Pending |
| Error case testing | Pending |
| SM-2 algorithm testing | Pending |
| API authentication testing | Pending |

---

## 10. Related Documents

| Document | Location | Description |
|----------|----------|-------------|
| Main Testing Framework Plan | [04-backend-testing-framework-plan.md](./04-backend-testing-framework-plan.md) | Parent task |
| Parallel Execution Plan | [04.07-parallel-test-execution-plan.md](./04.07-parallel-test-execution-plan.md) | pytest-xdist setup |
| Test Utilities Plan | [04.08-test-utilities-helpers-plan.md](./04.08-test-utilities-helpers-plan.md) | Helpers and mocks |
| Testing Conventions Plan | [04.09-testing-conventions-patterns-plan.md](./04.09-testing-conventions-patterns-plan.md) | Structure and fixtures |
| Current TESTING.md | `learn-greek-easy-backend/TESTING.md` | File to update |
| CLAUDE.md | `CLAUDE.md` | Project conventions |
| Backend Tasks Progress | [../Backend-Tasks-Progress.md](../Backend-Tasks-Progress.md) | Task tracking |

---

## Quick Reference

### Files to Update

| File | Changes |
|------|---------|
| `learn-greek-easy-backend/TESTING.md` | Add 7 new sections (~300 lines) |
| `CLAUDE.md` | Add Testing Quick Reference section |

### Content Summary

| New Section | Lines (Est.) |
|-------------|--------------|
| 12. Unit vs Integration Guide | ~60 |
| 13. Mocking Strategies | ~80 |
| 14. Test Data Management | ~50 |
| 15. Async Testing Patterns | ~50 |
| 16. Database Testing Patterns | ~60 |
| 17. Anti-Patterns | ~100 |
| 18. Example Pattern Library | ~200 |
| Appendix: Quick Reference | ~30 |
| **Total** | **~630** |

### Execution Order

1. Read current TESTING.md (done in planning)
2. Add sections 12-16 (best practices expansion)
3. Add section 17 (anti-patterns)
4. Add section 18 (example library)
5. Add appendix (quick reference)
6. Update Table of Contents
7. Update CLAUDE.md
8. Review and verify all links/examples

---

**Document Version**: 1.0
**Created**: 2025-12-01
**Author**: Architecture Agent
**Status**: Ready for Implementation
**Priority**: Medium
**Estimated Duration**: 1-2 hours
**Type**: Documentation-Only Task
