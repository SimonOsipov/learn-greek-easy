# Task 04.08: Create Test Utilities and Helpers - Technical Architecture Plan

**Document Version**: 1.1
**Created**: 2025-12-01
**Completed**: 2025-12-01
**Status**: ✅ COMPLETED
**Priority**: Medium (Developer Experience Improvement)
**Dependencies**: 04.01 (pytest-asyncio), 04.02 (Database Fixtures), 04.03 (Base Test Classes), 04.05 (Factories)
**Type**: Architecture Documentation
**Actual Duration**: 2 hours

---

## Table of Contents

1. [Overview](#1-overview)
2. [Current State Analysis](#2-current-state-analysis)
3. [Architecture Design](#3-architecture-design)
4. [Implementation Details](#4-implementation-details)
5. [File Specifications](#5-file-specifications)
6. [Integration with Existing Infrastructure](#6-integration-with-existing-infrastructure)
7. [Usage Examples](#7-usage-examples)
8. [Verification Checklist](#8-verification-checklist)
9. [Acceptance Criteria](#9-acceptance-criteria)
10. [Related Documents](#10-related-documents)

---

## 1. Overview

### 1.1 Task Description

Create reusable test utilities and helper functions that complement the existing fixtures and factories. These utilities should make tests more readable, reduce boilerplate code, and provide domain-specific testing capabilities for the Learn Greek Easy application.

### 1.2 Objectives

1. **Custom Assertions**: Domain-specific assertion helpers for API responses, SM-2 algorithm, and data validation
2. **Time Utilities**: Helpers for testing time-dependent logic (token expiration, scheduling)
3. **API Test Helpers**: Streamlined HTTP request helpers with authentication
4. **Database Helpers**: Extended database utilities for common test operations
5. **Mock Builders**: Pre-configured mocks for external dependencies
6. **Test Data Builders**: Fluent builders for complex test scenarios

### 1.3 Success Criteria

- [x] All utility modules created with full type annotations
- [x] 100% test coverage for utility functions
- [x] Integration with existing fixtures, factories, and base classes
- [x] Documentation with docstrings and usage examples
- [x] Verification script passes all checks

### 1.4 Design Principles

| Principle | Application |
|-----------|-------------|
| **DRY** | Centralize common test patterns |
| **Readability** | Tests should read like specifications |
| **Async-First** | All helpers support async/await |
| **Type Safety** | Full type hints for IDE support |
| **Domain-Specific** | Helpers match Learn Greek Easy domain |

---

## 2. Current State Analysis

### 2.1 Existing Test Infrastructure

**File Structure**:
```
tests/
├── base.py                    # BaseTestCase, AuthenticatedTestCase
├── conftest.py                # Global fixtures
├── fixtures/
│   ├── auth.py               # User/token fixtures
│   ├── database.py           # PostgreSQL fixtures
│   ├── deck.py               # Deck/card fixtures
│   └── progress.py           # Progress/review fixtures
├── factories/
│   ├── base.py               # BaseFactory with async support
│   ├── auth.py               # UserFactory
│   ├── content.py            # DeckFactory, CardFactory
│   └── progress.py           # StatisticsFactory, ReviewFactory
└── helpers/
    └── database.py           # Database utilities (existing)
```

### 2.2 Existing Database Helpers

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/helpers/database.py`

Current functions:
- `get_test_database_url()` - Get test database URL
- `count_table_rows()` - Count rows in a table
- `table_exists()` - Check if table exists
- `clear_table()` - Truncate table
- `get_table_names()` - List all tables
- `verify_connection()` - Test database connection
- `verify_extensions()` - Check PostgreSQL extensions
- `get_database_info()` - Database metadata
- `utc_now()` / `days_ago()` / `days_from_now()` - Timestamp utilities

### 2.3 Existing Base Classes

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/base.py`

Current methods in `BaseTestCase`:
- `create_test_user()` / `create_test_superuser()`
- `create_test_deck()` / `create_test_card()` / `create_deck_with_cards()`
- `count_table_rows()` / `table_exists()` / `get_entity_by_id()`
- `utc_now()` / `days_ago()` / `days_from_now()`
- `assert_user_created()` / `assert_response_success()` / `assert_response_error()`

Current methods in `AuthenticatedTestCase`:
- `create_access_token_for_user()` / `create_auth_headers_for_user()`
- `make_authenticated_request()` / HTTP verb helpers
- `assert_unauthorized()` / `assert_forbidden()` / `assert_token_valid()` / `assert_token_expired()`

### 2.4 Missing Components

| Component | Purpose | Priority |
|-----------|---------|----------|
| Custom assertions for API responses | Validate response structure | High |
| SM-2 algorithm assertions | Verify spaced repetition calculations | High |
| Time freezing utilities | Test time-dependent logic | High |
| Query parameter builder | Construct URL query strings | Medium |
| Mock builders | Pre-configured mocks | Medium |
| Test data builders | Complex scenario setup | Medium |

---

## 3. Architecture Design

### 3.1 Module Structure

```
tests/
├── helpers/
│   ├── __init__.py            # Export all helpers
│   ├── database.py            # (existing) Database utilities
│   ├── assertions.py          # NEW: Custom assertion helpers
│   ├── time.py                # NEW: Time manipulation utilities
│   ├── api.py                 # NEW: API testing helpers
│   └── mocks.py               # NEW: Mock builders
└── utils/
    ├── __init__.py            # Export all utilities
    └── builders.py            # NEW: Test data builders
```

### 3.2 Dependency Graph

```
                    tests/helpers/__init__.py
                              |
        +---------------------+----------------------+
        |                     |                      |
   assertions.py          time.py               api.py
        |                     |                      |
        +----------+----------+                      |
                   |                                 |
              mocks.py                          builders.py
                   |                                 |
                   +----------------+----------------+
                                    |
                              conftest.py
```

### 3.3 Integration Points

| Module | Integrates With |
|--------|-----------------|
| `assertions.py` | Base test classes, API response schemas |
| `time.py` | Auth fixtures, progress fixtures |
| `api.py` | AuthenticatedTestCase, httpx.AsyncClient |
| `mocks.py` | Service layers (future) |
| `builders.py` | Factories, fixtures |

---

## 4. Implementation Details

### 4.1 Custom Assertions (`tests/helpers/assertions.py`)

```python
"""Custom assertion helpers for Learn Greek Easy tests.

This module provides domain-specific assertion functions that:
- Validate API response structures
- Verify SM-2 algorithm calculations
- Check pagination response format
- Validate error response structures

All assertions raise AssertionError with descriptive messages on failure.

Usage:
    from tests.helpers.assertions import (
        assert_valid_user_response,
        assert_valid_token_response,
        assert_sm2_calculation,
    )

    def test_user_creation(response):
        assert_valid_user_response(response.json())
"""

from datetime import date, datetime
from typing import Any
from uuid import UUID

from httpx import Response


# =============================================================================
# API Response Assertions
# =============================================================================


def assert_valid_user_response(
    data: dict[str, Any],
    *,
    email: str | None = None,
    full_name: str | None = None,
    is_active: bool = True,
    is_superuser: bool = False,
) -> None:
    """Assert that a user response has valid structure and expected values.

    Args:
        data: User response data dictionary
        email: Expected email (optional)
        full_name: Expected full name (optional)
        is_active: Expected active status
        is_superuser: Expected superuser status

    Raises:
        AssertionError: If validation fails

    Example:
        response = await client.get("/api/v1/auth/me", headers=auth_headers)
        assert_valid_user_response(response.json(), email="test@example.com")
    """
    # Required fields
    required_fields = ["id", "email", "is_active", "is_superuser", "created_at", "updated_at"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"

    # UUID validation
    try:
        UUID(data["id"])
    except (ValueError, TypeError):
        raise AssertionError(f"Invalid UUID format for id: {data['id']}")

    # Type validation
    assert isinstance(data["email"], str), f"email must be string, got {type(data['email'])}"
    assert isinstance(data["is_active"], bool), f"is_active must be bool, got {type(data['is_active'])}"
    assert isinstance(data["is_superuser"], bool), f"is_superuser must be bool, got {type(data['is_superuser'])}"

    # Expected values
    if email is not None:
        assert data["email"] == email, f"Expected email '{email}', got '{data['email']}'"
    if full_name is not None:
        assert data.get("full_name") == full_name, f"Expected full_name '{full_name}', got '{data.get('full_name')}'"
    assert data["is_active"] == is_active, f"Expected is_active={is_active}, got {data['is_active']}"
    assert data["is_superuser"] == is_superuser, f"Expected is_superuser={is_superuser}, got {data['is_superuser']}"


def assert_valid_token_response(
    data: dict[str, Any],
    *,
    token_type: str = "bearer",
    min_expires_in: int = 60,
) -> None:
    """Assert that a token response has valid structure.

    Args:
        data: Token response data dictionary
        token_type: Expected token type (default: "bearer")
        min_expires_in: Minimum expected expiration time in seconds

    Raises:
        AssertionError: If validation fails

    Example:
        response = await client.post("/api/v1/auth/login", json=credentials)
        assert_valid_token_response(response.json())
    """
    required_fields = ["access_token", "refresh_token", "token_type", "expires_in"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"

    # Token validation
    assert isinstance(data["access_token"], str), "access_token must be string"
    assert len(data["access_token"]) > 20, "access_token too short"
    assert isinstance(data["refresh_token"], str), "refresh_token must be string"
    assert len(data["refresh_token"]) > 20, "refresh_token too short"

    # Token type
    assert data["token_type"] == token_type, f"Expected token_type '{token_type}', got '{data['token_type']}'"

    # Expiration
    assert isinstance(data["expires_in"], int), f"expires_in must be int, got {type(data['expires_in'])}"
    assert data["expires_in"] >= min_expires_in, f"expires_in too short: {data['expires_in']} < {min_expires_in}"


def assert_api_error(
    response: Response,
    status_code: int,
    *,
    detail_contains: str | None = None,
    detail_exact: str | None = None,
) -> None:
    """Assert that an API error response has expected format.

    Args:
        response: HTTP response object
        status_code: Expected status code
        detail_contains: Substring that should be in detail message
        detail_exact: Exact detail message expected

    Raises:
        AssertionError: If validation fails

    Example:
        response = await client.post("/api/v1/auth/login", json=bad_credentials)
        assert_api_error(response, 401, detail_contains="Invalid")
    """
    assert response.status_code == status_code, (
        f"Expected status {status_code}, got {response.status_code}: {response.text}"
    )

    data = response.json()
    assert "detail" in data, f"Error response missing 'detail' field: {data}"

    if detail_exact is not None:
        assert data["detail"] == detail_exact, (
            f"Expected detail '{detail_exact}', got '{data['detail']}'"
        )

    if detail_contains is not None:
        assert detail_contains in str(data["detail"]), (
            f"Expected detail to contain '{detail_contains}', got '{data['detail']}'"
        )


def assert_pagination(
    data: dict[str, Any],
    *,
    total: int | None = None,
    page: int | None = None,
    page_size: int | None = None,
    min_items: int | None = None,
    max_items: int | None = None,
) -> None:
    """Assert that a paginated response has valid structure.

    Args:
        data: Paginated response data
        total: Expected total count
        page: Expected current page
        page_size: Expected page size
        min_items: Minimum items in current page
        max_items: Maximum items in current page

    Raises:
        AssertionError: If validation fails

    Example:
        response = await client.get("/api/v1/decks?page=1&page_size=10")
        assert_pagination(response.json(), page=1, page_size=10, min_items=1)
    """
    # Check for pagination fields (support multiple patterns)
    pagination_patterns = [
        ("items", "total", "page", "page_size"),
        ("data", "total", "page", "per_page"),
        ("results", "count", "page", "limit"),
    ]

    items_key = None
    for items_k, total_k, page_k, size_k in pagination_patterns:
        if items_k in data:
            items_key = items_k
            break

    assert items_key is not None, f"No recognized pagination pattern in response: {list(data.keys())}"

    items = data[items_key]
    assert isinstance(items, list), f"Items must be a list, got {type(items)}"

    if total is not None and "total" in data:
        assert data["total"] == total, f"Expected total {total}, got {data['total']}"

    if page is not None and "page" in data:
        assert data["page"] == page, f"Expected page {page}, got {data['page']}"

    if page_size is not None:
        size_key = next((k for k in ["page_size", "per_page", "limit"] if k in data), None)
        if size_key:
            assert data[size_key] == page_size, f"Expected {size_key} {page_size}, got {data[size_key]}"

    if min_items is not None:
        assert len(items) >= min_items, f"Expected at least {min_items} items, got {len(items)}"

    if max_items is not None:
        assert len(items) <= max_items, f"Expected at most {max_items} items, got {len(items)}"


# =============================================================================
# SM-2 Algorithm Assertions
# =============================================================================


def assert_sm2_calculation(
    *,
    quality: int,
    old_ef: float,
    old_interval: int,
    old_repetitions: int,
    new_ef: float,
    new_interval: int,
    new_repetitions: int,
    tolerance: float = 0.01,
) -> None:
    """Assert that SM-2 algorithm calculation is correct.

    The SM-2 algorithm:
    - EF = EF + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02))
    - EF minimum = 1.3
    - If q < 3: reset repetitions to 0, interval to 1
    - If q >= 3: increment repetitions, calculate new interval

    Args:
        quality: Review quality rating (0-5)
        old_ef: Easiness factor before review
        old_interval: Interval before review (days)
        old_repetitions: Repetition count before review
        new_ef: Easiness factor after review (actual)
        new_interval: Interval after review (actual)
        new_repetitions: Repetition count after review (actual)
        tolerance: Tolerance for float comparison

    Raises:
        AssertionError: If calculation doesn't match expected SM-2 output

    Example:
        # After a quality=4 review on a new card
        assert_sm2_calculation(
            quality=4,
            old_ef=2.5, old_interval=0, old_repetitions=0,
            new_ef=2.5, new_interval=1, new_repetitions=1,
        )
    """
    # Calculate expected EF
    ef_delta = 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)
    expected_ef = max(1.3, old_ef + ef_delta)

    # Calculate expected interval and repetitions
    if quality < 3:
        # Failed review: reset
        expected_repetitions = 0
        expected_interval = 1
    else:
        # Successful review
        expected_repetitions = old_repetitions + 1
        if expected_repetitions == 1:
            expected_interval = 1
        elif expected_repetitions == 2:
            expected_interval = 6
        else:
            expected_interval = round(old_interval * expected_ef)

    # Assert EF (with tolerance for floating point)
    assert abs(new_ef - expected_ef) <= tolerance, (
        f"SM-2 EF mismatch: expected {expected_ef:.2f}, got {new_ef:.2f} "
        f"(quality={quality}, old_ef={old_ef:.2f})"
    )

    # Assert interval
    assert new_interval == expected_interval, (
        f"SM-2 interval mismatch: expected {expected_interval}, got {new_interval} "
        f"(quality={quality}, old_interval={old_interval})"
    )

    # Assert repetitions
    assert new_repetitions == expected_repetitions, (
        f"SM-2 repetitions mismatch: expected {expected_repetitions}, got {new_repetitions} "
        f"(quality={quality}, old_repetitions={old_repetitions})"
    )


def assert_card_due(
    next_review_date: date,
    *,
    on_date: date | None = None,
    days_tolerance: int = 0,
) -> None:
    """Assert that a card is due for review.

    Args:
        next_review_date: Card's next review date
        on_date: Date to check against (default: today)
        days_tolerance: Allowed days difference

    Raises:
        AssertionError: If card is not due

    Example:
        assert_card_due(card_stats.next_review_date)  # Due today
        assert_card_due(card_stats.next_review_date, on_date=some_date)
    """
    check_date = on_date or date.today()
    days_diff = (next_review_date - check_date).days

    assert days_diff <= days_tolerance, (
        f"Card not due: next_review={next_review_date}, check_date={check_date}, "
        f"days_diff={days_diff}, tolerance={days_tolerance}"
    )


def assert_card_not_due(
    next_review_date: date,
    *,
    on_date: date | None = None,
    min_days: int = 1,
) -> None:
    """Assert that a card is not yet due for review.

    Args:
        next_review_date: Card's next review date
        on_date: Date to check against (default: today)
        min_days: Minimum days until due

    Raises:
        AssertionError: If card is due

    Example:
        assert_card_not_due(mastered_card.next_review_date, min_days=7)
    """
    check_date = on_date or date.today()
    days_until = (next_review_date - check_date).days

    assert days_until >= min_days, (
        f"Card is due: next_review={next_review_date}, check_date={check_date}, "
        f"days_until={days_until}, min_days={min_days}"
    )


# =============================================================================
# Deck/Card Assertions
# =============================================================================


def assert_valid_deck_response(
    data: dict[str, Any],
    *,
    name: str | None = None,
    level: str | None = None,
    is_active: bool = True,
) -> None:
    """Assert that a deck response has valid structure.

    Args:
        data: Deck response data
        name: Expected deck name
        level: Expected CEFR level (A1, A2, B1, B2, C1, C2)
        is_active: Expected active status

    Raises:
        AssertionError: If validation fails
    """
    required_fields = ["id", "name", "level", "is_active", "created_at"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"

    # UUID validation
    try:
        UUID(data["id"])
    except (ValueError, TypeError):
        raise AssertionError(f"Invalid UUID format for id: {data['id']}")

    # Level validation
    valid_levels = ["A1", "A2", "B1", "B2", "C1", "C2"]
    assert data["level"] in valid_levels, f"Invalid level: {data['level']}, expected one of {valid_levels}"

    # Expected values
    if name is not None:
        assert data["name"] == name, f"Expected name '{name}', got '{data['name']}'"
    if level is not None:
        assert data["level"] == level, f"Expected level '{level}', got '{data['level']}'"
    assert data["is_active"] == is_active, f"Expected is_active={is_active}, got {data['is_active']}"


def assert_valid_card_response(
    data: dict[str, Any],
    *,
    deck_id: str | UUID | None = None,
    front_text: str | None = None,
    back_text: str | None = None,
) -> None:
    """Assert that a card response has valid structure.

    Args:
        data: Card response data
        deck_id: Expected parent deck ID
        front_text: Expected front text
        back_text: Expected back text

    Raises:
        AssertionError: If validation fails
    """
    required_fields = ["id", "deck_id", "front_text", "back_text", "difficulty", "order_index"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"

    # UUID validation
    for uuid_field in ["id", "deck_id"]:
        try:
            UUID(data[uuid_field])
        except (ValueError, TypeError):
            raise AssertionError(f"Invalid UUID format for {uuid_field}: {data[uuid_field]}")

    # Difficulty validation
    valid_difficulties = ["EASY", "MEDIUM", "HARD"]
    assert data["difficulty"] in valid_difficulties, (
        f"Invalid difficulty: {data['difficulty']}, expected one of {valid_difficulties}"
    )

    # Expected values
    if deck_id is not None:
        assert str(data["deck_id"]) == str(deck_id), f"Expected deck_id '{deck_id}', got '{data['deck_id']}'"
    if front_text is not None:
        assert data["front_text"] == front_text, f"Expected front_text '{front_text}', got '{data['front_text']}'"
    if back_text is not None:
        assert data["back_text"] == back_text, f"Expected back_text '{back_text}', got '{data['back_text']}'"


# =============================================================================
# Progress Assertions
# =============================================================================


def assert_valid_progress_response(
    data: dict[str, Any],
    *,
    user_id: str | UUID | None = None,
    deck_id: str | UUID | None = None,
    min_cards_studied: int | None = None,
    min_cards_mastered: int | None = None,
) -> None:
    """Assert that a progress response has valid structure.

    Args:
        data: Progress response data
        user_id: Expected user ID
        deck_id: Expected deck ID
        min_cards_studied: Minimum cards studied count
        min_cards_mastered: Minimum cards mastered count

    Raises:
        AssertionError: If validation fails
    """
    required_fields = ["id", "user_id", "deck_id", "cards_studied", "cards_mastered"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"

    # Count validation
    assert data["cards_studied"] >= 0, f"cards_studied must be non-negative: {data['cards_studied']}"
    assert data["cards_mastered"] >= 0, f"cards_mastered must be non-negative: {data['cards_mastered']}"
    assert data["cards_mastered"] <= data["cards_studied"], (
        f"cards_mastered ({data['cards_mastered']}) > cards_studied ({data['cards_studied']})"
    )

    # Expected values
    if user_id is not None:
        assert str(data["user_id"]) == str(user_id), f"Expected user_id '{user_id}', got '{data['user_id']}'"
    if deck_id is not None:
        assert str(data["deck_id"]) == str(deck_id), f"Expected deck_id '{deck_id}', got '{data['deck_id']}'"
    if min_cards_studied is not None:
        assert data["cards_studied"] >= min_cards_studied, (
            f"Expected at least {min_cards_studied} cards_studied, got {data['cards_studied']}"
        )
    if min_cards_mastered is not None:
        assert data["cards_mastered"] >= min_cards_mastered, (
            f"Expected at least {min_cards_mastered} cards_mastered, got {data['cards_mastered']}"
        )
```

### 4.2 Time Utilities (`tests/helpers/time.py`)

```python
"""Time manipulation utilities for testing.

This module provides helpers for testing time-dependent logic:
- freeze_time context manager for fixed timestamps
- advance_time helper for SM-2 interval testing
- Token expiration helpers
- Due date calculation helpers

Usage:
    from tests.helpers.time import freeze_time, create_expired_token

    async def test_token_expiration():
        token = create_expired_token(user.id, hours_ago=1)
        # Token should be rejected

    async def test_scheduling():
        with freeze_time("2025-01-15"):
            # All datetime calls return 2025-01-15
            due_cards = await service.get_due_cards()
"""

from contextlib import contextmanager
from datetime import date, datetime, timedelta, timezone
from typing import Generator
from unittest.mock import patch
from uuid import UUID

# Check if freezegun is available (optional dependency)
try:
    from freezegun import freeze_time as freezegun_freeze_time
    FREEZEGUN_AVAILABLE = True
except ImportError:
    FREEZEGUN_AVAILABLE = False


# =============================================================================
# Time Freezing
# =============================================================================


@contextmanager
def freeze_time(
    frozen_time: str | datetime | date,
) -> Generator[datetime, None, None]:
    """Context manager to freeze time for testing.

    Uses freezegun if available, otherwise provides basic mocking.

    Args:
        frozen_time: Time to freeze to (ISO string, datetime, or date)

    Yields:
        datetime: The frozen datetime

    Example:
        with freeze_time("2025-01-15 10:30:00"):
            now = datetime.utcnow()
            assert now.date() == date(2025, 1, 15)

        # Or with a datetime object
        with freeze_time(datetime(2025, 1, 15, 10, 30)):
            ...
    """
    if FREEZEGUN_AVAILABLE:
        with freezegun_freeze_time(frozen_time) as frozen:
            yield frozen
    else:
        # Basic fallback without freezegun
        if isinstance(frozen_time, str):
            if "T" in frozen_time or " " in frozen_time:
                frozen_dt = datetime.fromisoformat(frozen_time.replace("Z", "+00:00"))
            else:
                frozen_dt = datetime.fromisoformat(frozen_time)
        elif isinstance(frozen_time, date) and not isinstance(frozen_time, datetime):
            frozen_dt = datetime.combine(frozen_time, datetime.min.time())
        else:
            frozen_dt = frozen_time

        # Mock datetime.utcnow and datetime.now
        class FrozenDatetime(datetime):
            @classmethod
            def utcnow(cls) -> datetime:
                return frozen_dt

            @classmethod
            def now(cls, tz=None) -> datetime:
                if tz:
                    return frozen_dt.replace(tzinfo=tz)
                return frozen_dt

        with patch("datetime.datetime", FrozenDatetime):
            yield frozen_dt


def advance_time(days: int = 0, hours: int = 0, minutes: int = 0) -> datetime:
    """Calculate a future datetime from now.

    Args:
        days: Days to advance
        hours: Hours to advance
        minutes: Minutes to advance

    Returns:
        datetime: Future timestamp

    Example:
        future_date = advance_time(days=7)
        assert future_date > datetime.utcnow()
    """
    return datetime.utcnow() + timedelta(days=days, hours=hours, minutes=minutes)


def past_time(days: int = 0, hours: int = 0, minutes: int = 0) -> datetime:
    """Calculate a past datetime from now.

    Args:
        days: Days ago
        hours: Hours ago
        minutes: Minutes ago

    Returns:
        datetime: Past timestamp

    Example:
        past_date = past_time(days=30)
        assert past_date < datetime.utcnow()
    """
    return datetime.utcnow() - timedelta(days=days, hours=hours, minutes=minutes)


# =============================================================================
# Token Expiration Helpers
# =============================================================================


def create_expired_token(
    user_id: UUID,
    *,
    hours_ago: int = 1,
    token_type: str = "access",
) -> str:
    """Create an expired JWT token for testing expiration handling.

    Args:
        user_id: User ID to embed in token
        hours_ago: How many hours ago the token expired
        token_type: Token type ("access" or "refresh")

    Returns:
        str: Expired JWT token

    Example:
        expired_token = create_expired_token(user.id, hours_ago=2)
        response = await client.get("/api/v1/auth/me", headers={"Authorization": f"Bearer {expired_token}"})
        assert response.status_code == 401
    """
    from jose import jwt
    from src.config import settings

    payload = {
        "sub": str(user_id),
        "exp": datetime.utcnow() - timedelta(hours=hours_ago),
        "iat": datetime.utcnow() - timedelta(hours=hours_ago + 1),
        "type": token_type,
    }
    return jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)


def create_future_token(
    user_id: UUID,
    *,
    expires_in_hours: int = 24,
    token_type: str = "access",
) -> str:
    """Create a JWT token that expires in the future.

    Args:
        user_id: User ID to embed in token
        expires_in_hours: Hours until expiration
        token_type: Token type ("access" or "refresh")

    Returns:
        str: Valid JWT token

    Example:
        token = create_future_token(user.id, expires_in_hours=1)
        # Use for testing near-expiration scenarios
    """
    from jose import jwt
    from src.config import settings

    payload = {
        "sub": str(user_id),
        "exp": datetime.utcnow() + timedelta(hours=expires_in_hours),
        "iat": datetime.utcnow(),
        "type": token_type,
    }
    return jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)


def get_token_expiration(token: str) -> datetime:
    """Extract expiration time from a JWT token.

    Args:
        token: JWT token string

    Returns:
        datetime: Token expiration time

    Example:
        exp = get_token_expiration(access_token)
        assert exp > datetime.utcnow()
    """
    from jose import jwt
    from src.config import settings

    payload = jwt.decode(
        token,
        settings.jwt_secret_key,
        algorithms=[settings.jwt_algorithm],
        options={"verify_exp": False}  # Don't verify, just extract
    )
    return datetime.fromtimestamp(payload["exp"], tz=timezone.utc)


# =============================================================================
# SM-2 Due Date Helpers
# =============================================================================


def create_due_date(
    days_from_today: int = 0,
) -> date:
    """Create a date for testing card scheduling.

    Args:
        days_from_today: Days relative to today (negative for past)

    Returns:
        date: Calculated date

    Example:
        due_today = create_due_date(0)
        due_tomorrow = create_due_date(1)
        overdue = create_due_date(-3)
    """
    return date.today() + timedelta(days=days_from_today)


def create_overdue_date(days_overdue: int = 1) -> date:
    """Create a date in the past for overdue cards.

    Args:
        days_overdue: How many days overdue

    Returns:
        date: Past date

    Example:
        overdue = create_overdue_date(5)  # 5 days overdue
    """
    return date.today() - timedelta(days=days_overdue)


def create_future_date(days_ahead: int = 1) -> date:
    """Create a date in the future for not-yet-due cards.

    Args:
        days_ahead: How many days until due

    Returns:
        date: Future date

    Example:
        future = create_future_date(7)  # Due in 7 days
    """
    return date.today() + timedelta(days=days_ahead)


def calculate_sm2_interval(
    repetitions: int,
    easiness_factor: float = 2.5,
    previous_interval: int = 0,
) -> int:
    """Calculate expected SM-2 interval.

    Args:
        repetitions: Number of successful repetitions
        easiness_factor: Current EF value
        previous_interval: Previous interval (for rep > 2)

    Returns:
        int: Expected interval in days

    Example:
        # First successful review
        interval = calculate_sm2_interval(1)
        assert interval == 1

        # Second successful review
        interval = calculate_sm2_interval(2)
        assert interval == 6
    """
    if repetitions == 0:
        return 0
    elif repetitions == 1:
        return 1
    elif repetitions == 2:
        return 6
    else:
        return round(previous_interval * easiness_factor)


# =============================================================================
# Time Range Helpers
# =============================================================================


def get_today_range() -> tuple[datetime, datetime]:
    """Get datetime range for today (00:00:00 to 23:59:59).

    Returns:
        tuple: (start_of_day, end_of_day)

    Example:
        start, end = get_today_range()
        # Query reviews from today
    """
    today = date.today()
    start = datetime.combine(today, datetime.min.time())
    end = datetime.combine(today, datetime.max.time())
    return start, end


def get_week_range(weeks_ago: int = 0) -> tuple[datetime, datetime]:
    """Get datetime range for a week.

    Args:
        weeks_ago: Number of weeks in the past (0 = current week)

    Returns:
        tuple: (start_of_week, end_of_week)

    Example:
        start, end = get_week_range(1)  # Last week
    """
    today = date.today()
    start_of_current_week = today - timedelta(days=today.weekday())
    target_start = start_of_current_week - timedelta(weeks=weeks_ago)
    target_end = target_start + timedelta(days=6)

    return (
        datetime.combine(target_start, datetime.min.time()),
        datetime.combine(target_end, datetime.max.time()),
    )


def get_month_range(months_ago: int = 0) -> tuple[datetime, datetime]:
    """Get datetime range for a month.

    Args:
        months_ago: Number of months in the past (0 = current month)

    Returns:
        tuple: (start_of_month, end_of_month)
    """
    today = date.today()

    # Calculate target month
    target_year = today.year
    target_month = today.month - months_ago

    while target_month <= 0:
        target_month += 12
        target_year -= 1

    # Start of month
    start = datetime(target_year, target_month, 1)

    # End of month
    if target_month == 12:
        end = datetime(target_year + 1, 1, 1) - timedelta(seconds=1)
    else:
        end = datetime(target_year, target_month + 1, 1) - timedelta(seconds=1)

    return start, end
```

### 4.3 API Test Helpers (`tests/helpers/api.py`)

```python
"""API testing utilities for Learn Greek Easy.

This module provides helpers for HTTP request testing:
- Authenticated request wrappers
- Token extraction utilities
- Query parameter builders
- Response validation helpers

Usage:
    from tests.helpers.api import (
        make_authenticated_request,
        extract_tokens_from_response,
        build_query_params,
    )

    async def test_api_call(client, auth_headers):
        response = await make_authenticated_request(
            client, "GET", "/api/v1/decks", auth_headers
        )
        assert response.status_code == 200
"""

from typing import Any
from urllib.parse import urlencode

from httpx import AsyncClient, Response


# =============================================================================
# Authenticated Request Helpers
# =============================================================================


async def make_authenticated_request(
    client: AsyncClient,
    method: str,
    url: str,
    headers: dict[str, str],
    *,
    json: dict[str, Any] | None = None,
    params: dict[str, Any] | None = None,
    data: dict[str, Any] | None = None,
    **kwargs,
) -> Response:
    """Make an authenticated HTTP request.

    A unified helper that handles all HTTP methods with proper authentication.

    Args:
        client: AsyncClient instance
        method: HTTP method (GET, POST, PUT, PATCH, DELETE)
        url: Request URL
        headers: Auth headers (must contain Authorization)
        json: JSON body for POST/PUT/PATCH
        params: Query parameters
        data: Form data
        **kwargs: Additional arguments to pass to client

    Returns:
        Response: HTTP response

    Example:
        response = await make_authenticated_request(
            client, "POST", "/api/v1/decks",
            auth_headers,
            json={"name": "My Deck", "level": "A1"}
        )
    """
    method = method.upper()

    # Build request kwargs
    request_kwargs: dict[str, Any] = {
        "headers": headers,
        **kwargs,
    }

    if json is not None:
        request_kwargs["json"] = json
    if params is not None:
        request_kwargs["params"] = params
    if data is not None:
        request_kwargs["data"] = data

    # Execute request
    if method == "GET":
        return await client.get(url, **request_kwargs)
    elif method == "POST":
        return await client.post(url, **request_kwargs)
    elif method == "PUT":
        return await client.put(url, **request_kwargs)
    elif method == "PATCH":
        return await client.patch(url, **request_kwargs)
    elif method == "DELETE":
        return await client.delete(url, **request_kwargs)
    else:
        raise ValueError(f"Unsupported HTTP method: {method}")


async def make_request_without_auth(
    client: AsyncClient,
    method: str,
    url: str,
    *,
    json: dict[str, Any] | None = None,
    params: dict[str, Any] | None = None,
    **kwargs,
) -> Response:
    """Make an unauthenticated HTTP request.

    Useful for testing public endpoints or auth-required error handling.

    Args:
        client: AsyncClient instance
        method: HTTP method
        url: Request URL
        json: JSON body
        params: Query parameters

    Returns:
        Response: HTTP response

    Example:
        response = await make_request_without_auth(client, "GET", "/api/v1/health")
        assert response.status_code == 200
    """
    return await make_authenticated_request(
        client, method, url, headers={},
        json=json, params=params, **kwargs
    )


# =============================================================================
# Token Utilities
# =============================================================================


def extract_tokens_from_response(response: Response) -> tuple[str, str]:
    """Extract access and refresh tokens from a login/register response.

    Args:
        response: HTTP response from auth endpoint

    Returns:
        tuple: (access_token, refresh_token)

    Raises:
        AssertionError: If tokens not found in response

    Example:
        response = await client.post("/api/v1/auth/login", json=credentials)
        access_token, refresh_token = extract_tokens_from_response(response)
    """
    assert response.status_code in (200, 201), (
        f"Expected successful auth response, got {response.status_code}: {response.text}"
    )

    data = response.json()
    assert "access_token" in data, f"access_token not found in response: {data}"
    assert "refresh_token" in data, f"refresh_token not found in response: {data}"

    return data["access_token"], data["refresh_token"]


def create_auth_headers(access_token: str) -> dict[str, str]:
    """Create Authorization headers from an access token.

    Args:
        access_token: JWT access token

    Returns:
        dict: Headers with Bearer token

    Example:
        headers = create_auth_headers(access_token)
        response = await client.get("/api/v1/auth/me", headers=headers)
    """
    return {"Authorization": f"Bearer {access_token}"}


def extract_user_id_from_response(response: Response) -> str:
    """Extract user ID from a user-related response.

    Args:
        response: HTTP response containing user data

    Returns:
        str: User ID

    Raises:
        AssertionError: If user ID not found
    """
    data = response.json()
    assert "id" in data, f"User ID not found in response: {data}"
    return data["id"]


# =============================================================================
# Query Parameter Builders
# =============================================================================


def build_query_params(**kwargs) -> dict[str, str]:
    """Build query parameters, filtering out None values.

    Args:
        **kwargs: Key-value pairs for query parameters

    Returns:
        dict: Filtered query parameters

    Example:
        params = build_query_params(page=1, page_size=10, search=None)
        # Returns {"page": "1", "page_size": "10"}
    """
    return {k: str(v) for k, v in kwargs.items() if v is not None}


def build_pagination_params(
    page: int = 1,
    page_size: int = 10,
    **extra,
) -> dict[str, str]:
    """Build pagination query parameters.

    Args:
        page: Page number (1-indexed)
        page_size: Items per page
        **extra: Additional query parameters

    Returns:
        dict: Pagination parameters

    Example:
        params = build_pagination_params(page=2, page_size=20, sort="created_at")
        # Returns {"page": "2", "page_size": "20", "sort": "created_at"}
    """
    params = {"page": str(page), "page_size": str(page_size)}
    params.update(build_query_params(**extra))
    return params


def build_filter_params(
    level: str | None = None,
    is_active: bool | None = None,
    search: str | None = None,
    **extra,
) -> dict[str, str]:
    """Build filter query parameters for deck/card endpoints.

    Args:
        level: CEFR level filter (A1, A2, etc.)
        is_active: Active status filter
        search: Search term
        **extra: Additional filters

    Returns:
        dict: Filter parameters

    Example:
        params = build_filter_params(level="A1", is_active=True)
    """
    params = {}
    if level is not None:
        params["level"] = level
    if is_active is not None:
        params["is_active"] = str(is_active).lower()
    if search is not None:
        params["search"] = search
    params.update(build_query_params(**extra))
    return params


def build_url_with_params(base_url: str, params: dict[str, str]) -> str:
    """Build a URL with query parameters.

    Args:
        base_url: Base URL path
        params: Query parameters

    Returns:
        str: URL with encoded query string

    Example:
        url = build_url_with_params("/api/v1/decks", {"page": "1", "level": "A1"})
        # Returns "/api/v1/decks?page=1&level=A1"
    """
    if not params:
        return base_url
    return f"{base_url}?{urlencode(params)}"


# =============================================================================
# Response Validation Helpers
# =============================================================================


def assert_status_code(
    response: Response,
    expected: int | list[int],
    *,
    message: str | None = None,
) -> None:
    """Assert that response has expected status code.

    Enhanced assertion with helpful error message including response body.

    Args:
        response: HTTP response
        expected: Expected status code(s)
        message: Custom error message prefix

    Raises:
        AssertionError: If status code doesn't match

    Example:
        assert_status_code(response, 200)
        assert_status_code(response, [200, 201], message="Create should succeed")
    """
    if isinstance(expected, int):
        expected = [expected]

    if response.status_code not in expected:
        error_msg = f"Expected status {expected}, got {response.status_code}"
        if message:
            error_msg = f"{message}: {error_msg}"

        # Try to include response body for debugging
        try:
            body = response.json()
            error_msg += f"\nResponse body: {body}"
        except Exception:
            error_msg += f"\nResponse text: {response.text[:500]}"

        raise AssertionError(error_msg)


def assert_json_response(response: Response) -> dict[str, Any]:
    """Assert response is JSON and return parsed body.

    Args:
        response: HTTP response

    Returns:
        dict: Parsed JSON body

    Raises:
        AssertionError: If response is not valid JSON

    Example:
        data = assert_json_response(response)
        assert data["id"] == expected_id
    """
    content_type = response.headers.get("content-type", "")
    assert "application/json" in content_type, (
        f"Expected JSON response, got content-type: {content_type}"
    )

    try:
        return response.json()
    except Exception as e:
        raise AssertionError(f"Response is not valid JSON: {e}\nBody: {response.text[:500]}")


def assert_success_response(
    response: Response,
    *,
    expected_keys: list[str] | None = None,
) -> dict[str, Any]:
    """Assert response is successful (2xx) and return body.

    Args:
        response: HTTP response
        expected_keys: Keys that should be in response

    Returns:
        dict: Response body

    Raises:
        AssertionError: If response is not successful
    """
    assert 200 <= response.status_code < 300, (
        f"Expected success status, got {response.status_code}: {response.text}"
    )

    data = assert_json_response(response)

    if expected_keys:
        for key in expected_keys:
            assert key in data, f"Expected key '{key}' not in response: {list(data.keys())}"

    return data
```

### 4.4 Mock Builders (`tests/helpers/mocks.py`)

```python
"""Mock builders for external dependencies.

This module provides pre-configured mocks for testing:
- Redis client mock
- Email service mock (future)
- External API mocks

Usage:
    from tests.helpers.mocks import mock_redis_client

    async def test_with_redis(mocker):
        redis = mock_redis_client(mocker)
        redis.get.return_value = "cached_value"
        # Test code that uses Redis
"""

from datetime import timedelta
from typing import Any
from unittest.mock import AsyncMock, MagicMock


# =============================================================================
# Redis Mock
# =============================================================================


def mock_redis_client(mocker: Any | None = None) -> MagicMock:
    """Create a pre-configured Redis client mock.

    Provides common Redis operations as AsyncMocks.

    Args:
        mocker: pytest-mock mocker fixture (optional)

    Returns:
        MagicMock: Configured Redis mock

    Example:
        redis = mock_redis_client()
        redis.get.return_value = b"cached_value"
        redis.set.return_value = True

        # In test
        result = await redis.get("key")
        assert result == b"cached_value"
    """
    mock = MagicMock()

    # Async operations
    mock.get = AsyncMock(return_value=None)
    mock.set = AsyncMock(return_value=True)
    mock.setex = AsyncMock(return_value=True)
    mock.delete = AsyncMock(return_value=1)
    mock.exists = AsyncMock(return_value=0)
    mock.expire = AsyncMock(return_value=True)
    mock.ttl = AsyncMock(return_value=-1)
    mock.incr = AsyncMock(return_value=1)
    mock.decr = AsyncMock(return_value=0)
    mock.lpush = AsyncMock(return_value=1)
    mock.rpush = AsyncMock(return_value=1)
    mock.lpop = AsyncMock(return_value=None)
    mock.rpop = AsyncMock(return_value=None)
    mock.lrange = AsyncMock(return_value=[])
    mock.hget = AsyncMock(return_value=None)
    mock.hset = AsyncMock(return_value=1)
    mock.hgetall = AsyncMock(return_value={})
    mock.hdel = AsyncMock(return_value=1)
    mock.sadd = AsyncMock(return_value=1)
    mock.srem = AsyncMock(return_value=1)
    mock.smembers = AsyncMock(return_value=set())
    mock.sismember = AsyncMock(return_value=False)

    # Connection management
    mock.close = AsyncMock()
    mock.ping = AsyncMock(return_value=True)

    # Pipeline support
    pipeline_mock = MagicMock()
    pipeline_mock.execute = AsyncMock(return_value=[])
    mock.pipeline = MagicMock(return_value=pipeline_mock)

    return mock


def configure_redis_cache(
    redis_mock: MagicMock,
    cache_data: dict[str, bytes | str],
) -> None:
    """Configure Redis mock with cached data.

    Args:
        redis_mock: Redis mock instance
        cache_data: Dictionary of key -> value pairs

    Example:
        redis = mock_redis_client()
        configure_redis_cache(redis, {
            "user:123": b'{"name": "Test"}',
            "session:abc": b'{"user_id": "123"}',
        })
    """
    async def mock_get(key: str):
        value = cache_data.get(key)
        if isinstance(value, str):
            return value.encode()
        return value

    redis_mock.get = AsyncMock(side_effect=mock_get)
    redis_mock.exists = AsyncMock(side_effect=lambda k: 1 if k in cache_data else 0)


# =============================================================================
# Email Service Mock
# =============================================================================


def mock_email_service(mocker: Any | None = None) -> MagicMock:
    """Create a pre-configured email service mock.

    Args:
        mocker: pytest-mock mocker fixture (optional)

    Returns:
        MagicMock: Configured email service mock

    Example:
        email_service = mock_email_service()
        email_service.send_verification_email.return_value = True

        # In test
        result = await email_service.send_verification_email(user.email)
        email_service.send_verification_email.assert_called_once_with(user.email)
    """
    mock = MagicMock()

    # Common email operations
    mock.send_email = AsyncMock(return_value=True)
    mock.send_verification_email = AsyncMock(return_value=True)
    mock.send_password_reset_email = AsyncMock(return_value=True)
    mock.send_welcome_email = AsyncMock(return_value=True)
    mock.send_notification = AsyncMock(return_value=True)

    # Batch operations
    mock.send_bulk = AsyncMock(return_value={"sent": 0, "failed": 0})

    return mock


# =============================================================================
# External API Mock
# =============================================================================


def mock_external_api(
    mocker: Any | None = None,
    *,
    base_url: str = "https://api.example.com",
    default_response: dict | None = None,
) -> MagicMock:
    """Create a generic external API mock.

    Args:
        mocker: pytest-mock mocker fixture (optional)
        base_url: Base URL for the API
        default_response: Default response for all endpoints

    Returns:
        MagicMock: Configured API mock

    Example:
        api = mock_external_api(base_url="https://translation.api.com")
        api.translate.return_value = {"translated": "Yeia sou"}

        result = await api.translate("Hello", "el")
    """
    mock = MagicMock()
    mock.base_url = base_url

    response = default_response or {"success": True}

    # HTTP methods
    mock.get = AsyncMock(return_value=response)
    mock.post = AsyncMock(return_value=response)
    mock.put = AsyncMock(return_value=response)
    mock.delete = AsyncMock(return_value=response)
    mock.patch = AsyncMock(return_value=response)

    # Common API operations
    mock.request = AsyncMock(return_value=response)
    mock.fetch = AsyncMock(return_value=response)

    return mock


def mock_http_response(
    status_code: int = 200,
    json_data: dict | None = None,
    text: str = "",
    headers: dict | None = None,
) -> MagicMock:
    """Create a mock HTTP response object.

    Args:
        status_code: HTTP status code
        json_data: Response JSON data
        text: Response text
        headers: Response headers

    Returns:
        MagicMock: Mock response object

    Example:
        response = mock_http_response(200, json_data={"id": "123"})
        assert response.status_code == 200
        assert response.json() == {"id": "123"}
    """
    mock = MagicMock()
    mock.status_code = status_code
    mock.text = text or str(json_data or "")
    mock.headers = headers or {"content-type": "application/json"}

    if json_data is not None:
        mock.json = MagicMock(return_value=json_data)
    else:
        mock.json = MagicMock(side_effect=ValueError("No JSON"))

    return mock


# =============================================================================
# Service Mocks
# =============================================================================


def mock_auth_service(mocker: Any | None = None) -> MagicMock:
    """Create a mock for AuthService.

    Args:
        mocker: pytest-mock mocker fixture (optional)

    Returns:
        MagicMock: Configured AuthService mock

    Example:
        auth_service = mock_auth_service()
        auth_service.authenticate.return_value = (user, tokens)
    """
    mock = MagicMock()

    mock.register_user = AsyncMock()
    mock.login_user = AsyncMock()
    mock.refresh_access_token = AsyncMock()
    mock.revoke_refresh_token = AsyncMock(return_value=True)
    mock.revoke_all_user_tokens = AsyncMock(return_value=1)
    mock.get_user_sessions = AsyncMock(return_value=[])
    mock.revoke_session_by_id = AsyncMock(return_value=True)

    return mock


# =============================================================================
# Database Mocks
# =============================================================================


def mock_async_session() -> MagicMock:
    """Create a mock AsyncSession for unit testing without database.

    Returns:
        MagicMock: Mock session with async operations

    Example:
        session = mock_async_session()
        session.execute.return_value = mock_result
    """
    mock = MagicMock()

    # Async context manager support
    mock.__aenter__ = AsyncMock(return_value=mock)
    mock.__aexit__ = AsyncMock(return_value=None)

    # Core operations
    mock.execute = AsyncMock()
    mock.commit = AsyncMock()
    mock.rollback = AsyncMock()
    mock.close = AsyncMock()
    mock.flush = AsyncMock()
    mock.refresh = AsyncMock()

    # Query operations
    mock.get = AsyncMock(return_value=None)
    mock.add = MagicMock()
    mock.delete = AsyncMock()

    return mock
```

### 4.5 Test Data Builders (`tests/utils/builders.py`)

```python
"""Test data builders for complex scenarios.

This module provides fluent builders for creating complex test data:
- ReviewSessionBuilder: Build multi-card review sessions
- ProgressScenarioBuilder: Build user progress scenarios
- StudyStreakBuilder: Build study streak data

Builders provide a fluent API for readable test setup.

Usage:
    from tests.utils.builders import ReviewSessionBuilder

    async def test_review_session(db_session, test_user, deck_with_cards):
        session = await (
            ReviewSessionBuilder(db_session)
            .for_user(test_user)
            .for_deck(deck_with_cards.deck)
            .with_cards(deck_with_cards.cards[:5])
            .with_ratings([5, 4, 4, 3, 5])
            .build()
        )
        assert len(session.reviews) == 5
"""

from dataclasses import dataclass, field
from datetime import date, datetime, timedelta
from typing import Any
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import (
    Card,
    CardStatistics,
    CardStatus,
    Deck,
    Review,
    ReviewRating,
    User,
    UserDeckProgress,
)


# =============================================================================
# Result Containers
# =============================================================================


@dataclass
class ReviewSessionResult:
    """Container for review session builder output."""
    user: User
    deck: Deck
    cards: list[Card]
    reviews: list[Review]
    statistics: list[CardStatistics]
    duration_seconds: int
    average_quality: float


@dataclass
class ProgressScenarioResult:
    """Container for progress scenario builder output."""
    user: User
    decks: list[Deck]
    progress_records: list[UserDeckProgress]
    card_statistics: list[CardStatistics]
    reviews: list[Review]
    total_cards_studied: int
    total_cards_mastered: int


@dataclass
class StudyStreakResult:
    """Container for study streak builder output."""
    user: User
    reviews: list[Review]
    streak_days: int
    study_dates: list[date]
    cards_per_day: dict[date, int]


# =============================================================================
# Review Session Builder
# =============================================================================


class ReviewSessionBuilder:
    """Builder for creating review session test data.

    Creates a realistic review session with:
    - Multiple card reviews
    - SM-2 statistics updates
    - Timing information

    Example:
        result = await (
            ReviewSessionBuilder(db_session)
            .for_user(user)
            .for_deck(deck)
            .with_cards(cards)
            .with_ratings([5, 4, 4, 3, 5])
            .with_time_per_card(5)
            .build()
        )
    """

    def __init__(self, db_session: AsyncSession):
        self._session = db_session
        self._user: User | None = None
        self._deck: Deck | None = None
        self._cards: list[Card] = []
        self._ratings: list[int] = []
        self._time_per_card: int = 5
        self._session_start: datetime = datetime.utcnow()
        self._create_statistics: bool = True

    def for_user(self, user: User) -> "ReviewSessionBuilder":
        """Set the user for this session."""
        self._user = user
        return self

    def for_deck(self, deck: Deck) -> "ReviewSessionBuilder":
        """Set the deck being reviewed."""
        self._deck = deck
        return self

    def with_cards(self, cards: list[Card]) -> "ReviewSessionBuilder":
        """Set the cards to review."""
        self._cards = cards
        return self

    def with_ratings(self, ratings: list[int]) -> "ReviewSessionBuilder":
        """Set the quality ratings for each card (0-5).

        If fewer ratings than cards, remaining cards get rating 4.
        """
        self._ratings = ratings
        return self

    def with_all_perfect(self) -> "ReviewSessionBuilder":
        """Set all ratings to perfect (5)."""
        self._ratings = [ReviewRating.PERFECT] * len(self._cards)
        return self

    def with_all_failed(self) -> "ReviewSessionBuilder":
        """Set all ratings to failed (0)."""
        self._ratings = [ReviewRating.BLACKOUT] * len(self._cards)
        return self

    def with_mixed_ratings(self) -> "ReviewSessionBuilder":
        """Set realistic mixed ratings."""
        import random
        self._ratings = [random.choice([3, 4, 4, 5, 5]) for _ in self._cards]
        return self

    def with_time_per_card(self, seconds: int) -> "ReviewSessionBuilder":
        """Set average time spent per card."""
        self._time_per_card = seconds
        return self

    def at_time(self, session_start: datetime) -> "ReviewSessionBuilder":
        """Set the session start time."""
        self._session_start = session_start
        return self

    def without_statistics(self) -> "ReviewSessionBuilder":
        """Skip creating CardStatistics (just reviews)."""
        self._create_statistics = False
        return self

    async def build(self) -> ReviewSessionResult:
        """Build and persist the review session."""
        if not self._user:
            raise ValueError("User is required. Call .for_user()")
        if not self._deck:
            raise ValueError("Deck is required. Call .for_deck()")
        if not self._cards:
            raise ValueError("Cards are required. Call .with_cards()")

        # Extend ratings if needed
        while len(self._ratings) < len(self._cards):
            self._ratings.append(ReviewRating.CORRECT_HESITANT)

        reviews = []
        statistics = []
        current_time = self._session_start

        for i, (card, rating) in enumerate(zip(self._cards, self._ratings)):
            # Create review
            review = Review(
                user_id=self._user.id,
                card_id=card.id,
                quality=rating,
                time_taken=self._time_per_card + (i % 3),  # Slight variation
                reviewed_at=current_time,
            )
            self._session.add(review)
            reviews.append(review)

            # Create statistics if requested
            if self._create_statistics:
                stats = CardStatistics(
                    user_id=self._user.id,
                    card_id=card.id,
                    easiness_factor=2.5,
                    interval=1 if rating >= 3 else 0,
                    repetitions=1 if rating >= 3 else 0,
                    next_review_date=date.today() + timedelta(days=1),
                    status=CardStatus.LEARNING if rating >= 3 else CardStatus.NEW,
                )
                self._session.add(stats)
                statistics.append(stats)

            # Advance time
            current_time += timedelta(seconds=self._time_per_card)

        await self._session.commit()

        # Calculate metrics
        total_time = len(self._cards) * self._time_per_card
        avg_quality = sum(self._ratings) / len(self._ratings)

        return ReviewSessionResult(
            user=self._user,
            deck=self._deck,
            cards=self._cards,
            reviews=reviews,
            statistics=statistics,
            duration_seconds=total_time,
            average_quality=avg_quality,
        )


# =============================================================================
# Progress Scenario Builder
# =============================================================================


class ProgressScenarioBuilder:
    """Builder for creating user progress scenarios.

    Creates comprehensive progress data including:
    - Multiple deck progress records
    - Card statistics at various stages
    - Review history

    Example:
        result = await (
            ProgressScenarioBuilder(db_session)
            .for_user(user)
            .with_deck(deck1, studied=10, mastered=5)
            .with_deck(deck2, studied=5, mastered=2)
            .with_study_history(days=30)
            .build()
        )
    """

    def __init__(self, db_session: AsyncSession):
        self._session = db_session
        self._user: User | None = None
        self._deck_configs: list[dict] = []
        self._study_days: int = 0
        self._cards_per_day: int = 10

    def for_user(self, user: User) -> "ProgressScenarioBuilder":
        """Set the user for this scenario."""
        self._user = user
        return self

    def with_deck(
        self,
        deck: Deck,
        cards: list[Card] | None = None,
        studied: int = 5,
        mastered: int = 2,
    ) -> "ProgressScenarioBuilder":
        """Add a deck with progress configuration.

        Args:
            deck: The deck
            cards: Cards in the deck (optional, creates statistics if provided)
            studied: Number of cards studied
            mastered: Number of cards mastered
        """
        self._deck_configs.append({
            "deck": deck,
            "cards": cards or [],
            "studied": studied,
            "mastered": mastered,
        })
        return self

    def with_study_history(
        self,
        days: int = 30,
        cards_per_day: int = 10,
    ) -> "ProgressScenarioBuilder":
        """Generate study history over a period.

        Args:
            days: Number of days of history
            cards_per_day: Average cards reviewed per day
        """
        self._study_days = days
        self._cards_per_day = cards_per_day
        return self

    def as_beginner(self) -> "ProgressScenarioBuilder":
        """Configure as a beginner user (minimal progress)."""
        for config in self._deck_configs:
            config["studied"] = min(config["studied"], 5)
            config["mastered"] = min(config["mastered"], 1)
        self._study_days = 7
        return self

    def as_intermediate(self) -> "ProgressScenarioBuilder":
        """Configure as intermediate user."""
        for config in self._deck_configs:
            config["studied"] = 20
            config["mastered"] = 10
        self._study_days = 30
        return self

    def as_advanced(self) -> "ProgressScenarioBuilder":
        """Configure as advanced user (lots of progress)."""
        for config in self._deck_configs:
            config["studied"] = 50
            config["mastered"] = 40
        self._study_days = 90
        return self

    async def build(self) -> ProgressScenarioResult:
        """Build and persist the progress scenario."""
        if not self._user:
            raise ValueError("User is required. Call .for_user()")
        if not self._deck_configs:
            raise ValueError("At least one deck is required. Call .with_deck()")

        progress_records = []
        all_statistics = []
        all_reviews = []
        total_studied = 0
        total_mastered = 0

        for config in self._deck_configs:
            deck = config["deck"]
            cards = config["cards"]
            studied = config["studied"]
            mastered = config["mastered"]

            # Create progress record
            progress = UserDeckProgress(
                user_id=self._user.id,
                deck_id=deck.id,
                cards_studied=studied,
                cards_mastered=mastered,
                last_studied_at=datetime.utcnow(),
            )
            self._session.add(progress)
            progress_records.append(progress)
            total_studied += studied
            total_mastered += mastered

            # Create statistics for cards
            for i, card in enumerate(cards[:studied]):
                if i < mastered:
                    status = CardStatus.MASTERED
                    interval = 30
                    repetitions = 10
                elif i < studied:
                    status = CardStatus.LEARNING
                    interval = 1
                    repetitions = 2
                else:
                    status = CardStatus.NEW
                    interval = 0
                    repetitions = 0

                stats = CardStatistics(
                    user_id=self._user.id,
                    card_id=card.id,
                    easiness_factor=2.5,
                    interval=interval,
                    repetitions=repetitions,
                    next_review_date=date.today() + timedelta(days=interval),
                    status=status,
                )
                self._session.add(stats)
                all_statistics.append(stats)

        # Create review history if requested
        if self._study_days > 0 and cards:
            start_date = datetime.utcnow() - timedelta(days=self._study_days)
            for day in range(self._study_days):
                review_date = start_date + timedelta(days=day)
                # Create some reviews for this day
                for _ in range(min(self._cards_per_day, len(cards))):
                    card = cards[day % len(cards)]
                    review = Review(
                        user_id=self._user.id,
                        card_id=card.id,
                        quality=ReviewRating.CORRECT_HESITANT,
                        time_taken=5,
                        reviewed_at=review_date,
                    )
                    self._session.add(review)
                    all_reviews.append(review)

        await self._session.commit()

        return ProgressScenarioResult(
            user=self._user,
            decks=[c["deck"] for c in self._deck_configs],
            progress_records=progress_records,
            card_statistics=all_statistics,
            reviews=all_reviews,
            total_cards_studied=total_studied,
            total_cards_mastered=total_mastered,
        )


# =============================================================================
# Study Streak Builder
# =============================================================================


class StudyStreakBuilder:
    """Builder for creating study streak test data.

    Creates review data that represents a consecutive study streak.

    Example:
        result = await (
            StudyStreakBuilder(db_session)
            .for_user(user)
            .with_cards(cards)
            .with_streak(days=7)
            .with_cards_per_day(10)
            .build()
        )
    """

    def __init__(self, db_session: AsyncSession):
        self._session = db_session
        self._user: User | None = None
        self._cards: list[Card] = []
        self._streak_days: int = 7
        self._cards_per_day: int = 10
        self._start_date: date | None = None
        self._break_days: list[int] = []

    def for_user(self, user: User) -> "StudyStreakBuilder":
        """Set the user."""
        self._user = user
        return self

    def with_cards(self, cards: list[Card]) -> "StudyStreakBuilder":
        """Set the cards to use for reviews."""
        self._cards = cards
        return self

    def with_streak(self, days: int) -> "StudyStreakBuilder":
        """Set the streak length in days."""
        self._streak_days = days
        return self

    def with_cards_per_day(self, count: int) -> "StudyStreakBuilder":
        """Set cards reviewed per day."""
        self._cards_per_day = count
        return self

    def starting_from(self, start_date: date) -> "StudyStreakBuilder":
        """Set the streak start date."""
        self._start_date = start_date
        return self

    def ending_today(self) -> "StudyStreakBuilder":
        """Configure streak to end today."""
        self._start_date = date.today() - timedelta(days=self._streak_days - 1)
        return self

    def with_breaks(self, break_days: list[int]) -> "StudyStreakBuilder":
        """Add breaks in the streak (0-indexed day numbers).

        Example: .with_breaks([3, 5]) skips days 3 and 5
        """
        self._break_days = break_days
        return self

    async def build(self) -> StudyStreakResult:
        """Build and persist the streak data."""
        if not self._user:
            raise ValueError("User is required. Call .for_user()")
        if not self._cards:
            raise ValueError("Cards are required. Call .with_cards()")

        start_date = self._start_date or (date.today() - timedelta(days=self._streak_days - 1))

        reviews = []
        study_dates = []
        cards_per_day: dict[date, int] = {}
        actual_streak = 0

        for day in range(self._streak_days):
            if day in self._break_days:
                continue

            current_date = start_date + timedelta(day)
            study_dates.append(current_date)
            actual_streak += 1

            day_reviews = 0
            for i in range(min(self._cards_per_day, len(self._cards))):
                card = self._cards[(day + i) % len(self._cards)]
                review = Review(
                    user_id=self._user.id,
                    card_id=card.id,
                    quality=ReviewRating.CORRECT_HESITANT,
                    time_taken=5,
                    reviewed_at=datetime.combine(current_date, datetime.min.time().replace(hour=10)),
                )
                self._session.add(review)
                reviews.append(review)
                day_reviews += 1

            cards_per_day[current_date] = day_reviews

        await self._session.commit()

        return StudyStreakResult(
            user=self._user,
            reviews=reviews,
            streak_days=actual_streak,
            study_dates=study_dates,
            cards_per_day=cards_per_day,
        )
```

---

## 5. File Specifications

### 5.1 Module Init Files

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/helpers/__init__.py`

```python
"""Test helpers for Learn Greek Easy.

This package provides utility functions and helpers for testing:
- database: Database utilities (existing)
- assertions: Custom assertion helpers
- time: Time manipulation utilities
- api: API testing helpers
- mocks: Mock builders
"""

from tests.helpers.assertions import (
    assert_api_error,
    assert_card_due,
    assert_card_not_due,
    assert_pagination,
    assert_sm2_calculation,
    assert_valid_card_response,
    assert_valid_deck_response,
    assert_valid_progress_response,
    assert_valid_token_response,
    assert_valid_user_response,
)
from tests.helpers.api import (
    assert_json_response,
    assert_status_code,
    assert_success_response,
    build_filter_params,
    build_pagination_params,
    build_query_params,
    build_url_with_params,
    create_auth_headers,
    extract_tokens_from_response,
    extract_user_id_from_response,
    make_authenticated_request,
    make_request_without_auth,
)
from tests.helpers.database import (
    clear_table,
    count_table_rows,
    days_ago,
    days_from_now,
    get_database_info,
    get_enum_values,
    get_table_names,
    get_test_database_url,
    reset_sequences,
    table_exists,
    utc_now,
    verify_connection,
    verify_extensions,
)
from tests.helpers.mocks import (
    configure_redis_cache,
    mock_async_session,
    mock_auth_service,
    mock_email_service,
    mock_external_api,
    mock_http_response,
    mock_redis_client,
)
from tests.helpers.time import (
    advance_time,
    calculate_sm2_interval,
    create_due_date,
    create_expired_token,
    create_future_date,
    create_future_token,
    create_overdue_date,
    freeze_time,
    get_month_range,
    get_today_range,
    get_token_expiration,
    get_week_range,
    past_time,
)

__all__ = [
    # assertions
    "assert_api_error",
    "assert_card_due",
    "assert_card_not_due",
    "assert_pagination",
    "assert_sm2_calculation",
    "assert_valid_card_response",
    "assert_valid_deck_response",
    "assert_valid_progress_response",
    "assert_valid_token_response",
    "assert_valid_user_response",
    # api
    "assert_json_response",
    "assert_status_code",
    "assert_success_response",
    "build_filter_params",
    "build_pagination_params",
    "build_query_params",
    "build_url_with_params",
    "create_auth_headers",
    "extract_tokens_from_response",
    "extract_user_id_from_response",
    "make_authenticated_request",
    "make_request_without_auth",
    # database
    "clear_table",
    "count_table_rows",
    "days_ago",
    "days_from_now",
    "get_database_info",
    "get_enum_values",
    "get_table_names",
    "get_test_database_url",
    "reset_sequences",
    "table_exists",
    "utc_now",
    "verify_connection",
    "verify_extensions",
    # mocks
    "configure_redis_cache",
    "mock_async_session",
    "mock_auth_service",
    "mock_email_service",
    "mock_external_api",
    "mock_http_response",
    "mock_redis_client",
    # time
    "advance_time",
    "calculate_sm2_interval",
    "create_due_date",
    "create_expired_token",
    "create_future_date",
    "create_future_token",
    "create_overdue_date",
    "freeze_time",
    "get_month_range",
    "get_today_range",
    "get_token_expiration",
    "get_week_range",
    "past_time",
]
```

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/utils/__init__.py`

```python
"""Test utilities for Learn Greek Easy.

This package provides utility classes for testing:
- builders: Fluent test data builders
"""

from tests.utils.builders import (
    ProgressScenarioBuilder,
    ProgressScenarioResult,
    ReviewSessionBuilder,
    ReviewSessionResult,
    StudyStreakBuilder,
    StudyStreakResult,
)

__all__ = [
    "ProgressScenarioBuilder",
    "ProgressScenarioResult",
    "ReviewSessionBuilder",
    "ReviewSessionResult",
    "StudyStreakBuilder",
    "StudyStreakResult",
]
```

---

## 6. Integration with Existing Infrastructure

### 6.1 Update conftest.py

Add imports for new helpers:

```python
# In tests/conftest.py

# Add to existing imports
from tests.helpers import (
    # Existing database helpers
    get_test_database_url,
    count_table_rows,
    table_exists,
    # New helpers
    create_auth_headers,
    make_authenticated_request,
    freeze_time,
    mock_redis_client,
)

from tests.utils import (
    ReviewSessionBuilder,
    ProgressScenarioBuilder,
    StudyStreakBuilder,
)

# Optional: Add fixtures for common mocks
@pytest.fixture
def redis_mock():
    """Provide a pre-configured Redis mock."""
    return mock_redis_client()

@pytest.fixture
def email_service_mock():
    """Provide a pre-configured email service mock."""
    from tests.helpers.mocks import mock_email_service
    return mock_email_service()
```

### 6.2 Usage in Base Test Classes

```python
# In tests/base.py, add methods that use new helpers

from tests.helpers.assertions import (
    assert_valid_user_response,
    assert_valid_token_response,
    assert_api_error,
)

class AuthenticatedTestCase(BaseTestCase):
    # ... existing code ...

    def assert_valid_login_response(self, response: Response) -> None:
        """Assert that a login response is valid."""
        from tests.helpers.assertions import assert_valid_token_response
        self.assert_response_success(response)
        assert_valid_token_response(response.json())

    def assert_valid_me_response(
        self,
        response: Response,
        expected_email: str | None = None,
    ) -> None:
        """Assert that a /me response is valid."""
        from tests.helpers.assertions import assert_valid_user_response
        self.assert_response_success(response)
        assert_valid_user_response(response.json(), email=expected_email)
```

---

## 7. Usage Examples

### 7.1 Using Custom Assertions

```python
# tests/integration/api/test_auth.py

from tests.helpers.assertions import (
    assert_valid_token_response,
    assert_valid_user_response,
    assert_api_error,
)

class TestAuthEndpoints:
    async def test_register_success(self, client):
        response = await client.post("/api/v1/auth/register", json={
            "email": "newuser@example.com",
            "password": "SecurePass123!",
            "full_name": "New User",
        })
        assert response.status_code == 201
        assert_valid_token_response(response.json())

    async def test_register_weak_password(self, client):
        response = await client.post("/api/v1/auth/register", json={
            "email": "user@example.com",
            "password": "weak",
            "full_name": "User",
        })
        assert_api_error(response, 422, detail_contains="Password")

    async def test_me_endpoint(self, client, auth_headers, test_user):
        response = await client.get("/api/v1/auth/me", headers=auth_headers)
        assert response.status_code == 200
        assert_valid_user_response(response.json(), email=test_user.email)
```

### 7.2 Using Time Utilities

```python
# tests/unit/core/test_token_expiration.py

from tests.helpers.time import (
    create_expired_token,
    create_future_token,
    freeze_time,
)

class TestTokenExpiration:
    async def test_expired_token_rejected(self, client, test_user):
        expired = create_expired_token(test_user.id, hours_ago=2)
        response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {expired}"},
        )
        assert response.status_code == 401

    async def test_valid_token_accepted(self, client, test_user):
        valid = create_future_token(test_user.id, expires_in_hours=1)
        response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {valid}"},
        )
        assert response.status_code == 200

    async def test_scheduling_with_frozen_time(self, db_session, test_user, test_card):
        with freeze_time("2025-01-15"):
            # Create card statistics due today
            stats = CardStatistics(
                user_id=test_user.id,
                card_id=test_card.id,
                next_review_date=date(2025, 1, 15),
                status=CardStatus.REVIEW,
            )
            db_session.add(stats)
            await db_session.commit()

            # Verify card is due
            from tests.helpers.assertions import assert_card_due
            assert_card_due(stats.next_review_date)
```

### 7.3 Using Test Data Builders

```python
# tests/integration/api/test_reviews.py

from tests.utils.builders import ReviewSessionBuilder, ProgressScenarioBuilder

class TestReviewSession:
    async def test_complete_review_session(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        # Build a review session
        result = await (
            ReviewSessionBuilder(db_session)
            .for_user(test_user)
            .for_deck(deck_with_cards.deck)
            .with_cards(deck_with_cards.cards[:5])
            .with_ratings([5, 4, 4, 3, 5])
            .build()
        )

        assert len(result.reviews) == 5
        assert result.average_quality == 4.2
        assert len(result.statistics) == 5

    async def test_user_progress_scenario(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        # Build an intermediate user progress scenario
        result = await (
            ProgressScenarioBuilder(db_session)
            .for_user(test_user)
            .with_deck(
                deck_with_cards.deck,
                cards=deck_with_cards.cards,
                studied=10,
                mastered=5,
            )
            .as_intermediate()
            .build()
        )

        assert result.total_cards_studied >= 10
        assert result.total_cards_mastered >= 5

    async def test_study_streak(
        self,
        db_session,
        test_user,
        deck_with_cards,
    ):
        result = await (
            StudyStreakBuilder(db_session)
            .for_user(test_user)
            .with_cards(deck_with_cards.cards)
            .with_streak(days=7)
            .ending_today()
            .build()
        )

        assert result.streak_days == 7
        assert len(result.study_dates) == 7
```

### 7.4 Using Mock Builders

```python
# tests/unit/services/test_auth_service.py

from tests.helpers.mocks import mock_redis_client, mock_email_service

class TestAuthServiceWithMocks:
    async def test_with_redis_cache(self, mocker):
        redis = mock_redis_client()
        redis.get.return_value = b'{"user_id": "123"}'

        # Inject mock into service
        mocker.patch("src.services.auth_service.redis_client", redis)

        # Test cache hit scenario
        result = await redis.get("session:abc")
        assert result == b'{"user_id": "123"}'
        redis.get.assert_called_once_with("session:abc")

    async def test_email_verification(self, mocker):
        email_service = mock_email_service()

        # Test email sending
        result = await email_service.send_verification_email("user@example.com")
        assert result is True
        email_service.send_verification_email.assert_called_once_with("user@example.com")
```

---

## 8. Verification Checklist

### 8.1 Implementation Checklist

- [ ] Create `tests/helpers/assertions.py` with all assertion functions
- [ ] Create `tests/helpers/time.py` with time utilities
- [ ] Create `tests/helpers/api.py` with API helpers
- [ ] Create `tests/helpers/mocks.py` with mock builders
- [ ] Create `tests/utils/` directory
- [ ] Create `tests/utils/builders.py` with data builders
- [ ] Update `tests/helpers/__init__.py` with new exports
- [ ] Create `tests/utils/__init__.py` with exports
- [ ] Add optional `freezegun` dependency to pyproject.toml

### 8.2 Testing Checklist

- [ ] All helper functions have docstrings
- [ ] All functions have type hints
- [ ] Unit tests exist for each helper module
- [ ] Integration tests use the new helpers
- [ ] No circular imports
- [ ] All imports resolve correctly

### 8.3 Documentation Checklist

- [ ] Module-level docstrings explain purpose
- [ ] Function docstrings include examples
- [ ] Usage examples in this plan are accurate
- [ ] README or contributing guide updated

---

## 9. Acceptance Criteria

### 9.1 Functional Requirements

| Requirement | Status | Notes |
|-------------|--------|-------|
| Custom assertions module created | Pending | 12+ assertion functions |
| Time utilities module created | Pending | freeze_time, token helpers |
| API helpers module created | Pending | Request helpers, extractors |
| Mock builders module created | Pending | Redis, email, API mocks |
| Test data builders created | Pending | 3 builder classes |
| All modules have type hints | Pending | Full type coverage |
| All modules have docstrings | Pending | With examples |

### 9.2 Quality Requirements

| Requirement | Target | Status |
|-------------|--------|--------|
| Test coverage for helpers | >= 90% | Pending |
| No circular imports | 0 | Pending |
| Type checking passes | mypy clean | Pending |
| Integration with existing tests | Working | Pending |

### 9.3 Performance Requirements

| Requirement | Target | Status |
|-------------|--------|--------|
| Helper import time | < 100ms | Pending |
| Builder execution time | < 500ms | Pending |
| No significant test slowdown | < 5% | Pending |

---

## 10. Related Documents

| Document | Location | Description |
|----------|----------|-------------|
| Main Testing Framework Plan | [04-backend-testing-framework-plan.md](./04-backend-testing-framework-plan.md) | Parent task |
| Test Database Fixtures | [04.02-test-database-fixtures-plan.md](./04.02-test-database-fixtures-plan.md) | Database fixtures |
| Base Test Classes | [04.03-base-test-classes-plan.md](./04.03-base-test-classes-plan.md) | Base classes |
| Factory Classes | [04.05-factory-classes-plan.md](./04.05-factory-classes-plan.md) | Test factories |
| Backend Tasks Progress | [../Backend-Tasks-Progress.md](../Backend-Tasks-Progress.md) | Task tracking |

---

## Quick Reference

### Essential Commands

```bash
# Run tests for helper modules
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/unit/helpers/ -v

# Check type hints
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run mypy tests/helpers/ tests/utils/

# Install optional dependency
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry add --group dev freezegun
```

### File Locations

| File | Purpose |
|------|---------|
| `tests/helpers/assertions.py` | Custom assertion functions |
| `tests/helpers/time.py` | Time manipulation utilities |
| `tests/helpers/api.py` | API testing helpers |
| `tests/helpers/mocks.py` | Mock builders |
| `tests/utils/builders.py` | Test data builders |
| `tests/helpers/__init__.py` | Helper exports |
| `tests/utils/__init__.py` | Utility exports |

---

**Document Version**: 1.1
**Created**: 2025-12-01
**Completed**: 2025-12-01
**Author**: Architecture Agent
**Status**: ✅ COMPLETED
**Priority**: Medium
**Actual Duration**: 2 hours
**QA Report**: [task-04.08-verification.md](../../qa/task-04.08-verification.md)
