# Task 04.05: Factory Classes for Test Data Generation - Technical Architecture Plan

**Document Version**: 1.1
**Created**: 2025-11-30
**Completed**: 2025-11-30
**Status**: ✅ COMPLETED
**Priority**: High (Enhancement to Test Infrastructure)
**Dependencies**: 04.01, 04.02, 04.03, 04.04 (All Completed)
**Type**: Architecture Documentation
**QA Report**: [task-04.05-verification.md](../../../qa/task-04.05-verification.md)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Current State Analysis](#2-current-state-analysis)
3. [Architecture Design](#3-architecture-design)
4. [Implementation Details](#4-implementation-details)
5. [Factory Specifications](#5-factory-specifications)
6. [Integration with Existing Infrastructure](#6-integration-with-existing-infrastructure)
7. [Test Plan](#7-test-plan)
8. [Implementation Checklist](#8-implementation-checklist)
9. [Acceptance Criteria](#9-acceptance-criteria)
10. [Troubleshooting Guide](#10-troubleshooting-guide)

---

## 1. Overview

### 1.1 Task Description

Implement factory classes using the `factory-boy` library to provide a more declarative, maintainable approach to test data generation. These factories will complement existing fixture infrastructure and provide advanced features like traits, SubFactories, LazyAttributes, and post-generation hooks.

### 1.2 Objectives

1. Add `factory-boy` dependency to the project
2. Create a `BaseFactory` class with async SQLAlchemy session support
3. Implement factories for all 8 SQLAlchemy models:
   - User, UserSettings, RefreshToken (Auth models)
   - Deck, Card (Content models)
   - UserDeckProgress, CardStatistics, Review (Progress models)
4. Support factory traits for common variations (admin user, inactive user, premium deck, etc.)
5. Integrate with existing `db_session` fixture
6. Support Greek vocabulary generation with Faker
7. Provide SM-2 algorithm state presets for CardStatistics

### 1.3 Why Factory-Boy?

**Current Approach (Manual Factory Functions)**:
```python
async def create_test_user(db_session, email=None, is_active=True, ...):
    if email is None:
        email = f"testuser_{uuid4().hex[:8]}@example.com"
    user = User(email=email, is_active=is_active, ...)
    db_session.add(user)
    await db_session.commit()
    return user
```

**Factory-Boy Approach**:
```python
class UserFactory(BaseFactory):
    class Meta:
        model = User

    email = LazyAttribute(lambda _: f"user_{uuid4().hex[:8]}@example.com")
    is_active = True

    class Params:
        admin = Trait(is_superuser=True, email_verified_at=factory.LazyFunction(datetime.utcnow))
        inactive = Trait(is_active=False)

# Usage
user = await UserFactory.create(db_session)
admin = await UserFactory.create(db_session, admin=True)
inactive_user = await UserFactory.create(db_session, inactive=True)
```

**Benefits**:
- **Declarative**: Model data structure is clear at a glance
- **Traits**: Reusable variations without parameter duplication
- **SubFactory**: Automatic related object creation
- **LazyAttribute**: Computed fields based on other attributes
- **Sequences**: Unique sequential values (email_1, email_2, etc.)
- **Post-generation hooks**: Complex setup after object creation
- **Build vs Create**: In-memory objects vs database-persisted

### 1.4 Success Criteria

- [ ] `factory-boy` >= 3.3 added to dev dependencies
- [ ] BaseFactory supports async SQLAlchemy sessions
- [ ] All 8 model factories implemented
- [ ] Traits for common variations (admin, inactive, etc.)
- [ ] SubFactories for relationships (User -> UserSettings)
- [ ] Greek vocabulary Faker provider integrated
- [ ] SM-2 state presets for CardStatistics
- [ ] All factory tests passing (20+ tests)
- [ ] Integration with existing db_session fixture verified

---

## 2. Current State Analysis

### 2.1 Existing Test Infrastructure

**From Task 04.02 (Database Fixtures)**:
```
tests/fixtures/database.py
- db_engine: Async PostgreSQL engine
- db_session: Async session with automatic rollback
- db_session_with_savepoint: Session with savepoint pattern
```

**From Task 04.03 (Base Test Classes)**:
```
tests/fixtures/auth.py - 17 fixtures for users, tokens, headers
tests/base.py - BaseTestCase and AuthenticatedTestCase
```

**From Task 04.04 (Domain Fixtures)**:
```
tests/fixtures/deck.py - Deck and card fixtures with Greek vocabulary
tests/fixtures/progress.py - Progress and review fixtures for SM-2
```

### 2.2 Current Factory Pattern

The existing codebase uses manual factory functions:

```python
# From tests/fixtures/auth.py
def create_test_user_data(
    email: str | None = None,
    password: str = "TestPassword123!",
    full_name: str = "Test User",
    is_active: bool = True,
    is_superuser: bool = False,
    email_verified: bool = False,
) -> dict[str, Any]:
    if email is None:
        email = f"testuser_{uuid4().hex[:8]}@example.com"
    return {
        "email": email,
        "password_hash": hash_password(password),
        ...
    }

async def create_user_with_settings(
    db_session: AsyncSession,
    user_data: dict[str, Any],
    ...
) -> User:
    user = User(**user_data)
    db_session.add(user)
    ...
```

### 2.3 Current Dependencies

From `pyproject.toml`:
```toml
[tool.poetry.group.dev.dependencies]
pytest = "^8.3.0"
pytest-asyncio = "^0.23.0"
faker = "^26.0.0"  # Already installed!
# factory-boy is NOT present - needs to be added
```

### 2.4 Models to Create Factories For

| Model | Fields | Relationships | Notes |
|-------|--------|---------------|-------|
| User | id, email, password_hash, full_name, is_active, is_superuser, email_verified_at, google_id | settings, refresh_tokens, deck_progress, card_statistics, reviews | Core auth model |
| UserSettings | id, user_id, daily_goal, email_notifications | user | One-to-one with User |
| RefreshToken | id, user_id, token, expires_at | user | Session management |
| Deck | id, name, description, level, is_active | cards, user_progress | Content container |
| Card | id, deck_id, front_text, back_text, example_sentence, pronunciation, difficulty, order_index | deck, statistics, reviews | Greek vocabulary |
| UserDeckProgress | id, user_id, deck_id, cards_studied, cards_mastered, last_studied_at | user, deck | Progress tracking |
| CardStatistics | id, user_id, card_id, easiness_factor, interval, repetitions, next_review_date, status | user, card | SM-2 algorithm |
| Review | id, user_id, card_id, quality, time_taken, reviewed_at | user, card | Review history |

---

## 3. Architecture Design

### 3.1 File Structure

```
tests/
├── factories/                      <- NEW DIRECTORY
│   ├── __init__.py                 <- Export all factories
│   ├── base.py                     <- BaseFactory with async support
│   ├── auth.py                     <- User, UserSettings, RefreshToken factories
│   ├── content.py                  <- Deck, Card factories
│   ├── progress.py                 <- UserDeckProgress, CardStatistics, Review factories
│   └── providers/                  <- Custom Faker providers
│       ├── __init__.py
│       └── greek.py                <- Greek vocabulary provider
├── fixtures/
│   ├── __init__.py                 <- UPDATE: Export factory fixtures
│   ├── database.py                 <- EXISTING
│   ├── auth.py                     <- EXISTING
│   ├── deck.py                     <- EXISTING
│   └── progress.py                 <- EXISTING
├── unit/
│   └── test_factories.py           <- NEW: Factory tests
└── conftest.py                     <- UPDATE: Register factory session
```

### 3.2 Factory Class Hierarchy

```
factory.Factory (from factory-boy)
    |
    +-- BaseFactory (custom)
    |       |
    |       +-- Async SQLAlchemy session support
    |       +-- Greek Faker provider registration
    |       +-- Common Meta options
    |       |
    |       v
    +-- UserFactory
    |       +-- Traits: admin, inactive, verified, oauth
    |       +-- SubFactory: UserSettingsFactory
    |
    +-- UserSettingsFactory
    |       +-- LazyAttribute: user_id from parent
    |
    +-- RefreshTokenFactory
    |       +-- SubFactory: UserFactory
    |       +-- LazyAttribute: token generation
    |
    +-- DeckFactory
    |       +-- Traits: inactive, a1, a2, b1, b2
    |       +-- LazyAttribute: level-based description
    |
    +-- CardFactory
    |       +-- SubFactory: DeckFactory
    |       +-- Greek vocabulary LazyAttributes
    |       +-- Sequence: order_index
    |
    +-- UserDeckProgressFactory
    |       +-- SubFactory: UserFactory, DeckFactory
    |       +-- Traits: fresh, completed, active
    |
    +-- CardStatisticsFactory
    |       +-- SubFactory: UserFactory, CardFactory
    |       +-- Traits: new, learning, review, mastered, due, overdue
    |       +-- SM-2 preset values
    |
    +-- ReviewFactory
            +-- SubFactory: UserFactory, CardFactory
            +-- Traits: perfect, failed, hesitant
```

### 3.3 Integration Pattern

Factories integrate with existing pytest fixtures via session binding:

```python
# In conftest.py
@pytest.fixture(autouse=True)
def bind_factory_session(db_session):
    """Bind the db_session to all factories."""
    BaseFactory._session = db_session
    yield
    BaseFactory._session = None
```

### 3.4 Design Decisions

1. **Async Support via Session Binding**
   - Factory-boy doesn't natively support async
   - We bind the async session to factories
   - Factory `create()` methods are wrapped as async

2. **Lazy SubFactories**
   - Related objects created only when needed
   - Prevents circular creation loops
   - Allows explicit parent object passing

3. **Traits over Parameters**
   - Common variations defined as traits
   - Cleaner test code: `UserFactory.create(admin=True)`
   - Composable: `UserFactory.create(admin=True, inactive=True)`

4. **Greek Vocabulary via Custom Provider**
   - Faker extended with Greek vocabulary provider
   - Provides realistic card content
   - CEFR level-appropriate words

---

## 4. Implementation Details

### 4.1 Step 1: Add factory-boy Dependency

**Command**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry add --group dev factory-boy
```

**Expected pyproject.toml change**:
```toml
[tool.poetry.group.dev.dependencies]
# ... existing ...
factory-boy = "^3.3.0"
```

### 4.2 Step 2: Create Greek Faker Provider

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/providers/__init__.py`

```python
"""Custom Faker providers for test data generation."""

from tests.factories.providers.greek import GreekProvider

__all__ = ["GreekProvider"]
```

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/providers/greek.py`

```python
"""Greek vocabulary Faker provider for test data generation.

This provider extends Faker with Greek language content appropriate
for a Greek language learning application.
"""

import random
from typing import Any

from faker.providers import BaseProvider


class GreekProvider(BaseProvider):
    """Faker provider for Greek vocabulary content.

    Provides Greek words, phrases, and sentences organized by CEFR level.

    Usage:
        fake = Faker()
        fake.add_provider(GreekProvider)

        word = fake.greek_word()
        card = fake.greek_vocabulary_card()
    """

    # A1 Level - Basic Greetings and Essential Words
    A1_VOCABULARY: list[dict[str, Any]] = [
        {
            "front_text": "Yeia sou",
            "back_text": "Hello (informal)",
            "pronunciation": "YAH-soo",
            "example_sentence": "Yeia sou, ti kaneis?",
        },
        {
            "front_text": "Kalimera",
            "back_text": "Good morning",
            "pronunciation": "kah-lee-MEH-rah",
            "example_sentence": "Kalimera! Pos eiste?",
        },
        {
            "front_text": "Efcharisto",
            "back_text": "Thank you",
            "pronunciation": "ef-hah-ree-STO",
            "example_sentence": "Efcharisto poli!",
        },
        {
            "front_text": "Parakalo",
            "back_text": "Please / You're welcome",
            "pronunciation": "pah-rah-kah-LO",
            "example_sentence": "Parakalo, boroume na pame?",
        },
        {
            "front_text": "Nero",
            "back_text": "Water",
            "pronunciation": "neh-RO",
            "example_sentence": "Thelo ena nero, parakalo.",
        },
        {
            "front_text": "Psomi",
            "back_text": "Bread",
            "pronunciation": "pso-MEE",
            "example_sentence": "To psomi einai fresko.",
        },
        {
            "front_text": "Spiti",
            "back_text": "House / Home",
            "pronunciation": "SPEE-tee",
            "example_sentence": "To spiti mou einai mikro.",
        },
        {
            "front_text": "Ena",
            "back_text": "One",
            "pronunciation": "EH-nah",
            "example_sentence": "Ena kafe, parakalo.",
        },
        {
            "front_text": "Dio",
            "back_text": "Two",
            "pronunciation": "THEE-oh",
            "example_sentence": "Dio nero, parakalo.",
        },
        {
            "front_text": "Tria",
            "back_text": "Three",
            "pronunciation": "TREE-ah",
            "example_sentence": "Tria adelfia echo.",
        },
    ]

    # A2 Level - Daily Life and Common Verbs
    A2_VOCABULARY: list[dict[str, Any]] = [
        {
            "front_text": "Troo",
            "back_text": "I eat",
            "pronunciation": "TRO-oh",
            "example_sentence": "Troo proino stis okto.",
        },
        {
            "front_text": "Pino",
            "back_text": "I drink",
            "pronunciation": "PEE-no",
            "example_sentence": "Pino kafe kathe proi.",
        },
        {
            "front_text": "Douleo",
            "back_text": "I work",
            "pronunciation": "thoo-LEH-vo",
            "example_sentence": "Douleo se ena grafeio.",
        },
        {
            "front_text": "Oikogeneia",
            "back_text": "Family",
            "pronunciation": "ee-ko-YEH-nee-ah",
            "example_sentence": "I oikogeneia mou einai megali.",
        },
        {
            "front_text": "Filo",
            "back_text": "Friend",
            "pronunciation": "FEE-lo",
            "example_sentence": "O Yiannis einai o filo mou.",
        },
    ]

    # B1 Level - Abstract Concepts
    B1_VOCABULARY: list[dict[str, Any]] = [
        {
            "front_text": "Agapi",
            "back_text": "Love",
            "pronunciation": "ah-GAH-pee",
            "example_sentence": "I agapi einai to pio simantiko pragma.",
        },
        {
            "front_text": "Elpida",
            "back_text": "Hope",
            "pronunciation": "el-PEE-thah",
            "example_sentence": "Echo elpida gia to mellon.",
        },
        {
            "front_text": "Epistimi",
            "back_text": "Science",
            "pronunciation": "eh-pee-STEE-mee",
            "example_sentence": "I epistimi proodeui synechos.",
        },
        {
            "front_text": "Politismos",
            "back_text": "Culture / Civilization",
            "pronunciation": "po-lee-tee-SMOS",
            "example_sentence": "O ellinikos politismos einai archaios.",
        },
        {
            "front_text": "Dimokratia",
            "back_text": "Democracy",
            "pronunciation": "thee-mo-krah-TEE-ah",
            "example_sentence": "I dimokratia gennithike stin Athina.",
        },
    ]

    VOCABULARY_BY_LEVEL = {
        "A1": A1_VOCABULARY,
        "A2": A2_VOCABULARY,
        "B1": B1_VOCABULARY,
    }

    def greek_word(self, level: str = "A1") -> str:
        """Generate a random Greek word for the given CEFR level.

        Args:
            level: CEFR level (A1, A2, B1)

        Returns:
            str: Greek word (front_text)
        """
        vocab_list = self.VOCABULARY_BY_LEVEL.get(level, self.A1_VOCABULARY)
        return random.choice(vocab_list)["front_text"]

    def greek_translation(self, level: str = "A1") -> str:
        """Generate a random English translation for the given CEFR level.

        Args:
            level: CEFR level (A1, A2, B1)

        Returns:
            str: English translation (back_text)
        """
        vocab_list = self.VOCABULARY_BY_LEVEL.get(level, self.A1_VOCABULARY)
        return random.choice(vocab_list)["back_text"]

    def greek_pronunciation(self, level: str = "A1") -> str:
        """Generate a random pronunciation guide for the given CEFR level.

        Args:
            level: CEFR level (A1, A2, B1)

        Returns:
            str: Phonetic pronunciation
        """
        vocab_list = self.VOCABULARY_BY_LEVEL.get(level, self.A1_VOCABULARY)
        return random.choice(vocab_list)["pronunciation"]

    def greek_example_sentence(self, level: str = "A1") -> str:
        """Generate a random example sentence for the given CEFR level.

        Args:
            level: CEFR level (A1, A2, B1)

        Returns:
            str: Example sentence in Greek
        """
        vocab_list = self.VOCABULARY_BY_LEVEL.get(level, self.A1_VOCABULARY)
        return random.choice(vocab_list)["example_sentence"]

    def greek_vocabulary_card(self, level: str = "A1") -> dict[str, Any]:
        """Generate a complete vocabulary card dictionary.

        Args:
            level: CEFR level (A1, A2, B1)

        Returns:
            dict: Complete card data with front_text, back_text, etc.
        """
        vocab_list = self.VOCABULARY_BY_LEVEL.get(level, self.A1_VOCABULARY)
        return random.choice(vocab_list).copy()

    def deck_name(self, level: str = "A1") -> str:
        """Generate a deck name for the given CEFR level.

        Args:
            level: CEFR level (A1-C2)

        Returns:
            str: Deck name
        """
        prefixes = ["Greek", "Essential Greek", "Learn Greek", "Greek Vocabulary"]
        suffixes = ["Basics", "Vocabulary", "Words", "Phrases", "Essentials"]

        prefix = random.choice(prefixes)
        suffix = random.choice(suffixes)

        return f"{prefix} {level} - {suffix}"

    def deck_description(self, level: str = "A1") -> str:
        """Generate a deck description for the given CEFR level.

        Args:
            level: CEFR level (A1-C2)

        Returns:
            str: Deck description
        """
        descriptions = {
            "A1": "Essential Greek words and phrases for beginners. Start your Greek journey here!",
            "A2": "Elementary Greek vocabulary for daily life situations.",
            "B1": "Intermediate Greek vocabulary and expressions for confident communication.",
            "B2": "Upper-intermediate Greek for advanced learners.",
            "C1": "Advanced Greek vocabulary, idioms, and complex expressions.",
            "C2": "Near-native Greek proficiency vocabulary and nuanced expressions.",
        }
        return descriptions.get(level, descriptions["A1"])
```

### 4.3 Step 3: Create BaseFactory

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/base.py`

```python
"""Base factory class with async SQLAlchemy support.

This module provides the foundation for all test factories:
- BaseFactory with async session management
- Faker configuration with Greek provider
- Common Meta options for all factories

Usage:
    class MyFactory(BaseFactory):
        class Meta:
            model = MyModel

        field = "value"

    # In tests (with db_session fixture)
    obj = await MyFactory.create()
"""

from datetime import datetime
from typing import Any, ClassVar, TypeVar
from uuid import uuid4

import factory
from faker import Faker
from sqlalchemy.ext.asyncio import AsyncSession

from tests.factories.providers.greek import GreekProvider

# Configure Faker with Greek provider
fake = Faker()
fake.add_provider(GreekProvider)

T = TypeVar("T")


class BaseFactory(factory.Factory):
    """Base factory class for all model factories.

    Provides:
    - Async SQLAlchemy session binding
    - Faker instance with Greek provider
    - Common Meta options
    - Async create/build methods

    All factories should inherit from this class.

    Attributes:
        _session: Class-level async session (bound via fixture)
        fake: Faker instance with Greek provider

    Example:
        class UserFactory(BaseFactory):
            class Meta:
                model = User

            email = factory.LazyAttribute(lambda _: f"user_{uuid4().hex[:8]}@example.com")

        # Usage
        user = await UserFactory.create()
    """

    # Class-level session storage (set by fixture)
    _session: ClassVar[AsyncSession | None] = None

    # Faker instance for all factories
    fake: ClassVar[Faker] = fake

    class Meta:
        """Factory meta options."""
        abstract = True

    @classmethod
    def _create(cls, model_class: type[T], *args: Any, **kwargs: Any) -> T:
        """Create a model instance.

        This method is called by factory.create(). For async support,
        we create the instance and add it to the session, but commit
        must be handled separately.

        Args:
            model_class: The model class to instantiate
            *args: Positional arguments (unused)
            **kwargs: Model field values

        Returns:
            Model instance (uncommitted)
        """
        instance = model_class(**kwargs)
        return instance

    @classmethod
    async def create(cls, session: AsyncSession | None = None, **kwargs: Any) -> T:
        """Create and persist a model instance asynchronously.

        Args:
            session: Optional AsyncSession (uses bound session if not provided)
            **kwargs: Field overrides

        Returns:
            Persisted model instance

        Raises:
            ValueError: If no session is available
        """
        db_session = session or cls._session
        if db_session is None:
            raise ValueError(
                "No database session available. Either pass session parameter "
                "or ensure the factory session fixture is active."
            )

        # Build the instance using factory-boy
        instance = cls.build(**kwargs)

        # Add to session and commit
        db_session.add(instance)
        await db_session.flush()  # Get ID assigned
        await db_session.refresh(instance)

        return instance

    @classmethod
    async def create_batch(
        cls,
        size: int,
        session: AsyncSession | None = None,
        **kwargs: Any,
    ) -> list[T]:
        """Create multiple model instances asynchronously.

        Args:
            size: Number of instances to create
            session: Optional AsyncSession
            **kwargs: Field overrides (applied to all instances)

        Returns:
            List of persisted model instances
        """
        instances = []
        for _ in range(size):
            instance = await cls.create(session=session, **kwargs)
            instances.append(instance)
        return instances

    @classmethod
    def build(cls, **kwargs: Any) -> T:
        """Build a model instance without persisting.

        Args:
            **kwargs: Field overrides

        Returns:
            Model instance (not added to session)
        """
        return super().build(**kwargs)

    @classmethod
    def build_batch(cls, size: int, **kwargs: Any) -> list[T]:
        """Build multiple model instances without persisting.

        Args:
            size: Number of instances to build
            **kwargs: Field overrides

        Returns:
            List of model instances
        """
        return super().build_batch(size, **kwargs)


# =============================================================================
# Utility Functions
# =============================================================================


def unique_email() -> str:
    """Generate a unique email address.

    Returns:
        str: Unique email like "user_a1b2c3d4@example.com"
    """
    return f"user_{uuid4().hex[:8]}@example.com"


def unique_token() -> str:
    """Generate a unique token string.

    Returns:
        str: UUID-based token string
    """
    return str(uuid4())


def utc_now() -> datetime:
    """Get current UTC datetime.

    Returns:
        datetime: Current UTC time
    """
    return datetime.utcnow()
```

### 4.4 Step 4: Create Auth Factories

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/auth.py`

```python
"""Authentication model factories.

This module provides factories for authentication-related models:
- UserFactory: User accounts with various traits
- UserSettingsFactory: User preferences
- RefreshTokenFactory: JWT refresh tokens

Usage:
    # Create a regular user
    user = await UserFactory.create()

    # Create an admin user
    admin = await UserFactory.create(admin=True)

    # Create an inactive user
    inactive = await UserFactory.create(inactive=True)

    # Create user with custom settings
    user = await UserFactory.create()
    settings = await UserSettingsFactory.create(user_id=user.id, daily_goal=50)
"""

from datetime import datetime, timedelta
from uuid import uuid4

import factory
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.security import create_refresh_token, hash_password
from src.db.models import RefreshToken, User, UserSettings
from tests.factories.base import BaseFactory, unique_email, unique_token, utc_now


class UserFactory(BaseFactory):
    """Factory for User model.

    Creates test users with configurable attributes.

    Traits:
        admin: Superuser with verified email
        inactive: Deactivated account
        verified: Email verified
        oauth: Google OAuth user (no password)

    Example:
        user = await UserFactory.create()
        admin = await UserFactory.create(admin=True)
        inactive_admin = await UserFactory.create(admin=True, inactive=True)
    """

    class Meta:
        model = User

    # Default values
    email = factory.LazyFunction(unique_email)
    password_hash = factory.LazyAttribute(lambda _: hash_password("TestPassword123!"))
    full_name = factory.Faker("name")
    is_active = True
    is_superuser = False
    email_verified_at = None
    google_id = None
    last_login_at = None
    last_login_ip = None

    class Params:
        """Factory traits for common variations."""

        # Admin/superuser trait
        admin = factory.Trait(
            is_superuser=True,
            email_verified_at=factory.LazyFunction(utc_now),
            full_name="Admin User",
        )

        # Inactive user trait
        inactive = factory.Trait(
            is_active=False,
        )

        # Verified email trait
        verified = factory.Trait(
            email_verified_at=factory.LazyFunction(utc_now),
        )

        # OAuth user trait (no password)
        oauth = factory.Trait(
            password_hash=None,
            google_id=factory.LazyFunction(lambda: f"google_{uuid4().hex}"),
            email_verified_at=factory.LazyFunction(utc_now),
        )

        # Recently logged in
        logged_in = factory.Trait(
            last_login_at=factory.LazyFunction(utc_now),
            last_login_ip="127.0.0.1",
        )

    @classmethod
    async def create_with_settings(
        cls,
        session: AsyncSession | None = None,
        daily_goal: int = 20,
        email_notifications: bool = True,
        **kwargs,
    ) -> User:
        """Create a user with associated settings.

        This is a convenience method that creates both User and UserSettings.

        Args:
            session: Database session
            daily_goal: User's daily goal
            email_notifications: Email notification preference
            **kwargs: User field overrides

        Returns:
            User with settings relationship populated
        """
        user = await cls.create(session=session, **kwargs)

        db_session = session or cls._session
        settings = UserSettings(
            user_id=user.id,
            daily_goal=daily_goal,
            email_notifications=email_notifications,
        )
        db_session.add(settings)
        await db_session.flush()
        await db_session.refresh(user)

        return user


class UserSettingsFactory(BaseFactory):
    """Factory for UserSettings model.

    Creates user preference records.

    Note: Usually created via UserFactory.create_with_settings()
          for proper User-Settings relationship.

    Example:
        settings = await UserSettingsFactory.create(user_id=user.id)
    """

    class Meta:
        model = UserSettings

    # Required: Must be provided or use SubFactory
    user_id = None  # Must be set explicitly

    # Default settings
    daily_goal = 20
    email_notifications = True

    class Params:
        """Factory traits for common variations."""

        # High achiever - increased daily goal
        high_achiever = factory.Trait(
            daily_goal=50,
        )

        # No notifications
        quiet = factory.Trait(
            email_notifications=False,
        )


class RefreshTokenFactory(BaseFactory):
    """Factory for RefreshToken model.

    Creates JWT refresh tokens for session management testing.

    Traits:
        expired: Token with past expiration

    Example:
        token = await RefreshTokenFactory.create(user_id=user.id)
        expired_token = await RefreshTokenFactory.create(user_id=user.id, expired=True)
    """

    class Meta:
        model = RefreshToken

    # Required: Must be provided
    user_id = None  # Must be set explicitly

    # Token data
    token = factory.LazyFunction(unique_token)
    expires_at = factory.LazyFunction(lambda: utc_now() + timedelta(days=7))

    class Params:
        """Factory traits for common variations."""

        # Expired token
        expired = factory.Trait(
            expires_at=factory.LazyFunction(lambda: utc_now() - timedelta(hours=1)),
        )

        # Soon to expire (within 1 hour)
        expiring_soon = factory.Trait(
            expires_at=factory.LazyFunction(lambda: utc_now() + timedelta(minutes=30)),
        )

    @classmethod
    async def create_for_user(
        cls,
        user: User,
        session: AsyncSession | None = None,
        **kwargs,
    ) -> tuple[RefreshToken, str]:
        """Create a refresh token for a user with the actual JWT.

        Uses the application's create_refresh_token function.

        Args:
            user: User to create token for
            session: Database session
            **kwargs: Field overrides

        Returns:
            Tuple of (RefreshToken model, JWT string)
        """
        jwt_token, expires_at = create_refresh_token(user.id)

        db_token = await cls.create(
            session=session,
            user_id=user.id,
            token=jwt_token,
            expires_at=expires_at,
            **kwargs,
        )

        return db_token, jwt_token
```

### 4.5 Step 5: Create Content Factories

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/content.py`

```python
"""Content model factories.

This module provides factories for content-related models:
- DeckFactory: Flashcard decks with CEFR levels
- CardFactory: Individual flashcards with Greek vocabulary

Usage:
    # Create an A1 deck
    deck = await DeckFactory.create()

    # Create a B2 deck
    deck = await DeckFactory.create(b2=True)

    # Create a card for a deck
    card = await CardFactory.create(deck_id=deck.id)

    # Create deck with cards
    deck, cards = await DeckFactory.create_with_cards(card_count=10)
"""

import factory
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import Card, CardDifficulty, Deck, DeckLevel
from tests.factories.base import BaseFactory


class DeckFactory(BaseFactory):
    """Factory for Deck model.

    Creates flashcard decks with configurable CEFR levels.

    Traits:
        inactive: Deactivated deck
        a1, a2, b1, b2, c1, c2: CEFR level presets

    Example:
        deck = await DeckFactory.create()  # Default A1
        b2_deck = await DeckFactory.create(b2=True)
        inactive_deck = await DeckFactory.create(inactive=True)
    """

    class Meta:
        model = Deck

    # Default values
    name = factory.LazyAttribute(
        lambda obj: BaseFactory.fake.deck_name(obj.level.value if hasattr(obj, 'level') else "A1")
    )
    description = factory.LazyAttribute(
        lambda obj: BaseFactory.fake.deck_description(obj.level.value if hasattr(obj, 'level') else "A1")
    )
    level = DeckLevel.A1
    is_active = True

    class Params:
        """Factory traits for common variations."""

        # Inactive deck
        inactive = factory.Trait(
            is_active=False,
        )

        # CEFR Level traits
        a1 = factory.Trait(
            level=DeckLevel.A1,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("A1")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("A1")),
        )

        a2 = factory.Trait(
            level=DeckLevel.A2,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("A2")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("A2")),
        )

        b1 = factory.Trait(
            level=DeckLevel.B1,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("B1")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("B1")),
        )

        b2 = factory.Trait(
            level=DeckLevel.B2,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("B2")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("B2")),
        )

        c1 = factory.Trait(
            level=DeckLevel.C1,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("C1")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("C1")),
        )

        c2 = factory.Trait(
            level=DeckLevel.C2,
            name=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_name("C2")),
            description=factory.LazyAttribute(lambda _: BaseFactory.fake.deck_description("C2")),
        )

    @classmethod
    async def create_with_cards(
        cls,
        session: AsyncSession | None = None,
        card_count: int = 5,
        **kwargs,
    ) -> tuple[Deck, list[Card]]:
        """Create a deck with multiple cards.

        Args:
            session: Database session
            card_count: Number of cards to create
            **kwargs: Deck field overrides

        Returns:
            Tuple of (Deck, list of Cards)
        """
        deck = await cls.create(session=session, **kwargs)

        cards = []
        level = deck.level.value if deck.level else "A1"

        for i in range(card_count):
            card = await CardFactory.create(
                session=session,
                deck_id=deck.id,
                order_index=i,
                # Use level-appropriate vocabulary
            )
            cards.append(card)

        return deck, cards


class CardFactory(BaseFactory):
    """Factory for Card model.

    Creates flashcards with Greek vocabulary content.

    Traits:
        easy, medium, hard: Difficulty levels

    Example:
        card = await CardFactory.create(deck_id=deck.id)
        easy_card = await CardFactory.create(deck_id=deck.id, easy=True)
    """

    class Meta:
        model = Card

    # Required: Must be provided
    deck_id = None  # Must be set explicitly

    # Greek vocabulary from Faker provider
    front_text = factory.LazyAttribute(lambda _: BaseFactory.fake.greek_word("A1"))
    back_text = factory.LazyAttribute(lambda _: BaseFactory.fake.greek_translation("A1"))
    pronunciation = factory.LazyAttribute(lambda _: BaseFactory.fake.greek_pronunciation("A1"))
    example_sentence = factory.LazyAttribute(lambda _: BaseFactory.fake.greek_example_sentence("A1"))

    # Metadata
    difficulty = CardDifficulty.MEDIUM
    order_index = factory.Sequence(lambda n: n)

    class Params:
        """Factory traits for common variations."""

        # Difficulty traits
        easy = factory.Trait(
            difficulty=CardDifficulty.EASY,
        )

        medium = factory.Trait(
            difficulty=CardDifficulty.MEDIUM,
        )

        hard = factory.Trait(
            difficulty=CardDifficulty.HARD,
        )

        # Minimal card (no optional fields)
        minimal = factory.Trait(
            pronunciation=None,
            example_sentence=None,
        )

    @classmethod
    async def create_vocabulary_card(
        cls,
        deck_id,
        level: str = "A1",
        session: AsyncSession | None = None,
        **kwargs,
    ) -> Card:
        """Create a card with level-appropriate vocabulary.

        Args:
            deck_id: ID of parent deck
            level: CEFR level for vocabulary selection
            session: Database session
            **kwargs: Field overrides

        Returns:
            Card with Greek vocabulary
        """
        vocab = BaseFactory.fake.greek_vocabulary_card(level)

        return await cls.create(
            session=session,
            deck_id=deck_id,
            front_text=vocab["front_text"],
            back_text=vocab["back_text"],
            pronunciation=vocab.get("pronunciation"),
            example_sentence=vocab.get("example_sentence"),
            **kwargs,
        )
```

### 4.6 Step 6: Create Progress Factories

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/progress.py`

```python
"""Progress tracking model factories.

This module provides factories for progress-related models:
- UserDeckProgressFactory: User progress on decks
- CardStatisticsFactory: SM-2 algorithm statistics
- ReviewFactory: Individual review records

Usage:
    # Create progress for a user on a deck
    progress = await UserDeckProgressFactory.create(user_id=user.id, deck_id=deck.id)

    # Create SM-2 statistics for a card
    stats = await CardStatisticsFactory.create(user_id=user.id, card_id=card.id)

    # Create mastered card statistics
    mastered_stats = await CardStatisticsFactory.create(
        user_id=user.id, card_id=card.id, mastered=True
    )

    # Create a review
    review = await ReviewFactory.create(user_id=user.id, card_id=card.id)
"""

from datetime import date, datetime, timedelta

import factory
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import (
    CardStatistics,
    CardStatus,
    Review,
    ReviewRating,
    UserDeckProgress,
)
from tests.factories.base import BaseFactory, utc_now


# =============================================================================
# SM-2 Algorithm Constants
# =============================================================================

SM2_DEFAULT_EASINESS_FACTOR = 2.5
SM2_MIN_EASINESS_FACTOR = 1.3

SM2_INTERVALS = {
    "first_success": 1,    # 1 day after first successful review
    "second_success": 6,   # 6 days after second success
    "learning": 1,         # Learning phase interval
    "review": 10,          # Typical review interval
    "mastered": 30,        # Mastered card interval
}


class UserDeckProgressFactory(BaseFactory):
    """Factory for UserDeckProgress model.

    Creates user progress records for deck study tracking.

    Traits:
        fresh: New user, no progress
        active: Some cards studied
        completed: All cards mastered

    Example:
        progress = await UserDeckProgressFactory.create(
            user_id=user.id, deck_id=deck.id
        )
        fresh = await UserDeckProgressFactory.create(
            user_id=user.id, deck_id=deck.id, fresh=True
        )
    """

    class Meta:
        model = UserDeckProgress

    # Required: Must be provided
    user_id = None  # Must be set explicitly
    deck_id = None  # Must be set explicitly

    # Default values
    cards_studied = 5
    cards_mastered = 2
    last_studied_at = factory.LazyFunction(utc_now)

    class Params:
        """Factory traits for common variations."""

        # Fresh progress (new user)
        fresh = factory.Trait(
            cards_studied=0,
            cards_mastered=0,
            last_studied_at=None,
        )

        # Active learner
        active = factory.Trait(
            cards_studied=10,
            cards_mastered=3,
            last_studied_at=factory.LazyFunction(utc_now),
        )

        # Completed deck
        completed = factory.Trait(
            cards_studied=50,
            cards_mastered=50,
            last_studied_at=factory.LazyFunction(utc_now),
        )

        # Stale progress (hasn't studied recently)
        stale = factory.Trait(
            last_studied_at=factory.LazyFunction(
                lambda: utc_now() - timedelta(days=30)
            ),
        )


class CardStatisticsFactory(BaseFactory):
    """Factory for CardStatistics model (SM-2 algorithm).

    Creates card statistics for spaced repetition testing.

    Traits:
        new: Never reviewed (NEW status)
        learning: In learning phase (LEARNING status)
        review: In review phase (REVIEW status)
        mastered: Fully mastered (MASTERED status)
        due: Due for review today
        overdue: Past due date

    Example:
        # New card
        stats = await CardStatisticsFactory.create(
            user_id=user.id, card_id=card.id, new=True
        )

        # Mastered card
        mastered = await CardStatisticsFactory.create(
            user_id=user.id, card_id=card.id, mastered=True
        )

        # Due for review today
        due = await CardStatisticsFactory.create(
            user_id=user.id, card_id=card.id, due=True
        )
    """

    class Meta:
        model = CardStatistics

    # Required: Must be provided
    user_id = None  # Must be set explicitly
    card_id = None  # Must be set explicitly

    # Default SM-2 values (card in learning phase)
    easiness_factor = SM2_DEFAULT_EASINESS_FACTOR
    interval = 1
    repetitions = 1
    next_review_date = factory.LazyFunction(lambda: date.today() + timedelta(days=1))
    status = CardStatus.LEARNING

    class Params:
        """Factory traits for SM-2 states."""

        # NEW: Never reviewed
        new = factory.Trait(
            easiness_factor=SM2_DEFAULT_EASINESS_FACTOR,
            interval=0,
            repetitions=0,
            next_review_date=factory.LazyFunction(date.today),
            status=CardStatus.NEW,
        )

        # LEARNING: In initial learning phase
        learning = factory.Trait(
            easiness_factor=2.36,  # Slightly decreased from reviews
            interval=SM2_INTERVALS["learning"],
            repetitions=2,
            next_review_date=factory.LazyFunction(
                lambda: date.today() + timedelta(days=1)
            ),
            status=CardStatus.LEARNING,
        )

        # REVIEW: Graduated to review phase
        review = factory.Trait(
            easiness_factor=SM2_DEFAULT_EASINESS_FACTOR,
            interval=SM2_INTERVALS["review"],
            repetitions=5,
            next_review_date=factory.LazyFunction(
                lambda: date.today() + timedelta(days=10)
            ),
            status=CardStatus.REVIEW,
        )

        # MASTERED: Fully mastered
        mastered = factory.Trait(
            easiness_factor=2.7,  # Increased from consistent success
            interval=SM2_INTERVALS["mastered"],
            repetitions=10,
            next_review_date=factory.LazyFunction(
                lambda: date.today() + timedelta(days=30)
            ),
            status=CardStatus.MASTERED,
        )

        # Due for review today
        due = factory.Trait(
            easiness_factor=SM2_DEFAULT_EASINESS_FACTOR,
            interval=5,
            repetitions=3,
            next_review_date=factory.LazyFunction(date.today),
            status=CardStatus.REVIEW,
        )

        # Overdue (past due date)
        overdue = factory.Trait(
            easiness_factor=SM2_DEFAULT_EASINESS_FACTOR,
            interval=5,
            repetitions=3,
            next_review_date=factory.LazyFunction(
                lambda: date.today() - timedelta(days=3)
            ),
            status=CardStatus.REVIEW,
        )

        # Struggling card (low EF)
        struggling = factory.Trait(
            easiness_factor=SM2_MIN_EASINESS_FACTOR,
            interval=1,
            repetitions=1,
            status=CardStatus.LEARNING,
        )


class ReviewFactory(BaseFactory):
    """Factory for Review model.

    Creates individual review records for analytics testing.

    Traits:
        perfect: Perfect recall (quality=5)
        failed: Complete blackout (quality=0)
        hesitant: Correct but hesitant (quality=4)
        hard: Correct but difficult (quality=3)

    Example:
        review = await ReviewFactory.create(user_id=user.id, card_id=card.id)
        perfect = await ReviewFactory.create(
            user_id=user.id, card_id=card.id, perfect=True
        )
    """

    class Meta:
        model = Review

    # Required: Must be provided
    user_id = None  # Must be set explicitly
    card_id = None  # Must be set explicitly

    # Default values
    quality = ReviewRating.CORRECT_HESITANT  # 4
    time_taken = 5  # seconds
    reviewed_at = factory.LazyFunction(utc_now)

    class Params:
        """Factory traits for review qualities."""

        # Perfect recall
        perfect = factory.Trait(
            quality=ReviewRating.PERFECT,  # 5
            time_taken=2,  # Quick response
        )

        # Complete blackout
        failed = factory.Trait(
            quality=ReviewRating.BLACKOUT,  # 0
            time_taken=15,  # Long time trying to remember
        )

        # Incorrect but easy to recall
        incorrect_easy = factory.Trait(
            quality=ReviewRating.INCORRECT_EASY,  # 2
            time_taken=8,
        )

        # Correct but difficult
        hard = factory.Trait(
            quality=ReviewRating.CORRECT_HARD,  # 3
            time_taken=10,
        )

        # Correct with hesitation
        hesitant = factory.Trait(
            quality=ReviewRating.CORRECT_HESITANT,  # 4
            time_taken=6,
        )

    @classmethod
    async def create_history(
        cls,
        user_id,
        card_id,
        ratings: list[int],
        session: AsyncSession | None = None,
        start_date: datetime | None = None,
    ) -> list[Review]:
        """Create a series of reviews for a card.

        Args:
            user_id: User ID
            card_id: Card ID
            ratings: List of quality ratings in chronological order
            session: Database session
            start_date: First review date (defaults to 30 days ago)

        Returns:
            List of Review records
        """
        if start_date is None:
            start_date = utc_now() - timedelta(days=30)

        reviews = []
        current_date = start_date

        for i, rating in enumerate(ratings):
            review = await cls.create(
                session=session,
                user_id=user_id,
                card_id=card_id,
                quality=rating,
                time_taken=3 + i,  # Varying time
                reviewed_at=current_date,
            )
            reviews.append(review)
            # Space reviews by increasing intervals
            current_date += timedelta(days=max(1, i * 2))

        return reviews
```

### 4.7 Step 7: Create Factory Package Init

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/factories/__init__.py`

```python
"""Test factories package.

This package provides factory-boy based factories for test data generation:

Auth Factories:
    - UserFactory: User accounts with traits (admin, inactive, verified, oauth)
    - UserSettingsFactory: User preferences
    - RefreshTokenFactory: JWT refresh tokens

Content Factories:
    - DeckFactory: Flashcard decks with CEFR level traits
    - CardFactory: Flashcards with Greek vocabulary

Progress Factories:
    - UserDeckProgressFactory: User progress on decks
    - CardStatisticsFactory: SM-2 algorithm statistics with state traits
    - ReviewFactory: Individual review records

Custom Providers:
    - GreekProvider: Faker provider for Greek vocabulary

Usage:
    from tests.factories import UserFactory, DeckFactory, CardFactory

    # Create a user
    user = await UserFactory.create()

    # Create an admin
    admin = await UserFactory.create(admin=True)

    # Create a deck with cards
    deck, cards = await DeckFactory.create_with_cards(card_count=10)

    # Create SM-2 statistics
    stats = await CardStatisticsFactory.create(
        user_id=user.id, card_id=card.id, mastered=True
    )

Note: All factories require a database session. Either pass it explicitly
or use the factory_session fixture which binds the session automatically.
"""

# Base factory
from tests.factories.base import BaseFactory, unique_email, unique_token, utc_now

# Auth factories
from tests.factories.auth import (
    RefreshTokenFactory,
    UserFactory,
    UserSettingsFactory,
)

# Content factories
from tests.factories.content import CardFactory, DeckFactory

# Progress factories
from tests.factories.progress import (
    SM2_DEFAULT_EASINESS_FACTOR,
    SM2_INTERVALS,
    SM2_MIN_EASINESS_FACTOR,
    CardStatisticsFactory,
    ReviewFactory,
    UserDeckProgressFactory,
)

# Custom Faker providers
from tests.factories.providers import GreekProvider

__all__ = [
    # Base
    "BaseFactory",
    "unique_email",
    "unique_token",
    "utc_now",
    # Auth
    "UserFactory",
    "UserSettingsFactory",
    "RefreshTokenFactory",
    # Content
    "DeckFactory",
    "CardFactory",
    # Progress
    "UserDeckProgressFactory",
    "CardStatisticsFactory",
    "ReviewFactory",
    # Constants
    "SM2_DEFAULT_EASINESS_FACTOR",
    "SM2_MIN_EASINESS_FACTOR",
    "SM2_INTERVALS",
    # Providers
    "GreekProvider",
]
```

### 4.8 Step 8: Update conftest.py with Factory Session Binding

**Add to**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/conftest.py`

```python
# Add these imports at the top
from tests.factories.base import BaseFactory

# Add this fixture
@pytest.fixture(autouse=True)
def bind_factory_session(db_session):
    """Bind the database session to all factories.

    This fixture automatically binds the db_session to BaseFactory,
    making it available to all factory classes that inherit from it.

    The binding is done before each test and cleared after.
    """
    BaseFactory._session = db_session
    yield
    BaseFactory._session = None
```

### 4.9 Step 9: Create Factory Tests

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/unit/test_factories.py`

```python
"""Tests for factory classes.

This module verifies that all factories:
- Create valid model instances
- Support traits correctly
- Handle async session properly
- Generate appropriate Greek vocabulary
- Create proper SM-2 statistics
"""

from datetime import date, timedelta

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import (
    Card,
    CardDifficulty,
    CardStatistics,
    CardStatus,
    Deck,
    DeckLevel,
    RefreshToken,
    Review,
    ReviewRating,
    User,
    UserDeckProgress,
    UserSettings,
)
from tests.factories import (
    CardFactory,
    CardStatisticsFactory,
    DeckFactory,
    RefreshTokenFactory,
    ReviewFactory,
    SM2_DEFAULT_EASINESS_FACTOR,
    SM2_MIN_EASINESS_FACTOR,
    UserDeckProgressFactory,
    UserFactory,
    UserSettingsFactory,
)


# =============================================================================
# UserFactory Tests
# =============================================================================


class TestUserFactory:
    """Tests for UserFactory."""

    async def test_create_basic_user(self, db_session: AsyncSession):
        """Test creating a basic user."""
        user = await UserFactory.create(session=db_session)

        assert user is not None
        assert user.id is not None
        assert user.email is not None
        assert "@example.com" in user.email
        assert user.is_active is True
        assert user.is_superuser is False
        assert user.password_hash is not None

    async def test_create_admin_user(self, db_session: AsyncSession):
        """Test creating an admin user with trait."""
        user = await UserFactory.create(session=db_session, admin=True)

        assert user.is_superuser is True
        assert user.email_verified_at is not None

    async def test_create_inactive_user(self, db_session: AsyncSession):
        """Test creating an inactive user with trait."""
        user = await UserFactory.create(session=db_session, inactive=True)

        assert user.is_active is False

    async def test_create_verified_user(self, db_session: AsyncSession):
        """Test creating a verified user with trait."""
        user = await UserFactory.create(session=db_session, verified=True)

        assert user.email_verified_at is not None

    async def test_create_oauth_user(self, db_session: AsyncSession):
        """Test creating an OAuth user with trait."""
        user = await UserFactory.create(session=db_session, oauth=True)

        assert user.password_hash is None
        assert user.google_id is not None
        assert user.email_verified_at is not None

    async def test_compose_traits(self, db_session: AsyncSession):
        """Test composing multiple traits."""
        user = await UserFactory.create(
            session=db_session, admin=True, logged_in=True
        )

        assert user.is_superuser is True
        assert user.last_login_at is not None
        assert user.last_login_ip is not None

    async def test_create_with_settings(self, db_session: AsyncSession):
        """Test creating user with settings."""
        user = await UserFactory.create_with_settings(
            session=db_session, daily_goal=50
        )

        assert user is not None
        assert user.settings is not None
        assert user.settings.daily_goal == 50

    async def test_create_batch(self, db_session: AsyncSession):
        """Test creating multiple users."""
        users = await UserFactory.create_batch(3, session=db_session)

        assert len(users) == 3
        emails = [u.email for u in users]
        assert len(set(emails)) == 3  # All unique

    async def test_build_without_persist(self, db_session: AsyncSession):
        """Test building user without persisting."""
        user = UserFactory.build()

        assert user.id is None  # Not persisted
        assert user.email is not None


# =============================================================================
# UserSettingsFactory Tests
# =============================================================================


class TestUserSettingsFactory:
    """Tests for UserSettingsFactory."""

    async def test_create_settings(self, db_session: AsyncSession):
        """Test creating user settings."""
        user = await UserFactory.create(session=db_session)
        settings = await UserSettingsFactory.create(
            session=db_session, user_id=user.id
        )

        assert settings is not None
        assert settings.user_id == user.id
        assert settings.daily_goal == 20  # Default

    async def test_high_achiever_trait(self, db_session: AsyncSession):
        """Test high achiever settings trait."""
        user = await UserFactory.create(session=db_session)
        settings = await UserSettingsFactory.create(
            session=db_session, user_id=user.id, high_achiever=True
        )

        assert settings.daily_goal == 50

    async def test_quiet_trait(self, db_session: AsyncSession):
        """Test quiet settings trait."""
        user = await UserFactory.create(session=db_session)
        settings = await UserSettingsFactory.create(
            session=db_session, user_id=user.id, quiet=True
        )

        assert settings.email_notifications is False


# =============================================================================
# RefreshTokenFactory Tests
# =============================================================================


class TestRefreshTokenFactory:
    """Tests for RefreshTokenFactory."""

    async def test_create_token(self, db_session: AsyncSession):
        """Test creating a refresh token."""
        user = await UserFactory.create(session=db_session)
        token = await RefreshTokenFactory.create(
            session=db_session, user_id=user.id
        )

        assert token is not None
        assert token.user_id == user.id
        assert token.token is not None
        assert token.expires_at is not None

    async def test_expired_trait(self, db_session: AsyncSession):
        """Test creating an expired token."""
        user = await UserFactory.create(session=db_session)
        token = await RefreshTokenFactory.create(
            session=db_session, user_id=user.id, expired=True
        )

        from tests.factories.base import utc_now
        assert token.expires_at < utc_now()


# =============================================================================
# DeckFactory Tests
# =============================================================================


class TestDeckFactory:
    """Tests for DeckFactory."""

    async def test_create_basic_deck(self, db_session: AsyncSession):
        """Test creating a basic deck."""
        deck = await DeckFactory.create(session=db_session)

        assert deck is not None
        assert deck.id is not None
        assert deck.name is not None
        assert deck.level == DeckLevel.A1  # Default
        assert deck.is_active is True

    async def test_create_inactive_deck(self, db_session: AsyncSession):
        """Test creating an inactive deck."""
        deck = await DeckFactory.create(session=db_session, inactive=True)

        assert deck.is_active is False

    async def test_level_traits(self, db_session: AsyncSession):
        """Test CEFR level traits."""
        a2_deck = await DeckFactory.create(session=db_session, a2=True)
        b1_deck = await DeckFactory.create(session=db_session, b1=True)

        assert a2_deck.level == DeckLevel.A2
        assert b1_deck.level == DeckLevel.B1

    async def test_create_with_cards(self, db_session: AsyncSession):
        """Test creating a deck with cards."""
        deck, cards = await DeckFactory.create_with_cards(
            session=db_session, card_count=5
        )

        assert deck is not None
        assert len(cards) == 5
        for card in cards:
            assert card.deck_id == deck.id


# =============================================================================
# CardFactory Tests
# =============================================================================


class TestCardFactory:
    """Tests for CardFactory."""

    async def test_create_basic_card(self, db_session: AsyncSession):
        """Test creating a basic card."""
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        assert card is not None
        assert card.deck_id == deck.id
        assert card.front_text is not None  # Greek word
        assert card.back_text is not None  # English translation
        assert card.difficulty == CardDifficulty.MEDIUM  # Default

    async def test_difficulty_traits(self, db_session: AsyncSession):
        """Test difficulty level traits."""
        deck = await DeckFactory.create(session=db_session)

        easy = await CardFactory.create(session=db_session, deck_id=deck.id, easy=True)
        hard = await CardFactory.create(session=db_session, deck_id=deck.id, hard=True)

        assert easy.difficulty == CardDifficulty.EASY
        assert hard.difficulty == CardDifficulty.HARD

    async def test_minimal_trait(self, db_session: AsyncSession):
        """Test minimal card trait."""
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(
            session=db_session, deck_id=deck.id, minimal=True
        )

        assert card.pronunciation is None
        assert card.example_sentence is None

    async def test_order_index_sequence(self, db_session: AsyncSession):
        """Test that order_index is sequential."""
        deck = await DeckFactory.create(session=db_session)

        cards = await CardFactory.create_batch(
            3, session=db_session, deck_id=deck.id
        )

        indices = [c.order_index for c in cards]
        assert len(set(indices)) == 3  # All unique


# =============================================================================
# UserDeckProgressFactory Tests
# =============================================================================


class TestUserDeckProgressFactory:
    """Tests for UserDeckProgressFactory."""

    async def test_create_progress(self, db_session: AsyncSession):
        """Test creating deck progress."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)

        progress = await UserDeckProgressFactory.create(
            session=db_session, user_id=user.id, deck_id=deck.id
        )

        assert progress is not None
        assert progress.user_id == user.id
        assert progress.deck_id == deck.id
        assert progress.cards_studied >= 0

    async def test_fresh_trait(self, db_session: AsyncSession):
        """Test fresh progress trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)

        progress = await UserDeckProgressFactory.create(
            session=db_session, user_id=user.id, deck_id=deck.id, fresh=True
        )

        assert progress.cards_studied == 0
        assert progress.cards_mastered == 0
        assert progress.last_studied_at is None

    async def test_completed_trait(self, db_session: AsyncSession):
        """Test completed progress trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)

        progress = await UserDeckProgressFactory.create(
            session=db_session, user_id=user.id, deck_id=deck.id, completed=True
        )

        assert progress.cards_studied == 50
        assert progress.cards_mastered == 50


# =============================================================================
# CardStatisticsFactory Tests
# =============================================================================


class TestCardStatisticsFactory:
    """Tests for CardStatisticsFactory (SM-2 algorithm)."""

    async def test_create_statistics(self, db_session: AsyncSession):
        """Test creating card statistics."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id
        )

        assert stats is not None
        assert stats.user_id == user.id
        assert stats.card_id == card.id

    async def test_new_trait(self, db_session: AsyncSession):
        """Test NEW status trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, new=True
        )

        assert stats.status == CardStatus.NEW
        assert stats.easiness_factor == SM2_DEFAULT_EASINESS_FACTOR
        assert stats.interval == 0
        assert stats.repetitions == 0

    async def test_learning_trait(self, db_session: AsyncSession):
        """Test LEARNING status trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, learning=True
        )

        assert stats.status == CardStatus.LEARNING
        assert stats.repetitions > 0

    async def test_mastered_trait(self, db_session: AsyncSession):
        """Test MASTERED status trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, mastered=True
        )

        assert stats.status == CardStatus.MASTERED
        assert stats.easiness_factor > SM2_DEFAULT_EASINESS_FACTOR
        assert stats.interval >= 30
        assert stats.repetitions >= 10

    async def test_due_trait(self, db_session: AsyncSession):
        """Test due for review trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, due=True
        )

        assert stats.next_review_date == date.today()

    async def test_overdue_trait(self, db_session: AsyncSession):
        """Test overdue trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, overdue=True
        )

        assert stats.next_review_date < date.today()

    async def test_struggling_trait(self, db_session: AsyncSession):
        """Test struggling card trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        stats = await CardStatisticsFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, struggling=True
        )

        assert stats.easiness_factor == SM2_MIN_EASINESS_FACTOR


# =============================================================================
# ReviewFactory Tests
# =============================================================================


class TestReviewFactory:
    """Tests for ReviewFactory."""

    async def test_create_review(self, db_session: AsyncSession):
        """Test creating a review."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        review = await ReviewFactory.create(
            session=db_session, user_id=user.id, card_id=card.id
        )

        assert review is not None
        assert review.user_id == user.id
        assert review.card_id == card.id
        assert 0 <= review.quality <= 5

    async def test_perfect_trait(self, db_session: AsyncSession):
        """Test perfect review trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        review = await ReviewFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, perfect=True
        )

        assert review.quality == ReviewRating.PERFECT

    async def test_failed_trait(self, db_session: AsyncSession):
        """Test failed review trait."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        review = await ReviewFactory.create(
            session=db_session, user_id=user.id, card_id=card.id, failed=True
        )

        assert review.quality == ReviewRating.BLACKOUT

    async def test_create_history(self, db_session: AsyncSession):
        """Test creating review history."""
        user = await UserFactory.create(session=db_session)
        deck = await DeckFactory.create(session=db_session)
        card = await CardFactory.create(session=db_session, deck_id=deck.id)

        ratings = [3, 4, 4, 5, 5]  # Improving performance
        reviews = await ReviewFactory.create_history(
            user_id=user.id,
            card_id=card.id,
            ratings=ratings,
            session=db_session,
        )

        assert len(reviews) == 5
        for i, review in enumerate(reviews):
            assert review.quality == ratings[i]


# =============================================================================
# Integration Tests
# =============================================================================


class TestFactoryIntegration:
    """Integration tests for factory combinations."""

    async def test_complete_learning_scenario(self, db_session: AsyncSession):
        """Test creating a complete learning scenario."""
        # Create user with settings
        user = await UserFactory.create_with_settings(session=db_session)

        # Create deck with cards
        deck, cards = await DeckFactory.create_with_cards(
            session=db_session, card_count=5
        )

        # Create progress
        progress = await UserDeckProgressFactory.create(
            session=db_session,
            user_id=user.id,
            deck_id=deck.id,
            cards_studied=3,
            cards_mastered=1,
        )

        # Create statistics for each card
        stats_list = []
        for i, card in enumerate(cards):
            if i == 0:
                stats = await CardStatisticsFactory.create(
                    session=db_session, user_id=user.id, card_id=card.id, mastered=True
                )
            elif i < 3:
                stats = await CardStatisticsFactory.create(
                    session=db_session, user_id=user.id, card_id=card.id, learning=True
                )
            else:
                stats = await CardStatisticsFactory.create(
                    session=db_session, user_id=user.id, card_id=card.id, new=True
                )
            stats_list.append(stats)

        # Verify scenario
        assert user.settings is not None
        assert len(cards) == 5
        assert progress.cards_studied == 3
        assert stats_list[0].status == CardStatus.MASTERED
        assert stats_list[1].status == CardStatus.LEARNING
        assert stats_list[4].status == CardStatus.NEW
```

---

## 5. Factory Specifications

### 5.1 UserFactory

| Attribute | Default | Traits | Notes |
|-----------|---------|--------|-------|
| email | unique_email() | - | Auto-generated |
| password_hash | hash("TestPassword123!") | oauth: None | Bcrypt hashed |
| full_name | Faker name | admin: "Admin User" | |
| is_active | True | inactive: False | |
| is_superuser | False | admin: True | |
| email_verified_at | None | admin/verified/oauth: utc_now() | |
| google_id | None | oauth: uuid | |

### 5.2 DeckFactory

| Attribute | Default | Traits | Notes |
|-----------|---------|--------|-------|
| name | GreekProvider.deck_name | Level traits | CEFR-based |
| description | GreekProvider.deck_description | Level traits | |
| level | DeckLevel.A1 | a1-c2 traits | |
| is_active | True | inactive: False | |

### 5.3 CardFactory

| Attribute | Default | Traits | Notes |
|-----------|---------|--------|-------|
| deck_id | Required | - | Must be provided |
| front_text | GreekProvider.greek_word | - | Greek text |
| back_text | GreekProvider.greek_translation | - | English |
| pronunciation | GreekProvider.greek_pronunciation | minimal: None | |
| example_sentence | GreekProvider.greek_example_sentence | minimal: None | |
| difficulty | MEDIUM | easy/medium/hard | |
| order_index | Sequence | - | Auto-increment |

### 5.4 CardStatisticsFactory

| Attribute | Default | Traits | Notes |
|-----------|---------|--------|-------|
| user_id | Required | - | Must be provided |
| card_id | Required | - | Must be provided |
| easiness_factor | 2.5 | mastered: 2.7, struggling: 1.3 | SM-2 EF |
| interval | 1 | new: 0, mastered: 30 | Days |
| repetitions | 1 | new: 0, mastered: 10 | Count |
| next_review_date | tomorrow | due: today, overdue: past | |
| status | LEARNING | new/learning/review/mastered | SM-2 state |

---

## 6. Integration with Existing Infrastructure

### 6.1 Using Factories with Existing Fixtures

Factories complement existing fixtures:

```python
# Using factory with existing db_session fixture
async def test_with_factory(db_session):
    user = await UserFactory.create(session=db_session)
    assert user.id is not None

# Using factory with existing authenticated_user fixture
async def test_user_deck(authenticated_user, db_session):
    # authenticated_user is from fixtures/auth.py
    deck, cards = await DeckFactory.create_with_cards(session=db_session)
    progress = await UserDeckProgressFactory.create(
        session=db_session,
        user_id=authenticated_user.user.id,
        deck_id=deck.id,
    )
```

### 6.2 Factory Session Binding

The factory session binding in conftest.py enables:

```python
# With auto-bound session (via fixture)
async def test_auto_session(db_session):
    # Factory automatically uses db_session
    user = await UserFactory.create()  # No session parameter needed
    assert user.id is not None

# With explicit session
async def test_explicit_session(db_session):
    user = await UserFactory.create(session=db_session)
    assert user.id is not None
```

### 6.3 Migration Path from Manual Factories

Existing manual factory functions can coexist with factory-boy:

```python
# Old approach (still works)
from tests.fixtures.auth import create_user_with_settings
user = await create_user_with_settings(db_session, user_data)

# New approach (factory-boy)
from tests.factories import UserFactory
user = await UserFactory.create_with_settings(session=db_session)
```

---

## 7. Test Plan

### 7.1 Unit Tests

| Test Category | Test Count | Description |
|---------------|------------|-------------|
| UserFactory | 8 | Basic, traits, compose, batch |
| UserSettingsFactory | 3 | Basic, traits |
| RefreshTokenFactory | 2 | Basic, expired |
| DeckFactory | 4 | Basic, traits, with_cards |
| CardFactory | 4 | Basic, traits, sequence |
| UserDeckProgressFactory | 3 | Basic, traits |
| CardStatisticsFactory | 7 | SM-2 state traits |
| ReviewFactory | 4 | Basic, traits, history |
| Integration | 1 | Complete scenario |
| **Total** | **36+** | |

### 7.2 Verification Commands

```bash
# Add factory-boy dependency
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry add --group dev factory-boy

# Run factory tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/unit/test_factories.py -v

# Run all tests to ensure no regressions
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/ -v

# Verify imports
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run python -c "
from tests.factories import (
    UserFactory, DeckFactory, CardFactory,
    CardStatisticsFactory, ReviewFactory
)
print('All factory imports successful!')
"
```

---

## 8. Implementation Checklist

### Phase 1: Setup
- [ ] Add `factory-boy` dependency to pyproject.toml
- [ ] Create `tests/factories/` directory structure
- [ ] Create `tests/factories/providers/` directory

### Phase 2: Base Infrastructure
- [ ] Create `tests/factories/providers/greek.py` - Greek Faker provider
- [ ] Create `tests/factories/providers/__init__.py`
- [ ] Create `tests/factories/base.py` - BaseFactory with async support

### Phase 3: Auth Factories
- [ ] Create `tests/factories/auth.py`
  - [ ] UserFactory with traits
  - [ ] UserSettingsFactory
  - [ ] RefreshTokenFactory

### Phase 4: Content Factories
- [ ] Create `tests/factories/content.py`
  - [ ] DeckFactory with CEFR level traits
  - [ ] CardFactory with Greek vocabulary

### Phase 5: Progress Factories
- [ ] Create `tests/factories/progress.py`
  - [ ] UserDeckProgressFactory
  - [ ] CardStatisticsFactory with SM-2 traits
  - [ ] ReviewFactory

### Phase 6: Integration
- [ ] Create `tests/factories/__init__.py` - Package exports
- [ ] Update `tests/conftest.py` - Add factory session binding

### Phase 7: Testing
- [ ] Create `tests/unit/test_factories.py`
- [ ] Run all factory tests
- [ ] Run full test suite to verify no regressions

---

## 9. Acceptance Criteria

### 9.1 Functional Requirements

- [ ] `factory-boy` >= 3.3 installed
- [ ] BaseFactory supports async SQLAlchemy sessions
- [ ] All 8 model factories implemented
- [ ] Traits for common variations work correctly
- [ ] SubFactories create related objects
- [ ] Greek vocabulary provider generates realistic content
- [ ] SM-2 state presets have correct values

### 9.2 Non-Functional Requirements

- [ ] Factories are performant (no unnecessary queries)
- [ ] Code follows established patterns
- [ ] Type hints are accurate
- [ ] Docstrings describe usage
- [ ] Tests pass without warnings

### 9.3 Integration Requirements

- [ ] Factories work with db_session fixture
- [ ] Session binding works automatically
- [ ] Factories can be used alongside existing fixtures
- [ ] No circular import issues

---

## 10. Troubleshooting Guide

### Issue 1: "No database session available"

**Cause**: Factory used without session binding

**Solution**:
```python
# Either pass session explicitly
user = await UserFactory.create(session=db_session)

# Or ensure bind_factory_session fixture is active
# (should be autouse=True in conftest.py)
```

### Issue 2: "IntegrityError: duplicate key"

**Cause**: Non-unique email or constraint violation

**Solution**:
```python
# Use unique_email() for guaranteed uniqueness
from tests.factories.base import unique_email
user = await UserFactory.create(email=unique_email())
```

### Issue 3: "ImportError: cannot import name 'factory'"

**Cause**: factory-boy not installed

**Solution**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry add --group dev factory-boy
```

### Issue 4: Trait not applying

**Cause**: Trait name misspelled or not defined

**Solution**:
```python
# Check trait is defined in Params class
class Params:
    admin = factory.Trait(...)

# Use correct trait name
user = await UserFactory.create(admin=True)  # Correct
user = await UserFactory.create(is_admin=True)  # Wrong
```

### Issue 5: Greek vocabulary not generating

**Cause**: GreekProvider not registered with Faker

**Solution**:
```python
# Ensure provider is registered in base.py
from faker import Faker
from tests.factories.providers.greek import GreekProvider

fake = Faker()
fake.add_provider(GreekProvider)
```

---

## Related Documents

- [04-backend-testing-framework-plan.md](./04-backend-testing-framework-plan.md) - Parent task
- [04.01-pytest-async-configuration-plan.md](./04.01-pytest-async-configuration-plan.md) - Pytest configuration
- [04.02-test-database-fixtures-plan.md](./04.02-test-database-fixtures-plan.md) - Database fixtures
- [04.03-base-test-classes-plan.md](./04.03-base-test-classes-plan.md) - Base test classes
- [04.04-domain-fixtures-plan.md](./04.04-domain-fixtures-plan.md) - Domain fixtures
- [Backend-Tasks-Progress.md](../Backend-Tasks-Progress.md) - Task tracking

---

**Document Version**: 1.0
**Created**: 2025-11-30
**Author**: Architecture Team
**Status**: Ready for Implementation
**Priority**: High
**Estimated Duration**: 2-3 hours
