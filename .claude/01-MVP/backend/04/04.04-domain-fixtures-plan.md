# Task 04.04: Implement Test Fixtures (Decks, Cards, Progress, Reviews) - Technical Architecture Plan

**Created**: 2025-11-30
**Completed**: 2025-11-30
**Status**: ✅ COMPLETED
**Actual Duration**: 2 hours
**Type**: Architecture Documentation
**Priority**: Critical Path
**Dependencies**: 04.01, 04.02, 04.03 (All Completed)

---

## 1. Overview

### 1.1 Task Description

Implement comprehensive pytest fixtures for domain entities: Decks, Cards, UserDeckProgress, CardStatistics, and Reviews. These fixtures will support testing of spaced repetition (SM-2 algorithm) functionality, deck management, and user progress tracking.

### 1.2 Objectives

1. Create reusable deck and card fixtures with realistic Greek vocabulary content
2. Implement progress tracking fixtures (UserDeckProgress, CardStatistics) for SM-2 testing
3. Create review history fixtures for analytics and algorithm testing
4. Follow established patterns from `tests/fixtures/auth.py`
5. Support various test scenarios (new cards, due cards, mastered cards, etc.)
6. Provide both simple fixtures and factory functions for programmatic creation

### 1.3 Success Criteria

- All fixtures integrate seamlessly with existing database and auth fixtures
- Fixtures support async database operations
- Greek vocabulary content is realistic and educational
- SM-2 algorithm states are properly represented (NEW, LEARNING, REVIEW, MASTERED)
- Review history fixtures support analytics testing
- All fixtures are properly exported and documented

---

## 2. Current State Analysis

### 2.1 Existing Fixture Infrastructure

**Database Fixtures** (`tests/fixtures/database.py`):
- `db_engine`: Creates async PostgreSQL engine with table management
- `db_session`: Provides AsyncSession with automatic rollback
- `db_session_with_savepoint`: Savepoint-based transaction isolation
- `session_db_engine`: Session-scoped engine for faster tests
- `fast_db_session`: Session using shared engine

**Auth Fixtures** (`tests/fixtures/auth.py`):
- User fixtures: `test_user`, `test_superuser`, `test_verified_user`, `test_inactive_user`, `two_users`
- Token fixtures: `test_user_tokens`, `superuser_tokens`, `access_token`, `refresh_token_value`
- Header fixtures: `auth_headers`, `superuser_auth_headers`, `expired_auth_headers`
- Bundle fixtures: `authenticated_user`, `authenticated_superuser`
- Types: `AuthTokens`, `AuthenticatedUser`
- Factory functions: `create_test_user_data()`, `create_user_with_settings()`, `create_tokens_for_user()`

**Base Test Classes** (`tests/base.py`):
- `BaseTestCase` with `create_test_deck()`, `create_test_card()`, `create_deck_with_cards()`
- `AuthenticatedTestCase` with authentication helpers

### 2.2 Domain Models Reference

From `src/db/models.py`:

```python
# Enums
class DeckLevel(str, enum.Enum):
    A1 = "A1"  # Beginner
    A2 = "A2"  # Elementary
    B1 = "B1"  # Intermediate
    B2 = "B2"  # Upper Intermediate
    C1 = "C1"  # Advanced
    C2 = "C2"  # Proficiency

class CardDifficulty(str, enum.Enum):
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"

class CardStatus(str, enum.Enum):
    NEW = "new"           # Never reviewed
    LEARNING = "learning" # In initial learning phase
    REVIEW = "review"     # In review phase
    MASTERED = "mastered" # Successfully mastered

class ReviewRating(int, enum.Enum):
    BLACKOUT = 0          # Complete blackout
    INCORRECT_HARD = 1    # Incorrect, felt difficult
    INCORRECT_EASY = 2    # Incorrect, but easy to recall
    CORRECT_HARD = 3      # Correct, but difficult
    CORRECT_HESITANT = 4  # Correct, with hesitation
    PERFECT = 5           # Perfect response

# Models
class Deck:
    id: UUID
    name: str
    description: str | None
    level: DeckLevel
    is_active: bool
    created_at, updated_at: datetime
    cards: List[Card]
    user_progress: List[UserDeckProgress]

class Card:
    id: UUID
    deck_id: UUID
    front_text: str           # Greek text
    back_text: str            # English translation
    example_sentence: str | None
    pronunciation: str | None
    difficulty: CardDifficulty
    order_index: int
    created_at, updated_at: datetime
    deck: Deck
    statistics: List[CardStatistics]
    reviews: List[Review]

class UserDeckProgress:
    id: UUID
    user_id: UUID
    deck_id: UUID
    cards_studied: int
    cards_mastered: int
    last_studied_at: datetime | None
    created_at, updated_at: datetime
    user: User
    deck: Deck

class CardStatistics:
    id: UUID
    user_id: UUID
    card_id: UUID
    easiness_factor: float     # SM-2 EF (1.3 to 2.5+), default 2.5
    interval: int              # Days until next review, default 0
    repetitions: int           # Successful reviews count, default 0
    next_review_date: date     # For "get due cards" queries
    status: CardStatus         # NEW, LEARNING, REVIEW, MASTERED
    created_at, updated_at: datetime
    user: User
    card: Card

class Review:
    id: UUID
    user_id: UUID
    card_id: UUID
    quality: int               # 0-5 (SM-2 quality rating)
    time_taken: int            # Seconds spent on review
    reviewed_at: datetime
    created_at, updated_at: datetime
    user: User
    card: Card
```

### 2.3 File Structure to Create

```
tests/fixtures/
├── __init__.py       (UPDATE - add new exports)
├── database.py       (existing)
├── auth.py           (existing)
├── deck.py           (NEW - deck and card fixtures)
└── progress.py       (NEW - progress and review fixtures)
```

---

## 3. Architecture Design

### 3.1 Fixture Organization Strategy

Following the established pattern from `auth.py`:

1. **Type Definitions** - NamedTuple/TypedDict for bundled data
2. **Data Constants** - Realistic Greek vocabulary data
3. **Factory Functions** - Programmatic creation utilities
4. **Core Fixtures** - Basic entity fixtures
5. **Composite Fixtures** - Bundled fixtures for complex scenarios
6. **Specialized Fixtures** - Edge cases and specific test scenarios

### 3.2 Fixture Dependency Graph

```
                    db_session
                        │
        ┌───────────────┼───────────────┐
        ▼               ▼               ▼
    test_user      test_deck      test_deck_a1
        │               │               │
        │        ┌──────┴──────┐        │
        │        ▼             ▼        ▼
        │   test_cards    deck_with_cards
        │        │             │
        └────────┼─────────────┘
                 │
        ┌────────┴────────┐
        ▼                 ▼
  user_deck_progress  card_statistics
        │                 │
        └────────┬────────┘
                 ▼
            test_reviews
                 │
                 ▼
    user_with_learning_progress
```

### 3.3 Greek Vocabulary Data Design

Realistic Greek vocabulary organized by CEFR level:

**A1 (Beginner) - Basic Greetings & Numbers**:
- Common phrases: "Hello", "Thank you", "Please"
- Numbers 1-10
- Basic nouns: "water", "bread", "house"

**A2 (Elementary) - Daily Life**:
- Family vocabulary
- Food and drink
- Basic verbs

**B1 (Intermediate) - Abstract Concepts**:
- Emotions and feelings
- Time expressions
- More complex sentences

---

## 4. Implementation Details

### 4.1 File: `tests/fixtures/deck.py`

```python
"""Deck and Card fixtures for testing.

This module provides comprehensive fixtures for deck and card testing:
- test_deck: A basic A1-level deck
- test_deck_a1, test_deck_a2, test_deck_b1: Level-specific decks
- test_cards: A list of cards for a deck
- deck_with_cards: A deck populated with cards
- deck_with_mixed_difficulty_cards: Cards of varying difficulty
- empty_deck: A deck with no cards
- inactive_deck: A deactivated deck

All fixtures use PostgreSQL and integrate with the db_session fixture.

Usage:
    async def test_deck_listing(client: AsyncClient, test_deck: Deck):
        # test_deck is an A1-level Greek vocabulary deck
        assert test_deck.level == DeckLevel.A1

    async def test_cards_in_deck(deck_with_cards: DeckWithCards):
        deck = deck_with_cards.deck
        cards = deck_with_cards.cards
        assert len(cards) == 5
"""

from collections.abc import AsyncGenerator
from typing import Any, NamedTuple
from uuid import uuid4

import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import Card, CardDifficulty, Deck, DeckLevel


# =============================================================================
# Type Definitions
# =============================================================================


class DeckWithCards(NamedTuple):
    """Container for a deck with its cards."""

    deck: Deck
    cards: list[Card]


class MultiLevelDecks(NamedTuple):
    """Container for decks at different CEFR levels."""

    a1: Deck
    a2: Deck
    b1: Deck


# =============================================================================
# Greek Vocabulary Data
# =============================================================================

# A1 Level - Basic Greetings and Essential Words
GREEK_VOCABULARY_A1: list[dict[str, Any]] = [
    {
        "front_text": "Yeia sou",
        "back_text": "Hello (informal)",
        "pronunciation": "YAH-soo",
        "example_sentence": "Yeia sou, ti kaneis?",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Kalimera",
        "back_text": "Good morning",
        "pronunciation": "kah-lee-MEH-rah",
        "example_sentence": "Kalimera! Pos eiste?",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Efcharisto",
        "back_text": "Thank you",
        "pronunciation": "ef-hah-ree-STO",
        "example_sentence": "Efcharisto poli!",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Parakalo",
        "back_text": "Please / You're welcome",
        "pronunciation": "pah-rah-kah-LO",
        "example_sentence": "Parakalo, boroume na pame?",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Nero",
        "back_text": "Water",
        "pronunciation": "neh-RO",
        "example_sentence": "Thelo ena nero, parakalo.",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Psomi",
        "back_text": "Bread",
        "pronunciation": "pso-MEE",
        "example_sentence": "To psomi einai fresko.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Spiti",
        "back_text": "House / Home",
        "pronunciation": "SPEE-tee",
        "example_sentence": "To spiti mou einai mikro.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Ena",
        "back_text": "One",
        "pronunciation": "EH-nah",
        "example_sentence": "Ena kafe, parakalo.",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Dio",
        "back_text": "Two",
        "pronunciation": "THEE-oh",
        "example_sentence": "Dio nero, parakalo.",
        "difficulty": CardDifficulty.EASY,
    },
    {
        "front_text": "Tria",
        "back_text": "Three",
        "pronunciation": "TREE-ah",
        "example_sentence": "Tria adelfia echo.",
        "difficulty": CardDifficulty.EASY,
    },
]

# A2 Level - Daily Life and Common Verbs
GREEK_VOCABULARY_A2: list[dict[str, Any]] = [
    {
        "front_text": "Troo",
        "back_text": "I eat",
        "pronunciation": "TRO-oh",
        "example_sentence": "Troo proino stis okto.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Pino",
        "back_text": "I drink",
        "pronunciation": "PEE-no",
        "example_sentence": "Pino kafe kathe proi.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Douleo",
        "back_text": "I work",
        "pronunciation": "thoo-LEH-vo",
        "example_sentence": "Douleo se ena grafeio.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Oikogeneia",
        "back_text": "Family",
        "pronunciation": "ee-ko-YEH-nee-ah",
        "example_sentence": "I oikogeneia mou einai megali.",
        "difficulty": CardDifficulty.HARD,
    },
    {
        "front_text": "Filo",
        "back_text": "Friend",
        "pronunciation": "FEE-lo",
        "example_sentence": "O Yiannis einai o filo mou.",
        "difficulty": CardDifficulty.MEDIUM,
    },
]

# B1 Level - Abstract Concepts and Complex Vocabulary
GREEK_VOCABULARY_B1: list[dict[str, Any]] = [
    {
        "front_text": "Agapi",
        "back_text": "Love",
        "pronunciation": "ah-GAH-pee",
        "example_sentence": "I agapi einai to pio simantiko pragma.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Elpida",
        "back_text": "Hope",
        "pronunciation": "el-PEE-thah",
        "example_sentence": "Echo elpida gia to mellon.",
        "difficulty": CardDifficulty.MEDIUM,
    },
    {
        "front_text": "Epistimi",
        "back_text": "Science",
        "pronunciation": "eh-pee-STEE-mee",
        "example_sentence": "I epistimi proodeui synechos.",
        "difficulty": CardDifficulty.HARD,
    },
    {
        "front_text": "Politismos",
        "back_text": "Culture / Civilization",
        "pronunciation": "po-lee-tee-SMOS",
        "example_sentence": "O ellinikos politismos einai archaios.",
        "difficulty": CardDifficulty.HARD,
    },
    {
        "front_text": "Dimokratia",
        "back_text": "Democracy",
        "pronunciation": "thee-mo-krah-TEE-ah",
        "example_sentence": "I dimokratia gennithike stin Athina.",
        "difficulty": CardDifficulty.HARD,
    },
]


# =============================================================================
# Factory Functions
# =============================================================================


def create_deck_data(
    name: str | None = None,
    description: str | None = None,
    level: DeckLevel = DeckLevel.A1,
    is_active: bool = True,
) -> dict[str, Any]:
    """Create deck data dictionary.

    Args:
        name: Deck name (auto-generated if None)
        description: Deck description
        level: CEFR level (A1-C2)
        is_active: Whether deck is active

    Returns:
        dict: Deck data ready for Deck model creation
    """
    if name is None:
        name = f"Greek {level.value} Vocabulary"

    if description is None:
        descriptions = {
            DeckLevel.A1: "Essential Greek words and phrases for beginners",
            DeckLevel.A2: "Elementary Greek vocabulary for daily life",
            DeckLevel.B1: "Intermediate Greek vocabulary and expressions",
            DeckLevel.B2: "Upper-intermediate Greek for confident speakers",
            DeckLevel.C1: "Advanced Greek vocabulary and idioms",
            DeckLevel.C2: "Near-native Greek proficiency vocabulary",
        }
        description = descriptions.get(level, "Greek vocabulary deck")

    return {
        "name": name,
        "description": description,
        "level": level,
        "is_active": is_active,
    }


def create_card_data(
    deck_id: Any,
    front_text: str = "Yeia",
    back_text: str = "Hello",
    pronunciation: str | None = "YAH",
    example_sentence: str | None = None,
    difficulty: CardDifficulty = CardDifficulty.MEDIUM,
    order_index: int = 0,
) -> dict[str, Any]:
    """Create card data dictionary.

    Args:
        deck_id: UUID of parent deck
        front_text: Greek text (front of card)
        back_text: English translation (back of card)
        pronunciation: Phonetic pronunciation guide
        example_sentence: Example usage in Greek
        difficulty: Card difficulty level
        order_index: Order within deck

    Returns:
        dict: Card data ready for Card model creation
    """
    return {
        "deck_id": deck_id,
        "front_text": front_text,
        "back_text": back_text,
        "pronunciation": pronunciation,
        "example_sentence": example_sentence,
        "difficulty": difficulty,
        "order_index": order_index,
    }


async def create_deck(
    db_session: AsyncSession,
    name: str | None = None,
    description: str | None = None,
    level: DeckLevel = DeckLevel.A1,
    is_active: bool = True,
) -> Deck:
    """Create a deck in the database.

    Args:
        db_session: Database session
        name: Deck name
        description: Deck description
        level: CEFR level
        is_active: Whether deck is active

    Returns:
        Deck: Created deck
    """
    deck_data = create_deck_data(
        name=name,
        description=description,
        level=level,
        is_active=is_active,
    )
    deck = Deck(**deck_data)
    db_session.add(deck)
    await db_session.commit()
    await db_session.refresh(deck)
    return deck


async def create_card(
    db_session: AsyncSession,
    deck: Deck,
    front_text: str = "Yeia",
    back_text: str = "Hello",
    pronunciation: str | None = "YAH",
    example_sentence: str | None = None,
    difficulty: CardDifficulty = CardDifficulty.MEDIUM,
    order_index: int = 0,
) -> Card:
    """Create a card in the database.

    Args:
        db_session: Database session
        deck: Parent deck
        front_text: Greek text
        back_text: English translation
        pronunciation: Phonetic guide
        example_sentence: Example usage
        difficulty: Card difficulty
        order_index: Order in deck

    Returns:
        Card: Created card
    """
    card_data = create_card_data(
        deck_id=deck.id,
        front_text=front_text,
        back_text=back_text,
        pronunciation=pronunciation,
        example_sentence=example_sentence,
        difficulty=difficulty,
        order_index=order_index,
    )
    card = Card(**card_data)
    db_session.add(card)
    await db_session.commit()
    await db_session.refresh(card)
    return card


async def create_deck_with_vocabulary(
    db_session: AsyncSession,
    level: DeckLevel = DeckLevel.A1,
    card_count: int | None = None,
) -> DeckWithCards:
    """Create a deck with vocabulary cards from the predefined data.

    Args:
        db_session: Database session
        level: CEFR level (determines vocabulary set)
        card_count: Number of cards (None = all available)

    Returns:
        DeckWithCards: Deck with its cards
    """
    # Select vocabulary based on level
    vocabulary_map = {
        DeckLevel.A1: GREEK_VOCABULARY_A1,
        DeckLevel.A2: GREEK_VOCABULARY_A2,
        DeckLevel.B1: GREEK_VOCABULARY_B1,
    }
    vocabulary = vocabulary_map.get(level, GREEK_VOCABULARY_A1)

    # Limit card count if specified
    if card_count is not None:
        vocabulary = vocabulary[:card_count]

    # Create deck
    deck = await create_deck(db_session, level=level)

    # Create cards
    cards = []
    for i, vocab in enumerate(vocabulary):
        card = await create_card(
            db_session,
            deck,
            front_text=vocab["front_text"],
            back_text=vocab["back_text"],
            pronunciation=vocab.get("pronunciation"),
            example_sentence=vocab.get("example_sentence"),
            difficulty=vocab.get("difficulty", CardDifficulty.MEDIUM),
            order_index=i,
        )
        cards.append(card)

    return DeckWithCards(deck=deck, cards=cards)


# =============================================================================
# Core Deck Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def test_deck(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide a basic A1-level test deck.

    Creates an active deck with:
    - Name: "Greek A1 Vocabulary"
    - Level: A1 (Beginner)
    - Description: Standard beginner description
    - No cards (use deck_with_cards for cards)

    Yields:
        Deck: The created test deck
    """
    deck = await create_deck(db_session, level=DeckLevel.A1)
    yield deck


@pytest_asyncio.fixture
async def test_deck_a1(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide an A1 (Beginner) level deck.

    Explicitly named for clarity when testing level-specific behavior.

    Yields:
        Deck: A1 level deck
    """
    deck = await create_deck(
        db_session,
        name="Greek Basics - A1",
        level=DeckLevel.A1,
    )
    yield deck


@pytest_asyncio.fixture
async def test_deck_a2(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide an A2 (Elementary) level deck.

    Yields:
        Deck: A2 level deck
    """
    deck = await create_deck(
        db_session,
        name="Greek Daily Life - A2",
        level=DeckLevel.A2,
    )
    yield deck


@pytest_asyncio.fixture
async def test_deck_b1(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide a B1 (Intermediate) level deck.

    Yields:
        Deck: B1 level deck
    """
    deck = await create_deck(
        db_session,
        name="Greek Conversations - B1",
        level=DeckLevel.B1,
    )
    yield deck


@pytest_asyncio.fixture
async def inactive_deck(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide an inactive/deactivated deck.

    Use for testing that inactive decks are properly hidden.

    Yields:
        Deck: Inactive deck
    """
    deck = await create_deck(
        db_session,
        name="Archived Deck",
        is_active=False,
    )
    yield deck


@pytest_asyncio.fixture
async def empty_deck(db_session: AsyncSession) -> AsyncGenerator[Deck, None]:
    """Provide a deck with no cards.

    Alias for test_deck, but semantically clear for empty-deck tests.

    Yields:
        Deck: Empty deck
    """
    deck = await create_deck(
        db_session,
        name="Empty Deck",
        description="A deck waiting for cards",
    )
    yield deck


# =============================================================================
# Card Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def test_card(
    db_session: AsyncSession,
    test_deck: Deck,
) -> AsyncGenerator[Card, None]:
    """Provide a single test card.

    Creates a basic Greek greeting card.

    Args:
        db_session: Database session
        test_deck: Parent deck fixture

    Yields:
        Card: Single test card
    """
    card = await create_card(
        db_session,
        test_deck,
        front_text="Yeia sou",
        back_text="Hello (informal)",
        pronunciation="YAH-soo",
        example_sentence="Yeia sou, ti kaneis?",
        difficulty=CardDifficulty.EASY,
    )
    yield card


@pytest_asyncio.fixture
async def test_cards(
    db_session: AsyncSession,
    test_deck: Deck,
) -> AsyncGenerator[list[Card], None]:
    """Provide a list of 5 test cards for a deck.

    Creates cards from A1 vocabulary (first 5 words).

    Args:
        db_session: Database session
        test_deck: Parent deck fixture

    Yields:
        list[Card]: List of 5 cards
    """
    cards = []
    for i, vocab in enumerate(GREEK_VOCABULARY_A1[:5]):
        card = await create_card(
            db_session,
            test_deck,
            front_text=vocab["front_text"],
            back_text=vocab["back_text"],
            pronunciation=vocab.get("pronunciation"),
            example_sentence=vocab.get("example_sentence"),
            difficulty=vocab.get("difficulty", CardDifficulty.MEDIUM),
            order_index=i,
        )
        cards.append(card)
    yield cards


@pytest_asyncio.fixture
async def cards_by_difficulty(
    db_session: AsyncSession,
    test_deck: Deck,
) -> AsyncGenerator[dict[CardDifficulty, list[Card]], None]:
    """Provide cards grouped by difficulty level.

    Creates 2 cards of each difficulty level (EASY, MEDIUM, HARD).

    Yields:
        dict: Cards grouped by CardDifficulty
    """
    result: dict[CardDifficulty, list[Card]] = {
        CardDifficulty.EASY: [],
        CardDifficulty.MEDIUM: [],
        CardDifficulty.HARD: [],
    }

    difficulties = [CardDifficulty.EASY, CardDifficulty.MEDIUM, CardDifficulty.HARD]
    index = 0

    for difficulty in difficulties:
        for j in range(2):
            card = await create_card(
                db_session,
                test_deck,
                front_text=f"Word {index}",
                back_text=f"Translation {index}",
                difficulty=difficulty,
                order_index=index,
            )
            result[difficulty].append(card)
            index += 1

    yield result


# =============================================================================
# Composite Fixtures (Deck + Cards)
# =============================================================================


@pytest_asyncio.fixture
async def deck_with_cards(
    db_session: AsyncSession,
) -> AsyncGenerator[DeckWithCards, None]:
    """Provide a deck with 5 A1 vocabulary cards.

    This is the primary fixture for testing deck/card interactions.

    Yields:
        DeckWithCards: Named tuple with deck and cards
    """
    result = await create_deck_with_vocabulary(
        db_session,
        level=DeckLevel.A1,
        card_count=5,
    )
    yield result


@pytest_asyncio.fixture
async def deck_with_all_a1_cards(
    db_session: AsyncSession,
) -> AsyncGenerator[DeckWithCards, None]:
    """Provide a deck with all A1 vocabulary cards (10 cards).

    Yields:
        DeckWithCards: Deck with all A1 vocabulary
    """
    result = await create_deck_with_vocabulary(
        db_session,
        level=DeckLevel.A1,
        card_count=None,  # All cards
    )
    yield result


@pytest_asyncio.fixture
async def deck_with_a2_cards(
    db_session: AsyncSession,
) -> AsyncGenerator[DeckWithCards, None]:
    """Provide an A2-level deck with vocabulary cards.

    Yields:
        DeckWithCards: A2 deck with cards
    """
    result = await create_deck_with_vocabulary(
        db_session,
        level=DeckLevel.A2,
    )
    yield result


@pytest_asyncio.fixture
async def deck_with_b1_cards(
    db_session: AsyncSession,
) -> AsyncGenerator[DeckWithCards, None]:
    """Provide a B1-level deck with vocabulary cards.

    Yields:
        DeckWithCards: B1 deck with cards
    """
    result = await create_deck_with_vocabulary(
        db_session,
        level=DeckLevel.B1,
    )
    yield result


@pytest_asyncio.fixture
async def multi_level_decks(
    db_session: AsyncSession,
) -> AsyncGenerator[MultiLevelDecks, None]:
    """Provide decks at A1, A2, and B1 levels.

    Useful for testing level filtering and progression.

    Yields:
        MultiLevelDecks: Named tuple with a1, a2, b1 decks
    """
    a1 = await create_deck(db_session, level=DeckLevel.A1)
    a2 = await create_deck(db_session, level=DeckLevel.A2)
    b1 = await create_deck(db_session, level=DeckLevel.B1)

    yield MultiLevelDecks(a1=a1, a2=a2, b1=b1)


@pytest_asyncio.fixture
async def two_decks(
    db_session: AsyncSession,
) -> AsyncGenerator[tuple[Deck, Deck], None]:
    """Provide two different decks for testing isolation.

    Yields:
        tuple[Deck, Deck]: Two different decks
    """
    deck1 = await create_deck(
        db_session,
        name="Deck One",
        level=DeckLevel.A1,
    )
    deck2 = await create_deck(
        db_session,
        name="Deck Two",
        level=DeckLevel.A2,
    )
    yield deck1, deck2


# =============================================================================
# Large Dataset Fixtures (for performance testing)
# =============================================================================


@pytest_asyncio.fixture
async def deck_with_many_cards(
    db_session: AsyncSession,
) -> AsyncGenerator[DeckWithCards, None]:
    """Provide a deck with 50 cards for pagination/performance testing.

    Yields:
        DeckWithCards: Deck with 50 generated cards
    """
    deck = await create_deck(
        db_session,
        name="Large Test Deck",
        description="Deck with many cards for testing",
    )

    cards = []
    for i in range(50):
        difficulty = [CardDifficulty.EASY, CardDifficulty.MEDIUM, CardDifficulty.HARD][
            i % 3
        ]
        card = await create_card(
            db_session,
            deck,
            front_text=f"Greek word {i}",
            back_text=f"English translation {i}",
            difficulty=difficulty,
            order_index=i,
        )
        cards.append(card)

    yield DeckWithCards(deck=deck, cards=cards)
```

### 4.2 File: `tests/fixtures/progress.py`

```python
"""Progress and Review fixtures for testing.

This module provides fixtures for testing spaced repetition functionality:

Progress Fixtures:
- user_deck_progress: Basic progress for a user on a deck
- user_with_deck_progress: User bundle with deck progress
- progress_with_mastery: Progress showing card mastery

Card Statistics Fixtures (SM-2 Algorithm):
- new_card_statistics: Fresh card (never reviewed)
- learning_card_statistics: Card in learning phase
- review_card_statistics: Card in review phase
- mastered_card_statistics: Fully mastered card
- due_card_statistics: Card due for review today
- overdue_card_statistics: Card past due date
- cards_by_status: Cards grouped by SM-2 status

Review Fixtures:
- test_review: Single review record
- review_history: Multiple reviews for a card
- perfect_review_history: All perfect (5) ratings
- struggling_review_history: Mixed poor ratings
- user_with_reviews: User with full review history

All fixtures integrate with existing auth and deck fixtures.

Usage:
    async def test_due_cards(
        authenticated_user: AuthenticatedUser,
        due_card_statistics: CardStatistics,
    ):
        # due_card_statistics is for a card due today
        assert due_card_statistics.next_review_date <= date.today()

    async def test_sm2_calculation(learning_card_statistics: CardStatistics):
        # learning_card_statistics has appropriate SM-2 values
        assert learning_card_statistics.status == CardStatus.LEARNING
        assert learning_card_statistics.repetitions > 0
"""

from collections.abc import AsyncGenerator
from datetime import date, datetime, timedelta
from typing import Any, NamedTuple
from uuid import UUID

import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import (
    Card,
    CardStatistics,
    CardStatus,
    Deck,
    Review,
    ReviewRating,
    User,
    UserDeckProgress,
)

# Import from sibling fixtures
from tests.fixtures.auth import AuthenticatedUser
from tests.fixtures.deck import DeckWithCards


# =============================================================================
# Type Definitions
# =============================================================================


class UserProgress(NamedTuple):
    """Container for user with their deck progress."""

    user: User
    deck: Deck
    progress: UserDeckProgress


class CardWithStatistics(NamedTuple):
    """Container for card with user statistics."""

    card: Card
    statistics: CardStatistics


class UserWithLearningData(NamedTuple):
    """Complete learning data bundle for a user."""

    user: User
    deck: Deck
    cards: list[Card]
    progress: UserDeckProgress
    card_statistics: list[CardStatistics]
    reviews: list[Review]


class CardsByStatus(NamedTuple):
    """Cards grouped by their SM-2 status."""

    new: list[CardStatistics]
    learning: list[CardStatistics]
    review: list[CardStatistics]
    mastered: list[CardStatistics]


class ReviewHistory(NamedTuple):
    """Container for card review history."""

    card: Card
    statistics: CardStatistics
    reviews: list[Review]


# =============================================================================
# SM-2 Algorithm Constants
# =============================================================================

# Default SM-2 values for new cards
SM2_DEFAULT_EASINESS_FACTOR = 2.5
SM2_MIN_EASINESS_FACTOR = 1.3

# Typical intervals after successful reviews
SM2_INTERVALS = {
    "first_success": 1,    # 1 day after first successful review
    "second_success": 6,   # 6 days after second success
    "learning": 1,         # Learning phase interval
    "review": 10,          # Typical review interval
    "mastered": 30,        # Mastered card interval
}


# =============================================================================
# Factory Functions - UserDeckProgress
# =============================================================================


def create_progress_data(
    user_id: UUID,
    deck_id: UUID,
    cards_studied: int = 0,
    cards_mastered: int = 0,
    last_studied_at: datetime | None = None,
) -> dict[str, Any]:
    """Create UserDeckProgress data dictionary.

    Args:
        user_id: User's UUID
        deck_id: Deck's UUID
        cards_studied: Number of cards studied
        cards_mastered: Number of cards mastered
        last_studied_at: Last study timestamp

    Returns:
        dict: Progress data for model creation
    """
    return {
        "user_id": user_id,
        "deck_id": deck_id,
        "cards_studied": cards_studied,
        "cards_mastered": cards_mastered,
        "last_studied_at": last_studied_at,
    }


async def create_user_deck_progress(
    db_session: AsyncSession,
    user: User,
    deck: Deck,
    cards_studied: int = 0,
    cards_mastered: int = 0,
    last_studied_at: datetime | None = None,
) -> UserDeckProgress:
    """Create UserDeckProgress in the database.

    Args:
        db_session: Database session
        user: User who has progress
        deck: Deck being studied
        cards_studied: Number of cards studied
        cards_mastered: Number of cards mastered
        last_studied_at: Last study timestamp

    Returns:
        UserDeckProgress: Created progress record
    """
    progress_data = create_progress_data(
        user_id=user.id,
        deck_id=deck.id,
        cards_studied=cards_studied,
        cards_mastered=cards_mastered,
        last_studied_at=last_studied_at,
    )
    progress = UserDeckProgress(**progress_data)
    db_session.add(progress)
    await db_session.commit()
    await db_session.refresh(progress)
    return progress


# =============================================================================
# Factory Functions - CardStatistics
# =============================================================================


def create_statistics_data(
    user_id: UUID,
    card_id: UUID,
    easiness_factor: float = SM2_DEFAULT_EASINESS_FACTOR,
    interval: int = 0,
    repetitions: int = 0,
    next_review_date: date | None = None,
    status: CardStatus = CardStatus.NEW,
) -> dict[str, Any]:
    """Create CardStatistics data dictionary.

    Args:
        user_id: User's UUID
        card_id: Card's UUID
        easiness_factor: SM-2 easiness factor (1.3-2.5+)
        interval: Days until next review
        repetitions: Successful review count
        next_review_date: Next scheduled review
        status: Card learning status

    Returns:
        dict: Statistics data for model creation
    """
    if next_review_date is None:
        next_review_date = date.today()

    return {
        "user_id": user_id,
        "card_id": card_id,
        "easiness_factor": easiness_factor,
        "interval": interval,
        "repetitions": repetitions,
        "next_review_date": next_review_date,
        "status": status,
    }


async def create_card_statistics(
    db_session: AsyncSession,
    user: User,
    card: Card,
    easiness_factor: float = SM2_DEFAULT_EASINESS_FACTOR,
    interval: int = 0,
    repetitions: int = 0,
    next_review_date: date | None = None,
    status: CardStatus = CardStatus.NEW,
) -> CardStatistics:
    """Create CardStatistics in the database.

    Args:
        db_session: Database session
        user: User who owns statistics
        card: Card being tracked
        easiness_factor: SM-2 EF value
        interval: Days between reviews
        repetitions: Successful reviews count
        next_review_date: Next review date
        status: Learning status

    Returns:
        CardStatistics: Created statistics record
    """
    stats_data = create_statistics_data(
        user_id=user.id,
        card_id=card.id,
        easiness_factor=easiness_factor,
        interval=interval,
        repetitions=repetitions,
        next_review_date=next_review_date,
        status=status,
    )
    stats = CardStatistics(**stats_data)
    db_session.add(stats)
    await db_session.commit()
    await db_session.refresh(stats)
    return stats


async def create_new_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
) -> CardStatistics:
    """Create statistics for a new (never reviewed) card.

    Args:
        db_session: Database session
        user: User
        card: Card

    Returns:
        CardStatistics: New card statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=SM2_DEFAULT_EASINESS_FACTOR,
        interval=0,
        repetitions=0,
        next_review_date=date.today(),
        status=CardStatus.NEW,
    )


async def create_learning_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
) -> CardStatistics:
    """Create statistics for a card in learning phase.

    Simulates a card after 2 reviews, still in learning.

    Args:
        db_session: Database session
        user: User
        card: Card

    Returns:
        CardStatistics: Learning phase statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=2.36,  # Decreased slightly from reviews
        interval=SM2_INTERVALS["learning"],
        repetitions=2,
        next_review_date=date.today() + timedelta(days=1),
        status=CardStatus.LEARNING,
    )


async def create_review_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
) -> CardStatistics:
    """Create statistics for a card in review phase.

    Simulates a card that graduated from learning.

    Args:
        db_session: Database session
        user: User
        card: Card

    Returns:
        CardStatistics: Review phase statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=2.5,
        interval=SM2_INTERVALS["review"],
        repetitions=5,
        next_review_date=date.today() + timedelta(days=10),
        status=CardStatus.REVIEW,
    )


async def create_mastered_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
) -> CardStatistics:
    """Create statistics for a mastered card.

    Simulates a card with many successful reviews.

    Args:
        db_session: Database session
        user: User
        card: Card

    Returns:
        CardStatistics: Mastered card statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=2.7,  # Increased from consistent success
        interval=SM2_INTERVALS["mastered"],
        repetitions=10,
        next_review_date=date.today() + timedelta(days=30),
        status=CardStatus.MASTERED,
    )


async def create_due_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
) -> CardStatistics:
    """Create statistics for a card due for review today.

    Args:
        db_session: Database session
        user: User
        card: Card

    Returns:
        CardStatistics: Due card statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=2.5,
        interval=5,
        repetitions=3,
        next_review_date=date.today(),  # Due today
        status=CardStatus.REVIEW,
    )


async def create_overdue_card_stats(
    db_session: AsyncSession,
    user: User,
    card: Card,
    days_overdue: int = 3,
) -> CardStatistics:
    """Create statistics for an overdue card.

    Args:
        db_session: Database session
        user: User
        card: Card
        days_overdue: How many days past due

    Returns:
        CardStatistics: Overdue card statistics
    """
    return await create_card_statistics(
        db_session,
        user,
        card,
        easiness_factor=2.5,
        interval=5,
        repetitions=3,
        next_review_date=date.today() - timedelta(days=days_overdue),
        status=CardStatus.REVIEW,
    )


# =============================================================================
# Factory Functions - Review
# =============================================================================


def create_review_data(
    user_id: UUID,
    card_id: UUID,
    quality: int = ReviewRating.CORRECT_HESITANT,
    time_taken: int = 5,
    reviewed_at: datetime | None = None,
) -> dict[str, Any]:
    """Create Review data dictionary.

    Args:
        user_id: User's UUID
        card_id: Card's UUID
        quality: SM-2 quality rating (0-5)
        time_taken: Seconds spent on review
        reviewed_at: Review timestamp

    Returns:
        dict: Review data for model creation
    """
    if reviewed_at is None:
        reviewed_at = datetime.utcnow()

    return {
        "user_id": user_id,
        "card_id": card_id,
        "quality": quality,
        "time_taken": time_taken,
        "reviewed_at": reviewed_at,
    }


async def create_review(
    db_session: AsyncSession,
    user: User,
    card: Card,
    quality: int = ReviewRating.CORRECT_HESITANT,
    time_taken: int = 5,
    reviewed_at: datetime | None = None,
) -> Review:
    """Create a Review in the database.

    Args:
        db_session: Database session
        user: User who reviewed
        card: Card reviewed
        quality: SM-2 quality (0-5)
        time_taken: Seconds spent
        reviewed_at: Review timestamp

    Returns:
        Review: Created review record
    """
    review_data = create_review_data(
        user_id=user.id,
        card_id=card.id,
        quality=quality,
        time_taken=time_taken,
        reviewed_at=reviewed_at,
    )
    review = Review(**review_data)
    db_session.add(review)
    await db_session.commit()
    await db_session.refresh(review)
    return review


async def create_review_history(
    db_session: AsyncSession,
    user: User,
    card: Card,
    ratings: list[int],
    start_date: datetime | None = None,
) -> list[Review]:
    """Create a series of reviews for a card.

    Args:
        db_session: Database session
        user: User
        card: Card
        ratings: List of quality ratings in chronological order
        start_date: First review date (defaults to 30 days ago)

    Returns:
        list[Review]: Review history
    """
    if start_date is None:
        start_date = datetime.utcnow() - timedelta(days=30)

    reviews = []
    current_date = start_date

    for i, rating in enumerate(ratings):
        review = await create_review(
            db_session,
            user,
            card,
            quality=rating,
            time_taken=3 + i,  # Varying time
            reviewed_at=current_date,
        )
        reviews.append(review)
        # Space reviews by increasing intervals (simulating SM-2)
        current_date += timedelta(days=max(1, i * 2))

    return reviews


# =============================================================================
# Progress Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def user_deck_progress(
    db_session: AsyncSession,
    test_user: User,
    test_deck: Deck,
) -> AsyncGenerator[UserDeckProgress, None]:
    """Provide basic progress for test_user on test_deck.

    Creates progress with:
    - 5 cards studied
    - 2 cards mastered
    - Last studied today

    Yields:
        UserDeckProgress: User's progress on the deck
    """
    progress = await create_user_deck_progress(
        db_session,
        test_user,
        test_deck,
        cards_studied=5,
        cards_mastered=2,
        last_studied_at=datetime.utcnow(),
    )
    yield progress


@pytest_asyncio.fixture
async def fresh_user_progress(
    db_session: AsyncSession,
    test_user: User,
    test_deck: Deck,
) -> AsyncGenerator[UserDeckProgress, None]:
    """Provide progress for a user who just started.

    Creates progress with:
    - 0 cards studied
    - 0 cards mastered
    - Never studied

    Yields:
        UserDeckProgress: Fresh progress record
    """
    progress = await create_user_deck_progress(
        db_session,
        test_user,
        test_deck,
        cards_studied=0,
        cards_mastered=0,
        last_studied_at=None,
    )
    yield progress


@pytest_asyncio.fixture
async def completed_deck_progress(
    db_session: AsyncSession,
    test_user: User,
    deck_with_cards: DeckWithCards,
) -> AsyncGenerator[UserDeckProgress, None]:
    """Provide progress for a fully completed deck.

    Creates progress where all cards are studied and mastered.

    Yields:
        UserDeckProgress: Completed deck progress
    """
    card_count = len(deck_with_cards.cards)
    progress = await create_user_deck_progress(
        db_session,
        test_user,
        deck_with_cards.deck,
        cards_studied=card_count,
        cards_mastered=card_count,
        last_studied_at=datetime.utcnow(),
    )
    yield progress


# =============================================================================
# CardStatistics Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def new_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for a new (never reviewed) card.

    SM-2 values:
    - easiness_factor: 2.5 (default)
    - interval: 0
    - repetitions: 0
    - status: NEW

    Yields:
        CardStatistics: New card statistics
    """
    stats = await create_new_card_stats(db_session, test_user, test_card)
    yield stats


@pytest_asyncio.fixture
async def learning_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for a card in learning phase.

    SM-2 values:
    - easiness_factor: 2.36
    - interval: 1
    - repetitions: 2
    - status: LEARNING

    Yields:
        CardStatistics: Learning card statistics
    """
    stats = await create_learning_card_stats(db_session, test_user, test_card)
    yield stats


@pytest_asyncio.fixture
async def review_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for a card in review phase.

    SM-2 values:
    - easiness_factor: 2.5
    - interval: 10
    - repetitions: 5
    - status: REVIEW

    Yields:
        CardStatistics: Review card statistics
    """
    stats = await create_review_card_stats(db_session, test_user, test_card)
    yield stats


@pytest_asyncio.fixture
async def mastered_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for a fully mastered card.

    SM-2 values:
    - easiness_factor: 2.7
    - interval: 30
    - repetitions: 10
    - status: MASTERED

    Yields:
        CardStatistics: Mastered card statistics
    """
    stats = await create_mastered_card_stats(db_session, test_user, test_card)
    yield stats


@pytest_asyncio.fixture
async def due_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for a card due for review today.

    next_review_date is set to today.

    Yields:
        CardStatistics: Due card statistics
    """
    stats = await create_due_card_stats(db_session, test_user, test_card)
    yield stats


@pytest_asyncio.fixture
async def overdue_card_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardStatistics, None]:
    """Provide statistics for an overdue card (3 days past due).

    Yields:
        CardStatistics: Overdue card statistics
    """
    stats = await create_overdue_card_stats(
        db_session,
        test_user,
        test_card,
        days_overdue=3,
    )
    yield stats


@pytest_asyncio.fixture
async def cards_by_status(
    db_session: AsyncSession,
    test_user: User,
    deck_with_cards: DeckWithCards,
) -> AsyncGenerator[CardsByStatus, None]:
    """Provide cards grouped by SM-2 status.

    Creates statistics for 5 cards:
    - 1 NEW card
    - 2 LEARNING cards
    - 1 REVIEW card
    - 1 MASTERED card

    Yields:
        CardsByStatus: Named tuple with cards by status
    """
    cards = deck_with_cards.cards

    new_stats = [await create_new_card_stats(db_session, test_user, cards[0])]
    learning_stats = [
        await create_learning_card_stats(db_session, test_user, cards[1]),
        await create_learning_card_stats(db_session, test_user, cards[2]),
    ]
    review_stats = [await create_review_card_stats(db_session, test_user, cards[3])]
    mastered_stats = [await create_mastered_card_stats(db_session, test_user, cards[4])]

    yield CardsByStatus(
        new=new_stats,
        learning=learning_stats,
        review=review_stats,
        mastered=mastered_stats,
    )


@pytest_asyncio.fixture
async def multiple_due_cards(
    db_session: AsyncSession,
    test_user: User,
    deck_with_cards: DeckWithCards,
) -> AsyncGenerator[list[CardStatistics], None]:
    """Provide multiple cards due for review.

    Creates 3 cards all due today.

    Yields:
        list[CardStatistics]: List of due card statistics
    """
    cards = deck_with_cards.cards[:3]
    stats = []
    for card in cards:
        stat = await create_due_card_stats(db_session, test_user, card)
        stats.append(stat)
    yield stats


# =============================================================================
# Review Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def test_review(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[Review, None]:
    """Provide a single review record.

    Creates a review with:
    - quality: 4 (CORRECT_HESITANT)
    - time_taken: 5 seconds
    - reviewed_at: now

    Yields:
        Review: Single review record
    """
    review = await create_review(
        db_session,
        test_user,
        test_card,
        quality=ReviewRating.CORRECT_HESITANT,
        time_taken=5,
    )
    yield review


@pytest_asyncio.fixture
async def perfect_review(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[Review, None]:
    """Provide a perfect (quality=5) review.

    Yields:
        Review: Perfect review record
    """
    review = await create_review(
        db_session,
        test_user,
        test_card,
        quality=ReviewRating.PERFECT,
        time_taken=2,
    )
    yield review


@pytest_asyncio.fixture
async def failed_review(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[Review, None]:
    """Provide a failed (quality=0) review.

    Yields:
        Review: Failed review record
    """
    review = await create_review(
        db_session,
        test_user,
        test_card,
        quality=ReviewRating.BLACKOUT,
        time_taken=10,
    )
    yield review


@pytest_asyncio.fixture
async def review_history(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[list[Review], None]:
    """Provide a realistic review history for a card.

    Creates 5 reviews with mixed ratings:
    [3, 4, 3, 4, 5] - improving performance

    Yields:
        list[Review]: Review history
    """
    ratings = [
        ReviewRating.CORRECT_HARD,
        ReviewRating.CORRECT_HESITANT,
        ReviewRating.CORRECT_HARD,
        ReviewRating.CORRECT_HESITANT,
        ReviewRating.PERFECT,
    ]
    reviews = await create_review_history(
        db_session,
        test_user,
        test_card,
        ratings,
    )
    yield reviews


@pytest_asyncio.fixture
async def perfect_review_history(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[list[Review], None]:
    """Provide a history of all perfect reviews.

    Creates 5 reviews all with quality=5.

    Yields:
        list[Review]: Perfect review history
    """
    ratings = [ReviewRating.PERFECT] * 5
    reviews = await create_review_history(
        db_session,
        test_user,
        test_card,
        ratings,
    )
    yield reviews


@pytest_asyncio.fixture
async def struggling_review_history(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[list[Review], None]:
    """Provide a history showing struggle with a card.

    Creates reviews with poor/mixed ratings:
    [0, 1, 2, 1, 3] - many failures

    Yields:
        list[Review]: Struggling review history
    """
    ratings = [
        ReviewRating.BLACKOUT,
        ReviewRating.INCORRECT_HARD,
        ReviewRating.INCORRECT_EASY,
        ReviewRating.INCORRECT_HARD,
        ReviewRating.CORRECT_HARD,
    ]
    reviews = await create_review_history(
        db_session,
        test_user,
        test_card,
        ratings,
    )
    yield reviews


# =============================================================================
# Composite/Bundle Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def user_with_deck_progress(
    db_session: AsyncSession,
    test_user: User,
    test_deck: Deck,
) -> AsyncGenerator[UserProgress, None]:
    """Provide a user bundled with their deck progress.

    Yields:
        UserProgress: Named tuple with user, deck, and progress
    """
    progress = await create_user_deck_progress(
        db_session,
        test_user,
        test_deck,
        cards_studied=5,
        cards_mastered=2,
        last_studied_at=datetime.utcnow(),
    )
    yield UserProgress(user=test_user, deck=test_deck, progress=progress)


@pytest_asyncio.fixture
async def card_with_statistics(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[CardWithStatistics, None]:
    """Provide a card bundled with user statistics.

    Yields:
        CardWithStatistics: Named tuple with card and statistics
    """
    stats = await create_learning_card_stats(db_session, test_user, test_card)
    yield CardWithStatistics(card=test_card, statistics=stats)


@pytest_asyncio.fixture
async def card_with_review_history(
    db_session: AsyncSession,
    test_user: User,
    test_card: Card,
) -> AsyncGenerator[ReviewHistory, None]:
    """Provide a card with statistics and review history.

    Yields:
        ReviewHistory: Card, statistics, and reviews
    """
    stats = await create_review_card_stats(db_session, test_user, test_card)
    ratings = [3, 4, 4, 5, 4]
    reviews = await create_review_history(db_session, test_user, test_card, ratings)
    yield ReviewHistory(card=test_card, statistics=stats, reviews=reviews)


@pytest_asyncio.fixture
async def user_with_learning_progress(
    db_session: AsyncSession,
    test_user: User,
    deck_with_cards: DeckWithCards,
) -> AsyncGenerator[UserWithLearningData, None]:
    """Provide comprehensive learning data for a user.

    Creates:
    - User with deck progress
    - Card statistics for all cards
    - Review history for some cards

    This is the most comprehensive fixture for testing
    the full learning flow.

    Yields:
        UserWithLearningData: Complete learning data bundle
    """
    deck = deck_with_cards.deck
    cards = deck_with_cards.cards

    # Create deck progress
    progress = await create_user_deck_progress(
        db_session,
        test_user,
        deck,
        cards_studied=len(cards),
        cards_mastered=2,
        last_studied_at=datetime.utcnow(),
    )

    # Create card statistics with varying statuses
    card_statistics = []
    for i, card in enumerate(cards):
        if i == 0:
            stats = await create_new_card_stats(db_session, test_user, card)
        elif i < 3:
            stats = await create_learning_card_stats(db_session, test_user, card)
        elif i < 4:
            stats = await create_review_card_stats(db_session, test_user, card)
        else:
            stats = await create_mastered_card_stats(db_session, test_user, card)
        card_statistics.append(stats)

    # Create reviews for cards that have been studied
    reviews = []
    for i, card in enumerate(cards[1:4]):  # Skip first (new) card
        card_reviews = await create_review_history(
            db_session,
            test_user,
            card,
            [3, 4, 4],  # Simple history
        )
        reviews.extend(card_reviews)

    yield UserWithLearningData(
        user=test_user,
        deck=deck,
        cards=cards,
        progress=progress,
        card_statistics=card_statistics,
        reviews=reviews,
    )


@pytest_asyncio.fixture
async def two_users_same_deck(
    db_session: AsyncSession,
    two_users: tuple[User, User],
    deck_with_cards: DeckWithCards,
) -> AsyncGenerator[tuple[UserProgress, UserProgress], None]:
    """Provide two users with progress on the same deck.

    Useful for testing user isolation.

    Yields:
        tuple: Two UserProgress bundles for different users
    """
    user1, user2 = two_users
    deck = deck_with_cards.deck

    progress1 = await create_user_deck_progress(
        db_session,
        user1,
        deck,
        cards_studied=3,
        cards_mastered=1,
        last_studied_at=datetime.utcnow(),
    )
    progress2 = await create_user_deck_progress(
        db_session,
        user2,
        deck,
        cards_studied=5,
        cards_mastered=3,
        last_studied_at=datetime.utcnow() - timedelta(days=1),
    )

    yield (
        UserProgress(user=user1, deck=deck, progress=progress1),
        UserProgress(user=user2, deck=deck, progress=progress2),
    )
```

### 4.3 Updated `tests/fixtures/__init__.py`

```python
"""Test fixtures package.

This package contains reusable test fixtures:
- database.py: Database session and engine fixtures (PostgreSQL only)
- auth.py: Authentication-related fixtures (users, tokens, headers)
- deck.py: Deck and card fixtures with Greek vocabulary
- progress.py: Progress tracking and review fixtures for SM-2 testing

Import fixtures in conftest.py to make them available globally.

Available Database Fixtures:
    db_engine: Async PostgreSQL engine (creates/drops tables per test)
    db_session: Async session with automatic rollback
    db_session_with_savepoint: Session using savepoint pattern
    session_db_engine: Shared engine across test session (faster)
    fast_db_session: Session using shared engine (faster, less isolated)

Available Auth Fixtures:
    test_user: Regular active user
    test_superuser: Admin user with superuser privileges
    test_verified_user: User with verified email
    test_inactive_user: Deactivated user account
    test_user_tokens: JWT tokens for test_user
    auth_headers: Authorization headers for test_user
    superuser_auth_headers: Authorization headers for superuser
    authenticated_user: Complete bundle (user, tokens, headers)
    expired_access_token: Expired token for error testing
    invalid_token: Invalid token for error testing

Available Deck Fixtures:
    test_deck: Basic A1-level deck
    test_deck_a1, test_deck_a2, test_deck_b1: Level-specific decks
    test_card: Single test card
    test_cards: List of 5 test cards
    deck_with_cards: Deck with 5 A1 vocabulary cards
    deck_with_all_a1_cards: Deck with all 10 A1 vocabulary cards
    deck_with_a2_cards, deck_with_b1_cards: Level-specific decks with cards
    multi_level_decks: A1, A2, B1 decks bundle
    cards_by_difficulty: Cards grouped by difficulty
    inactive_deck: Deactivated deck
    empty_deck: Deck with no cards

Available Progress Fixtures:
    user_deck_progress: Basic progress for user on deck
    fresh_user_progress: Progress for new user (0 studied)
    completed_deck_progress: Progress with all cards mastered
    new_card_statistics: Card never reviewed (NEW status)
    learning_card_statistics: Card in learning phase
    review_card_statistics: Card in review phase
    mastered_card_statistics: Fully mastered card
    due_card_statistics: Card due for review today
    overdue_card_statistics: Card past due date
    cards_by_status: Cards grouped by SM-2 status

Available Review Fixtures:
    test_review: Single review record
    perfect_review: Perfect (quality=5) review
    failed_review: Failed (quality=0) review
    review_history: Mixed review history (5 reviews)
    perfect_review_history: All perfect reviews
    struggling_review_history: Poor performance history

Available Bundle Fixtures:
    user_with_deck_progress: User + deck + progress
    card_with_statistics: Card + statistics
    card_with_review_history: Card + statistics + reviews
    user_with_learning_progress: Complete learning data bundle
    two_users_same_deck: Two users studying same deck

Note: All fixtures use PostgreSQL. SQLite is not supported due to
      PostgreSQL-specific features (native enums, uuid_generate_v4, etc.).

Usage:
    # In conftest.py
    from tests.fixtures.database import db_engine, db_session
    from tests.fixtures.auth import test_user, auth_headers
    from tests.fixtures.deck import deck_with_cards, DeckWithCards
    from tests.fixtures.progress import user_with_learning_progress

    # In test files
    async def test_something(
        db_session: AsyncSession,
        deck_with_cards: DeckWithCards,
    ):
        deck = deck_with_cards.deck
        cards = deck_with_cards.cards
        ...
"""

# Database fixtures
from tests.fixtures.database import (
    clean_tables,
    create_test_engine,
    create_test_session_factory,
    db_engine,
    db_session,
    db_session_with_savepoint,
    db_url,
    fast_db_session,
    session_db_engine,
    verify_isolation,
)

# Auth fixtures
from tests.fixtures.auth import (
    # User fixtures
    test_user,
    test_superuser,
    test_verified_user,
    test_inactive_user,
    two_users,
    # Token fixtures
    test_user_tokens,
    superuser_tokens,
    access_token,
    refresh_token_value,
    # Header fixtures
    auth_headers,
    superuser_auth_headers,
    expired_auth_headers,
    # Bundle fixtures
    authenticated_user,
    authenticated_superuser,
    # Error testing fixtures
    expired_access_token,
    invalid_token,
    # Utility functions
    create_test_user_data,
    create_user_with_settings,
    create_tokens_for_user,
    create_auth_headers,
    # Types
    AuthTokens,
    AuthenticatedUser,
)

# Deck fixtures
from tests.fixtures.deck import (
    # Type definitions
    DeckWithCards,
    MultiLevelDecks,
    # Vocabulary data
    GREEK_VOCABULARY_A1,
    GREEK_VOCABULARY_A2,
    GREEK_VOCABULARY_B1,
    # Factory functions
    create_deck_data,
    create_card_data,
    create_deck,
    create_card,
    create_deck_with_vocabulary,
    # Core deck fixtures
    test_deck,
    test_deck_a1,
    test_deck_a2,
    test_deck_b1,
    inactive_deck,
    empty_deck,
    # Card fixtures
    test_card,
    test_cards,
    cards_by_difficulty,
    # Composite fixtures
    deck_with_cards,
    deck_with_all_a1_cards,
    deck_with_a2_cards,
    deck_with_b1_cards,
    multi_level_decks,
    two_decks,
    # Large dataset fixtures
    deck_with_many_cards,
)

# Progress fixtures
from tests.fixtures.progress import (
    # Type definitions
    UserProgress,
    CardWithStatistics,
    UserWithLearningData,
    CardsByStatus,
    ReviewHistory,
    # SM-2 constants
    SM2_DEFAULT_EASINESS_FACTOR,
    SM2_MIN_EASINESS_FACTOR,
    SM2_INTERVALS,
    # Factory functions - Progress
    create_progress_data,
    create_user_deck_progress,
    # Factory functions - Statistics
    create_statistics_data,
    create_card_statistics,
    create_new_card_stats,
    create_learning_card_stats,
    create_review_card_stats,
    create_mastered_card_stats,
    create_due_card_stats,
    create_overdue_card_stats,
    # Factory functions - Reviews
    create_review_data,
    create_review,
    create_review_history,
    # Progress fixtures
    user_deck_progress,
    fresh_user_progress,
    completed_deck_progress,
    # Card statistics fixtures
    new_card_statistics,
    learning_card_statistics,
    review_card_statistics,
    mastered_card_statistics,
    due_card_statistics,
    overdue_card_statistics,
    cards_by_status,
    multiple_due_cards,
    # Review fixtures
    test_review,
    perfect_review,
    failed_review,
    review_history,
    perfect_review_history,
    struggling_review_history,
    # Bundle fixtures
    user_with_deck_progress,
    card_with_statistics,
    card_with_review_history,
    user_with_learning_progress,
    two_users_same_deck,
)

__all__ = [
    # Database fixtures
    "db_engine",
    "db_session",
    "db_session_with_savepoint",
    "session_db_engine",
    "fast_db_session",
    "db_url",
    "clean_tables",
    "verify_isolation",
    "create_test_engine",
    "create_test_session_factory",
    # User fixtures
    "test_user",
    "test_superuser",
    "test_verified_user",
    "test_inactive_user",
    "two_users",
    # Token fixtures
    "test_user_tokens",
    "superuser_tokens",
    "access_token",
    "refresh_token_value",
    # Header fixtures
    "auth_headers",
    "superuser_auth_headers",
    "expired_auth_headers",
    # Bundle fixtures
    "authenticated_user",
    "authenticated_superuser",
    # Error testing fixtures
    "expired_access_token",
    "invalid_token",
    # Utility functions
    "create_test_user_data",
    "create_user_with_settings",
    "create_tokens_for_user",
    "create_auth_headers",
    # Types
    "AuthTokens",
    "AuthenticatedUser",
    # Deck type definitions
    "DeckWithCards",
    "MultiLevelDecks",
    # Vocabulary data
    "GREEK_VOCABULARY_A1",
    "GREEK_VOCABULARY_A2",
    "GREEK_VOCABULARY_B1",
    # Deck factory functions
    "create_deck_data",
    "create_card_data",
    "create_deck",
    "create_card",
    "create_deck_with_vocabulary",
    # Core deck fixtures
    "test_deck",
    "test_deck_a1",
    "test_deck_a2",
    "test_deck_b1",
    "inactive_deck",
    "empty_deck",
    # Card fixtures
    "test_card",
    "test_cards",
    "cards_by_difficulty",
    # Composite deck fixtures
    "deck_with_cards",
    "deck_with_all_a1_cards",
    "deck_with_a2_cards",
    "deck_with_b1_cards",
    "multi_level_decks",
    "two_decks",
    "deck_with_many_cards",
    # Progress type definitions
    "UserProgress",
    "CardWithStatistics",
    "UserWithLearningData",
    "CardsByStatus",
    "ReviewHistory",
    # SM-2 constants
    "SM2_DEFAULT_EASINESS_FACTOR",
    "SM2_MIN_EASINESS_FACTOR",
    "SM2_INTERVALS",
    # Progress factory functions
    "create_progress_data",
    "create_user_deck_progress",
    "create_statistics_data",
    "create_card_statistics",
    "create_new_card_stats",
    "create_learning_card_stats",
    "create_review_card_stats",
    "create_mastered_card_stats",
    "create_due_card_stats",
    "create_overdue_card_stats",
    "create_review_data",
    "create_review",
    "create_review_history",
    # Progress fixtures
    "user_deck_progress",
    "fresh_user_progress",
    "completed_deck_progress",
    # Card statistics fixtures
    "new_card_statistics",
    "learning_card_statistics",
    "review_card_statistics",
    "mastered_card_statistics",
    "due_card_statistics",
    "overdue_card_statistics",
    "cards_by_status",
    "multiple_due_cards",
    # Review fixtures
    "test_review",
    "perfect_review",
    "failed_review",
    "review_history",
    "perfect_review_history",
    "struggling_review_history",
    # Progress bundle fixtures
    "user_with_deck_progress",
    "card_with_statistics",
    "card_with_review_history",
    "user_with_learning_progress",
    "two_users_same_deck",
]
```

### 4.4 Updated `tests/conftest.py` (additions only)

Add the following imports to the existing conftest.py:

```python
# Add to existing imports section after auth imports

# Import deck fixtures from fixtures package
from tests.fixtures.deck import (
    # Type definitions
    DeckWithCards,
    MultiLevelDecks,
    # Core fixtures
    test_deck,
    test_deck_a1,
    test_deck_a2,
    test_deck_b1,
    inactive_deck,
    empty_deck,
    # Card fixtures
    test_card,
    test_cards,
    cards_by_difficulty,
    # Composite fixtures
    deck_with_cards,
    deck_with_all_a1_cards,
    deck_with_a2_cards,
    deck_with_b1_cards,
    multi_level_decks,
    two_decks,
    deck_with_many_cards,
)

# Import progress fixtures from fixtures package
from tests.fixtures.progress import (
    # Type definitions
    UserProgress,
    CardWithStatistics,
    UserWithLearningData,
    CardsByStatus,
    ReviewHistory,
    # Progress fixtures
    user_deck_progress,
    fresh_user_progress,
    completed_deck_progress,
    # Card statistics fixtures
    new_card_statistics,
    learning_card_statistics,
    review_card_statistics,
    mastered_card_statistics,
    due_card_statistics,
    overdue_card_statistics,
    cards_by_status,
    multiple_due_cards,
    # Review fixtures
    test_review,
    perfect_review,
    failed_review,
    review_history,
    perfect_review_history,
    struggling_review_history,
    # Bundle fixtures
    user_with_deck_progress,
    card_with_statistics,
    card_with_review_history,
    user_with_learning_progress,
    two_users_same_deck,
)

# Update __all__ list to include new fixtures
__all__ = [
    # ... existing exports ...
    # Deck fixtures
    "DeckWithCards",
    "MultiLevelDecks",
    "test_deck",
    "test_deck_a1",
    "test_deck_a2",
    "test_deck_b1",
    "inactive_deck",
    "empty_deck",
    "test_card",
    "test_cards",
    "cards_by_difficulty",
    "deck_with_cards",
    "deck_with_all_a1_cards",
    "deck_with_a2_cards",
    "deck_with_b1_cards",
    "multi_level_decks",
    "two_decks",
    "deck_with_many_cards",
    # Progress fixtures
    "UserProgress",
    "CardWithStatistics",
    "UserWithLearningData",
    "CardsByStatus",
    "ReviewHistory",
    "user_deck_progress",
    "fresh_user_progress",
    "completed_deck_progress",
    "new_card_statistics",
    "learning_card_statistics",
    "review_card_statistics",
    "mastered_card_statistics",
    "due_card_statistics",
    "overdue_card_statistics",
    "cards_by_status",
    "multiple_due_cards",
    "test_review",
    "perfect_review",
    "failed_review",
    "review_history",
    "perfect_review_history",
    "struggling_review_history",
    "user_with_deck_progress",
    "card_with_statistics",
    "card_with_review_history",
    "user_with_learning_progress",
    "two_users_same_deck",
]
```

---

## 5. Test File Examples

### 5.1 Example: Testing Deck API

```python
"""Example tests using deck fixtures."""

import pytest
from httpx import AsyncClient

from src.db.models import DeckLevel
from tests.fixtures.deck import DeckWithCards


@pytest.mark.integration
class TestDeckAPI:
    """Integration tests for deck endpoints."""

    async def test_list_decks_returns_active_only(
        self,
        client: AsyncClient,
        deck_with_cards: DeckWithCards,
        inactive_deck,
        auth_headers: dict[str, str],
    ):
        """Test that listing decks excludes inactive decks."""
        response = await client.get(
            "/api/v1/decks",
            headers=auth_headers,
        )
        assert response.status_code == 200
        decks = response.json()["data"]

        # Should include active deck
        deck_ids = [d["id"] for d in decks]
        assert str(deck_with_cards.deck.id) in deck_ids

        # Should not include inactive deck
        assert str(inactive_deck.id) not in deck_ids

    async def test_get_deck_cards(
        self,
        client: AsyncClient,
        deck_with_cards: DeckWithCards,
        auth_headers: dict[str, str],
    ):
        """Test retrieving cards from a deck."""
        deck_id = deck_with_cards.deck.id

        response = await client.get(
            f"/api/v1/decks/{deck_id}/cards",
            headers=auth_headers,
        )
        assert response.status_code == 200

        cards = response.json()["data"]
        assert len(cards) == len(deck_with_cards.cards)

    async def test_filter_decks_by_level(
        self,
        client: AsyncClient,
        multi_level_decks,
        auth_headers: dict[str, str],
    ):
        """Test filtering decks by CEFR level."""
        response = await client.get(
            "/api/v1/decks?level=A1",
            headers=auth_headers,
        )
        assert response.status_code == 200

        decks = response.json()["data"]
        for deck in decks:
            assert deck["level"] == "A1"
```

### 5.2 Example: Testing SM-2 Algorithm

```python
"""Example tests using progress fixtures for SM-2."""

import pytest
from datetime import date

from src.db.models import CardStatus
from tests.fixtures.progress import CardsByStatus, UserWithLearningData


class TestSM2Algorithm:
    """Unit tests for SM-2 spaced repetition algorithm."""

    async def test_new_card_initial_values(self, new_card_statistics):
        """Test that new cards have correct initial SM-2 values."""
        stats = new_card_statistics

        assert stats.status == CardStatus.NEW
        assert stats.easiness_factor == 2.5
        assert stats.interval == 0
        assert stats.repetitions == 0

    async def test_learning_card_has_short_interval(self, learning_card_statistics):
        """Test that learning cards have short review intervals."""
        stats = learning_card_statistics

        assert stats.status == CardStatus.LEARNING
        assert stats.interval <= 3  # Short interval during learning
        assert stats.repetitions > 0

    async def test_mastered_card_has_long_interval(self, mastered_card_statistics):
        """Test that mastered cards have long review intervals."""
        stats = mastered_card_statistics

        assert stats.status == CardStatus.MASTERED
        assert stats.interval >= 21  # Long interval for mastered
        assert stats.easiness_factor >= 2.5  # High EF from success

    async def test_due_cards_query(self, multiple_due_cards):
        """Test querying for cards due today."""
        today = date.today()

        for stats in multiple_due_cards:
            assert stats.next_review_date <= today

    async def test_cards_by_status_distribution(self, cards_by_status: CardsByStatus):
        """Test that cards are correctly distributed by status."""
        assert len(cards_by_status.new) == 1
        assert len(cards_by_status.learning) == 2
        assert len(cards_by_status.review) == 1
        assert len(cards_by_status.mastered) == 1


class TestReviewProcessing:
    """Tests for review processing."""

    async def test_perfect_reviews_improve_easiness(self, perfect_review_history):
        """Test that perfect reviews should increase EF."""
        reviews = perfect_review_history

        # All reviews should be quality 5
        for review in reviews:
            assert review.quality == 5

    async def test_struggling_reviews_tracked(self, struggling_review_history):
        """Test that struggling reviews are tracked."""
        reviews = struggling_review_history

        # Should have multiple low-quality reviews
        low_quality = [r for r in reviews if r.quality < 3]
        assert len(low_quality) >= 3
```

### 5.3 Example: Testing User Progress

```python
"""Example tests using comprehensive progress fixtures."""

import pytest

from tests.fixtures.progress import UserWithLearningData, UserProgress


class TestUserProgress:
    """Tests for user progress tracking."""

    async def test_user_deck_progress_tracking(
        self,
        user_with_deck_progress: UserProgress,
    ):
        """Test that user progress is tracked correctly."""
        user = user_with_deck_progress.user
        deck = user_with_deck_progress.deck
        progress = user_with_deck_progress.progress

        assert progress.user_id == user.id
        assert progress.deck_id == deck.id
        assert progress.cards_studied > 0
        assert progress.cards_mastered <= progress.cards_studied

    async def test_comprehensive_learning_data(
        self,
        user_with_learning_progress: UserWithLearningData,
    ):
        """Test comprehensive learning data bundle."""
        data = user_with_learning_progress

        # All relationships should be consistent
        assert data.progress.user_id == data.user.id
        assert data.progress.deck_id == data.deck.id
        assert len(data.card_statistics) == len(data.cards)

        # Should have reviews for studied cards
        assert len(data.reviews) > 0

    async def test_user_isolation(
        self,
        two_users_same_deck,
    ):
        """Test that user progress is isolated."""
        progress1, progress2 = two_users_same_deck

        # Same deck, different users
        assert progress1.deck.id == progress2.deck.id
        assert progress1.user.id != progress2.user.id

        # Progress should be independent
        assert progress1.progress.cards_studied != progress2.progress.cards_studied
```

---

## 6. Integration with Base Test Classes

The fixtures integrate seamlessly with existing base test classes:

```python
"""Using fixtures with BaseTestCase."""

from tests.base import BaseTestCase, AuthenticatedTestCase
from tests.fixtures.deck import DeckWithCards
from tests.fixtures.progress import UserWithLearningData


class TestDeckOperations(BaseTestCase):
    """Tests using BaseTestCase utilities with fixtures."""

    async def test_create_additional_cards(
        self,
        db_session,
        deck_with_cards: DeckWithCards,
    ):
        """Test creating additional cards in a deck."""
        deck = deck_with_cards.deck
        initial_count = len(deck_with_cards.cards)

        # Use BaseTestCase method to create more cards
        new_card = await self.create_test_card(
            db_session,
            deck,
            front_text="Neos",
            back_text="New",
        )

        assert new_card.deck_id == deck.id
        # (Would need to refresh deck.cards to see new count)


class TestAuthenticatedDeckAccess(AuthenticatedTestCase):
    """Tests using AuthenticatedTestCase with deck fixtures."""

    async def test_authenticated_deck_access(
        self,
        client,
        authenticated_user,
        deck_with_cards: DeckWithCards,
    ):
        """Test that authenticated users can access decks."""
        response = await self.get_authenticated(
            client,
            f"/api/v1/decks/{deck_with_cards.deck.id}",
            authenticated_user.headers,
        )
        self.assert_response_success(response)
```

---

## 7. Verification Steps

### 7.1 Pre-Implementation Verification

```bash
# Verify PostgreSQL is running
docker ps --filter "name=learn-greek-postgres"

# Verify existing tests pass
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/fixtures/ -v
```

### 7.2 Post-Implementation Verification

```bash
# Run all fixture tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/fixtures/ -v

# Verify imports work
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run python -c "
from tests.fixtures import (
    deck_with_cards,
    user_with_learning_progress,
    cards_by_status,
    DeckWithCards,
    UserWithLearningData,
)
print('All imports successful!')
"

# Run a quick integration test
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest -v -k "deck" --collect-only
```

### 7.3 Test Coverage Verification

```bash
# Run tests with coverage
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest --cov=tests/fixtures --cov-report=term-missing
```

---

## 8. Implementation Checklist

### 8.1 Files to Create

- [ ] `tests/fixtures/deck.py`
  - [ ] Type definitions (DeckWithCards, MultiLevelDecks)
  - [ ] Greek vocabulary data (A1, A2, B1)
  - [ ] Factory functions (create_deck, create_card, create_deck_with_vocabulary)
  - [ ] Core deck fixtures (test_deck, test_deck_a1, test_deck_a2, test_deck_b1)
  - [ ] Card fixtures (test_card, test_cards, cards_by_difficulty)
  - [ ] Composite fixtures (deck_with_cards, multi_level_decks)
  - [ ] Large dataset fixtures (deck_with_many_cards)

- [ ] `tests/fixtures/progress.py`
  - [ ] Type definitions (UserProgress, CardWithStatistics, UserWithLearningData, CardsByStatus, ReviewHistory)
  - [ ] SM-2 constants
  - [ ] Factory functions for UserDeckProgress
  - [ ] Factory functions for CardStatistics (new, learning, review, mastered, due, overdue)
  - [ ] Factory functions for Review
  - [ ] Progress fixtures
  - [ ] CardStatistics fixtures by status
  - [ ] Review fixtures (single, history, perfect, struggling)
  - [ ] Bundle fixtures (user_with_learning_progress)

### 8.2 Files to Update

- [ ] `tests/fixtures/__init__.py`
  - [ ] Import deck fixtures and types
  - [ ] Import progress fixtures and types
  - [ ] Update __all__ list
  - [ ] Update module docstring

- [ ] `tests/conftest.py`
  - [ ] Import deck fixtures
  - [ ] Import progress fixtures
  - [ ] Update __all__ list

### 8.3 Verification Tasks

- [ ] All imports work without errors
- [ ] All fixtures can be instantiated
- [ ] Fixtures integrate with existing auth fixtures
- [ ] Fixtures integrate with db_session
- [ ] Greek vocabulary is realistic and educational
- [ ] SM-2 values are realistic
- [ ] Type hints are correct
- [ ] Docstrings are complete

---

## 9. Acceptance Criteria

### 9.1 Functional Requirements

- [ ] All deck fixtures create valid Deck models
- [ ] All card fixtures create valid Card models with Greek content
- [ ] All progress fixtures create valid UserDeckProgress models
- [ ] All statistics fixtures create valid CardStatistics with SM-2 values
- [ ] All review fixtures create valid Review models
- [ ] Bundle fixtures provide complete data for complex test scenarios
- [ ] Factory functions support customization

### 9.2 Non-Functional Requirements

- [ ] Fixtures are performant (no unnecessary queries)
- [ ] Code follows established patterns from auth.py
- [ ] Type hints are accurate and complete
- [ ] Docstrings describe usage and examples
- [ ] Greek vocabulary is authentic and educational

### 9.3 Integration Requirements

- [ ] Fixtures work with db_session (automatic rollback)
- [ ] Fixtures work with test_user and auth fixtures
- [ ] Fixtures can be composed together
- [ ] Fixtures support user isolation testing

---

## 10. Related Documents

- [04-backend-testing-framework-plan.md](./04-backend-testing-framework-plan.md) - Parent task
- [04.01-pytest-async-configuration-plan.md](./04.01-pytest-async-configuration-plan.md) - Pytest configuration
- [04.02-test-database-fixtures-plan.md](./04.02-test-database-fixtures-plan.md) - Database fixtures
- [04.03-base-test-classes-plan.md](./04.03-base-test-classes-plan.md) - Base test classes
- [Backend-Tasks-Progress.md](../Backend-Tasks-Progress.md) - Task tracking

---

**Document Version**: 1.0
**Created**: 2025-11-30
**Author**: Architecture Team
**Status**: Ready for Implementation
**Priority**: Critical Path
**Estimated Duration**: 2-3 hours
