# Subtask 04.03: Create Base Test Classes

**Document Version**: 1.1
**Created**: 2025-11-30
**Completed**: 2025-11-30
**Status**: ✅ COMPLETED
**Priority**: High (Foundation for organized testing)
**Dependencies**: Task 04.01 (Pytest Async Configuration), Task 04.02 (Test Database Fixtures)

**Implementation Summary**:
- Created `tests/fixtures/auth.py` with 17 fixtures (users, tokens, headers, bundles, error cases)
- Created `tests/base.py` with BaseTestCase (11 methods) and AuthenticatedTestCase (10 methods)
- Created `tests/unit/test_base_classes.py` with 41 comprehensive tests
- Updated `tests/fixtures/__init__.py` and `tests/conftest.py` to export fixtures
- QA Report: [task-04.03-verification.md](../../qa/task-04.03-verification.md)
- All 41 tests passing

---

## Table of Contents

1. [Overview](#overview)
2. [Current State Analysis](#current-state-analysis)
3. [Architecture Design](#architecture-design)
4. [Implementation Details](#implementation-details)
5. [Test Patterns](#test-patterns)
6. [Implementation Checklist](#implementation-checklist)
7. [Acceptance Criteria](#acceptance-criteria)
8. [Troubleshooting Guide](#troubleshooting-guide)

---

## Overview

### Objective

Create reusable base test classes (`BaseTestCase`, `AuthenticatedTestCase`) that provide common testing infrastructure, reduce boilerplate code, and establish consistent patterns across all backend tests.

### What You'll Build

**New Files**:
1. `tests/base.py` - Base test classes (BaseTestCase, AuthenticatedTestCase)
2. `tests/fixtures/auth.py` - Authentication-related fixtures (users, tokens, auth headers)
3. `tests/unit/test_base_classes.py` - Tests for the base classes themselves

**Modified Files**:
1. `tests/conftest.py` - Import and expose auth fixtures globally
2. `tests/fixtures/__init__.py` - Export auth fixtures

**Key Features**:
- `BaseTestCase` - Common utilities for all tests
- `AuthenticatedTestCase` - Pre-configured authenticated user fixtures
- Test user factories with various states (verified, unverified, admin)
- Ready-to-use auth headers for API testing
- Utility methods for common assertions and operations

### Success Criteria

- [x] `BaseTestCase` provides common test utilities
- [x] `AuthenticatedTestCase` extends `BaseTestCase` with authentication fixtures
- [x] All existing tests continue to pass
- [x] New base class tests pass (15+ tests) - **41 tests passing**
- [x] Authentication fixtures create valid JWT tokens
- [x] Test users can have different states (active, inactive, superuser)
- [x] Auth headers are properly formatted for API requests

---

## Current State Analysis

### Existing Infrastructure (from 04.01 and 04.02)

**From `tests/conftest.py`**:
- Event loop configuration for async tests
- Pytest markers (unit, integration, slow, auth, api, db)
- `client` fixture for HTTP testing with `AsyncClient`
- Sample data fixtures (`sample_email`, `sample_password`, `sample_user_data`)
- `test_settings` fixture with JWT configuration

**From `tests/fixtures/database.py`**:
- `db_engine` - Async PostgreSQL engine with table management
- `db_session` - Async session with automatic rollback
- `db_session_with_savepoint` - Session with savepoint pattern
- `session_db_engine` - Session-scoped engine for faster tests
- `fast_db_session` - Fast session using shared engine

**From `tests/helpers/database.py`**:
- `get_test_database_url()` - Get test database URL
- `count_table_rows()` - Count rows in a table
- `table_exists()` - Check if table exists
- `verify_connection()` - Verify database connection
- Timestamp utilities (`utc_now`, `days_ago`, `days_from_now`)

### Authentication Infrastructure (from src/core/)

**From `src/core/security.py`**:
- `hash_password()` - Hash passwords with bcrypt
- `verify_password()` - Verify password against hash
- `create_access_token()` - Create JWT access tokens
- `create_refresh_token()` - Create JWT refresh tokens
- `verify_token()` - Verify and decode JWT tokens

**From `src/db/models.py`**:
- `User` model with email, password_hash, full_name, is_active, is_superuser
- `UserSettings` model for user preferences
- `RefreshToken` model for session management

---

## Architecture Design

### Class Hierarchy

```
BaseTestCase
    |
    +-- Common utilities and assertions
    +-- Database session access
    +-- Utility methods for data creation
    |
    v
AuthenticatedTestCase (extends BaseTestCase)
    |
    +-- Pre-created test users
    +-- Valid JWT tokens
    +-- Auth headers for API requests
    +-- User variants (normal, superuser, unverified)
```

### File Structure

```
tests/
├── base.py                          <- NEW: Base test classes
├── conftest.py                      <- MODIFIED: Import auth fixtures
├── fixtures/
│   ├── __init__.py                  <- MODIFIED: Export auth fixtures
│   ├── database.py                  <- EXISTING: Database fixtures
│   └── auth.py                      <- NEW: Authentication fixtures
├── helpers/
│   ├── __init__.py
│   └── database.py                  <- EXISTING: Database helpers
└── unit/
    ├── test_base_classes.py         <- NEW: Tests for base classes
    └── ...
```

### Design Decisions

1. **Composition over Inheritance for Fixtures**
   - Fixtures are composable and reusable
   - Base classes provide utility methods, not fixture inheritance
   - This works better with pytest's fixture system

2. **PostgreSQL-Only Testing**
   - All fixtures use PostgreSQL (matching production)
   - No SQLite fallback needed
   - Consistent with Task 04.02 decisions

3. **Async-First Design**
   - All fixtures are async-compatible
   - Uses `pytest_asyncio` for async fixture handling
   - Matches the async FastAPI/SQLAlchemy stack

4. **Token-Based Authentication**
   - Test users get real JWT tokens
   - Tokens are valid and can be verified
   - Supports testing token expiration scenarios

---

## Implementation Details

### STEP 1: Create Authentication Fixtures

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/fixtures/auth.py`

```python
"""Authentication fixtures for testing.

This module provides comprehensive authentication fixtures:
- test_user: A regular active user
- test_superuser: A superuser for admin testing
- test_unverified_user: User without email verification
- test_inactive_user: Deactivated user account
- auth_headers: Pre-built Authorization headers
- access_token: Valid JWT access token
- refresh_token: Valid JWT refresh token

All fixtures use PostgreSQL and integrate with the db_session fixture.

Usage:
    async def test_protected_endpoint(client: AsyncClient, auth_headers: dict):
        response = await client.get("/api/v1/protected", headers=auth_headers)
        assert response.status_code == 200

    async def test_admin_only(client: AsyncClient, superuser_auth_headers: dict):
        response = await client.delete("/api/v1/admin/users/123", headers=superuser_auth_headers)
        assert response.status_code == 200
"""

from collections.abc import AsyncGenerator
from datetime import datetime, timedelta
from typing import Any, NamedTuple
from uuid import uuid4

import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.security import create_access_token, create_refresh_token, hash_password
from src.db.models import RefreshToken, User, UserSettings


# =============================================================================
# Type Definitions
# =============================================================================


class AuthTokens(NamedTuple):
    """Container for access and refresh tokens with expiry info."""

    access_token: str
    refresh_token: str
    access_expires: datetime
    refresh_expires: datetime


class AuthenticatedUser(NamedTuple):
    """Container for user with tokens and headers."""

    user: User
    tokens: AuthTokens
    headers: dict[str, str]


# =============================================================================
# User Data Factories
# =============================================================================


def create_test_user_data(
    email: str | None = None,
    password: str = "TestPassword123!",
    full_name: str = "Test User",
    is_active: bool = True,
    is_superuser: bool = False,
    email_verified: bool = False,
) -> dict[str, Any]:
    """Create test user data dictionary.

    Args:
        email: User email (auto-generated if None)
        password: Plain text password (will be hashed)
        full_name: User's full name
        is_active: Whether user account is active
        is_superuser: Whether user has superuser privileges
        email_verified: Whether email is verified

    Returns:
        dict: User data ready for User model creation
    """
    if email is None:
        email = f"testuser_{uuid4().hex[:8]}@example.com"

    return {
        "email": email,
        "password_hash": hash_password(password),
        "full_name": full_name,
        "is_active": is_active,
        "is_superuser": is_superuser,
        "email_verified_at": datetime.utcnow() if email_verified else None,
    }


async def create_user_with_settings(
    db_session: AsyncSession,
    user_data: dict[str, Any],
    daily_goal: int = 20,
    email_notifications: bool = True,
) -> User:
    """Create a user with associated settings in the database.

    Args:
        db_session: Database session
        user_data: User attributes dictionary
        daily_goal: Daily learning goal
        email_notifications: Email notification preference

    Returns:
        User: Created user with settings
    """
    user = User(**user_data)
    db_session.add(user)
    await db_session.flush()

    settings = UserSettings(
        user_id=user.id,
        daily_goal=daily_goal,
        email_notifications=email_notifications,
    )
    db_session.add(settings)
    await db_session.commit()
    await db_session.refresh(user)

    return user


def create_tokens_for_user(user: User) -> AuthTokens:
    """Create JWT tokens for a user.

    Args:
        user: User to create tokens for

    Returns:
        AuthTokens: Container with access and refresh tokens
    """
    access_token, access_expires = create_access_token(user.id)
    refresh_token, refresh_expires = create_refresh_token(user.id)

    return AuthTokens(
        access_token=access_token,
        refresh_token=refresh_token,
        access_expires=access_expires,
        refresh_expires=refresh_expires,
    )


def create_auth_headers(access_token: str) -> dict[str, str]:
    """Create Authorization headers for HTTP requests.

    Args:
        access_token: JWT access token

    Returns:
        dict: Headers with Bearer token
    """
    return {"Authorization": f"Bearer {access_token}"}


# =============================================================================
# Core User Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def test_user(db_session: AsyncSession) -> AsyncGenerator[User, None]:
    """Provide a regular active test user.

    Creates a user with:
    - Valid email and password
    - Active account (is_active=True)
    - Regular user (is_superuser=False)
    - Unverified email (email_verified_at=None)

    Yields:
        User: The created test user
    """
    user_data = create_test_user_data(
        full_name="Regular Test User",
        is_active=True,
        is_superuser=False,
        email_verified=False,
    )
    user = await create_user_with_settings(db_session, user_data)
    yield user


@pytest_asyncio.fixture
async def test_superuser(db_session: AsyncSession) -> AsyncGenerator[User, None]:
    """Provide a superuser for admin testing.

    Creates a user with:
    - Valid email and password
    - Active account (is_active=True)
    - Superuser privileges (is_superuser=True)
    - Verified email

    Yields:
        User: The created superuser
    """
    user_data = create_test_user_data(
        email=f"admin_{uuid4().hex[:8]}@example.com",
        full_name="Admin Superuser",
        is_active=True,
        is_superuser=True,
        email_verified=True,
    )
    user = await create_user_with_settings(db_session, user_data)
    yield user


@pytest_asyncio.fixture
async def test_verified_user(db_session: AsyncSession) -> AsyncGenerator[User, None]:
    """Provide a user with verified email.

    Creates a user with:
    - Valid email and password
    - Active account
    - Regular user (not superuser)
    - Verified email (email_verified_at set)

    Yields:
        User: The created verified user
    """
    user_data = create_test_user_data(
        full_name="Verified User",
        is_active=True,
        is_superuser=False,
        email_verified=True,
    )
    user = await create_user_with_settings(db_session, user_data)
    yield user


@pytest_asyncio.fixture
async def test_inactive_user(db_session: AsyncSession) -> AsyncGenerator[User, None]:
    """Provide an inactive/deactivated user.

    Creates a user with:
    - Valid email and password
    - Inactive account (is_active=False)
    - Regular user

    Use this to test that inactive users cannot authenticate.

    Yields:
        User: The created inactive user
    """
    user_data = create_test_user_data(
        full_name="Inactive User",
        is_active=False,
        is_superuser=False,
    )
    user = await create_user_with_settings(db_session, user_data)
    yield user


# =============================================================================
# Token Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def test_user_tokens(test_user: User) -> AuthTokens:
    """Provide valid JWT tokens for the test user.

    Args:
        test_user: The test user fixture

    Returns:
        AuthTokens: Named tuple with access_token, refresh_token, and expiry times
    """
    return create_tokens_for_user(test_user)


@pytest_asyncio.fixture
async def superuser_tokens(test_superuser: User) -> AuthTokens:
    """Provide valid JWT tokens for the superuser.

    Args:
        test_superuser: The superuser fixture

    Returns:
        AuthTokens: Named tuple with access_token, refresh_token, and expiry times
    """
    return create_tokens_for_user(test_superuser)


@pytest_asyncio.fixture
async def access_token(test_user_tokens: AuthTokens) -> str:
    """Provide just the access token string.

    Convenience fixture for tests that only need the access token.

    Args:
        test_user_tokens: The test user tokens fixture

    Returns:
        str: JWT access token
    """
    return test_user_tokens.access_token


@pytest_asyncio.fixture
async def refresh_token_value(
    test_user: User,
    test_user_tokens: AuthTokens,
    db_session: AsyncSession,
) -> str:
    """Provide a refresh token that's stored in the database.

    This fixture creates a valid refresh token AND stores it in the
    database, which is required for token refresh operations.

    Args:
        test_user: The test user
        test_user_tokens: The test user tokens
        db_session: Database session

    Returns:
        str: JWT refresh token (stored in database)
    """
    # Store refresh token in database
    db_refresh_token = RefreshToken(
        user_id=test_user.id,
        token=test_user_tokens.refresh_token,
        expires_at=test_user_tokens.refresh_expires,
    )
    db_session.add(db_refresh_token)
    await db_session.commit()

    return test_user_tokens.refresh_token


# =============================================================================
# Auth Headers Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def auth_headers(test_user_tokens: AuthTokens) -> dict[str, str]:
    """Provide Authorization headers for the test user.

    Ready-to-use headers for making authenticated HTTP requests.

    Args:
        test_user_tokens: The test user tokens fixture

    Returns:
        dict: Headers with "Authorization: Bearer <token>"

    Example:
        async def test_protected_endpoint(client, auth_headers):
            response = await client.get("/api/v1/me", headers=auth_headers)
            assert response.status_code == 200
    """
    return create_auth_headers(test_user_tokens.access_token)


@pytest_asyncio.fixture
async def superuser_auth_headers(superuser_tokens: AuthTokens) -> dict[str, str]:
    """Provide Authorization headers for the superuser.

    Ready-to-use headers for making authenticated admin requests.

    Args:
        superuser_tokens: The superuser tokens fixture

    Returns:
        dict: Headers with "Authorization: Bearer <token>"

    Example:
        async def test_admin_endpoint(client, superuser_auth_headers):
            response = await client.delete("/api/v1/admin/users/123", headers=superuser_auth_headers)
            assert response.status_code == 200
    """
    return create_auth_headers(superuser_tokens.access_token)


# =============================================================================
# Authenticated User Bundle Fixtures
# =============================================================================


@pytest_asyncio.fixture
async def authenticated_user(
    test_user: User,
    test_user_tokens: AuthTokens,
    auth_headers: dict[str, str],
) -> AuthenticatedUser:
    """Provide a complete authenticated user bundle.

    This fixture bundles together the user, their tokens, and auth headers
    for convenient use in tests that need all of these.

    Args:
        test_user: The test user
        test_user_tokens: The test user tokens
        auth_headers: The auth headers

    Returns:
        AuthenticatedUser: Named tuple with user, tokens, and headers

    Example:
        async def test_something(authenticated_user):
            user = authenticated_user.user
            headers = authenticated_user.headers
            tokens = authenticated_user.tokens
    """
    return AuthenticatedUser(
        user=test_user,
        tokens=test_user_tokens,
        headers=auth_headers,
    )


@pytest_asyncio.fixture
async def authenticated_superuser(
    test_superuser: User,
    superuser_tokens: AuthTokens,
    superuser_auth_headers: dict[str, str],
) -> AuthenticatedUser:
    """Provide a complete authenticated superuser bundle.

    Similar to authenticated_user but with superuser privileges.

    Args:
        test_superuser: The superuser
        superuser_tokens: The superuser tokens
        superuser_auth_headers: The superuser auth headers

    Returns:
        AuthenticatedUser: Named tuple with user, tokens, and headers
    """
    return AuthenticatedUser(
        user=test_superuser,
        tokens=superuser_tokens,
        headers=superuser_auth_headers,
    )


# =============================================================================
# Expired Token Fixtures (for testing expiration handling)
# =============================================================================


@pytest.fixture
def expired_access_token() -> str:
    """Provide an expired access token for testing expiration handling.

    Creates a token that expired 1 hour ago.

    Returns:
        str: Expired JWT access token

    Warning:
        This token will fail validation. Use for testing error handling.
    """
    from jose import jwt
    from src.config import settings

    payload = {
        "sub": str(uuid4()),
        "exp": datetime.utcnow() - timedelta(hours=1),  # Expired 1 hour ago
        "iat": datetime.utcnow() - timedelta(hours=2),
        "type": "access",
    }
    return jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)


@pytest.fixture
def invalid_token() -> str:
    """Provide a malformed/invalid token for testing error handling.

    Returns:
        str: Invalid JWT token string
    """
    return "invalid.token.string"


@pytest.fixture
def expired_auth_headers(expired_access_token: str) -> dict[str, str]:
    """Provide Authorization headers with an expired token.

    Args:
        expired_access_token: The expired token fixture

    Returns:
        dict: Headers with expired Bearer token
    """
    return create_auth_headers(expired_access_token)


# =============================================================================
# Multiple Users Fixtures (for testing user isolation)
# =============================================================================


@pytest_asyncio.fixture
async def two_users(db_session: AsyncSession) -> AsyncGenerator[tuple[User, User], None]:
    """Provide two different users for testing user isolation.

    Useful for testing that users cannot access each other's data.

    Yields:
        tuple[User, User]: Two different active users
    """
    user1_data = create_test_user_data(
        email=f"user1_{uuid4().hex[:8]}@example.com",
        full_name="User One",
    )
    user2_data = create_test_user_data(
        email=f"user2_{uuid4().hex[:8]}@example.com",
        full_name="User Two",
    )

    user1 = await create_user_with_settings(db_session, user1_data)
    user2 = await create_user_with_settings(db_session, user2_data)

    yield user1, user2
```

### STEP 2: Create Base Test Classes

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/base.py`

```python
"""Base test classes for Learn Greek Easy backend tests.

This module provides reusable base classes that encapsulate common
testing patterns and utilities:

- BaseTestCase: Foundation for all tests with common utilities
- AuthenticatedTestCase: Extends BaseTestCase with authentication helpers

These classes are designed to work with pytest fixtures and provide
utility methods rather than fixture inheritance (which doesn't work well
with pytest's fixture system).

Usage:
    class TestMyFeature(BaseTestCase):
        async def test_something(self, db_session):
            user = await self.create_test_user(db_session)
            assert user.email is not None

    class TestProtectedEndpoint(AuthenticatedTestCase):
        async def test_with_auth(self, client, authenticated_user):
            response = await self.make_authenticated_request(
                client, "GET", "/api/v1/me", authenticated_user.headers
            )
            assert response.status_code == 200
"""

from datetime import datetime, timedelta
from typing import Any, Optional
from uuid import UUID, uuid4

import pytest
from httpx import AsyncClient, Response
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.security import create_access_token, hash_password
from src.db.models import Card, CardDifficulty, Deck, DeckLevel, User, UserSettings


class BaseTestCase:
    """Base class for all test cases providing common utilities.

    This class provides:
    - User creation utilities
    - Deck and card creation utilities
    - Common assertions
    - Database helper methods
    - Timestamp utilities

    All methods are designed to work with pytest fixtures passed as arguments.
    This class does NOT define fixtures itself.

    Example:
        class TestUsers(BaseTestCase):
            async def test_create_user(self, db_session):
                user = await self.create_test_user(db_session)
                assert user.id is not None
                assert user.is_active is True
    """

    # =========================================================================
    # User Creation Utilities
    # =========================================================================

    async def create_test_user(
        self,
        db_session: AsyncSession,
        email: str | None = None,
        password: str = "TestPassword123!",
        full_name: str = "Test User",
        is_active: bool = True,
        is_superuser: bool = False,
        email_verified: bool = False,
    ) -> User:
        """Create a test user in the database.

        Args:
            db_session: Database session
            email: User email (auto-generated if None)
            password: Plain text password
            full_name: User's full name
            is_active: Whether account is active
            is_superuser: Whether user has admin privileges
            email_verified: Whether email is verified

        Returns:
            User: Created user with settings
        """
        if email is None:
            email = f"test_{uuid4().hex[:8]}@example.com"

        user = User(
            email=email,
            password_hash=hash_password(password),
            full_name=full_name,
            is_active=is_active,
            is_superuser=is_superuser,
            email_verified_at=datetime.utcnow() if email_verified else None,
        )
        db_session.add(user)
        await db_session.flush()

        settings = UserSettings(
            user_id=user.id,
            daily_goal=20,
            email_notifications=True,
        )
        db_session.add(settings)
        await db_session.commit()
        await db_session.refresh(user)

        return user

    async def create_test_superuser(
        self,
        db_session: AsyncSession,
        email: str | None = None,
    ) -> User:
        """Create a superuser for admin testing.

        Args:
            db_session: Database session
            email: User email (auto-generated if None)

        Returns:
            User: Created superuser
        """
        return await self.create_test_user(
            db_session,
            email=email or f"admin_{uuid4().hex[:8]}@example.com",
            full_name="Admin User",
            is_superuser=True,
            email_verified=True,
        )

    # =========================================================================
    # Deck and Card Creation Utilities
    # =========================================================================

    async def create_test_deck(
        self,
        db_session: AsyncSession,
        name: str = "Test Deck",
        description: str = "A test deck",
        level: DeckLevel = DeckLevel.A1,
        is_active: bool = True,
    ) -> Deck:
        """Create a test deck in the database.

        Args:
            db_session: Database session
            name: Deck name
            description: Deck description
            level: CEFR level (A1-C2)
            is_active: Whether deck is active

        Returns:
            Deck: Created deck
        """
        deck = Deck(
            name=name,
            description=description,
            level=level,
            is_active=is_active,
        )
        db_session.add(deck)
        await db_session.commit()
        await db_session.refresh(deck)

        return deck

    async def create_test_card(
        self,
        db_session: AsyncSession,
        deck: Deck,
        front_text: str = "Hello",
        back_text: str = "Yeia",
        difficulty: CardDifficulty = CardDifficulty.MEDIUM,
        order_index: int = 0,
    ) -> Card:
        """Create a test card in the database.

        Args:
            db_session: Database session
            deck: Parent deck
            front_text: Front of card (Greek)
            back_text: Back of card (English)
            difficulty: Card difficulty level
            order_index: Card order within deck

        Returns:
            Card: Created card
        """
        card = Card(
            deck_id=deck.id,
            front_text=front_text,
            back_text=back_text,
            difficulty=difficulty,
            order_index=order_index,
        )
        db_session.add(card)
        await db_session.commit()
        await db_session.refresh(card)

        return card

    async def create_deck_with_cards(
        self,
        db_session: AsyncSession,
        name: str = "Test Deck",
        level: DeckLevel = DeckLevel.A1,
        card_count: int = 5,
    ) -> tuple[Deck, list[Card]]:
        """Create a deck with multiple cards.

        Args:
            db_session: Database session
            name: Deck name
            level: CEFR level
            card_count: Number of cards to create

        Returns:
            tuple: (Deck, list of Cards)
        """
        deck = await self.create_test_deck(db_session, name=name, level=level)

        cards = []
        for i in range(card_count):
            card = await self.create_test_card(
                db_session,
                deck,
                front_text=f"Greek word {i}",
                back_text=f"English word {i}",
                order_index=i,
            )
            cards.append(card)

        return deck, cards

    # =========================================================================
    # Database Helper Methods
    # =========================================================================

    async def count_table_rows(
        self,
        db_session: AsyncSession,
        table_name: str,
    ) -> int:
        """Count rows in a database table.

        Args:
            db_session: Database session
            table_name: Name of the table

        Returns:
            int: Number of rows in the table
        """
        result = await db_session.execute(
            text(f"SELECT COUNT(*) FROM {table_name}")
        )
        return result.scalar() or 0

    async def table_exists(
        self,
        db_session: AsyncSession,
        table_name: str,
    ) -> bool:
        """Check if a table exists in the database.

        Args:
            db_session: Database session
            table_name: Name of the table

        Returns:
            bool: True if table exists
        """
        result = await db_session.execute(
            text(
                """
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_schema = 'public'
                    AND table_name = :table_name
                )
                """
            ),
            {"table_name": table_name},
        )
        return result.scalar() or False

    async def get_entity_by_id(
        self,
        db_session: AsyncSession,
        model_class: type,
        entity_id: UUID,
    ) -> Any:
        """Get an entity by its ID.

        Args:
            db_session: Database session
            model_class: SQLAlchemy model class
            entity_id: UUID of the entity

        Returns:
            Entity or None if not found
        """
        return await db_session.get(model_class, entity_id)

    # =========================================================================
    # Timestamp Utilities
    # =========================================================================

    @staticmethod
    def utc_now() -> datetime:
        """Get current UTC datetime.

        Returns:
            datetime: Current UTC time
        """
        return datetime.utcnow()

    @staticmethod
    def days_ago(days: int) -> datetime:
        """Get datetime for N days ago.

        Args:
            days: Number of days ago

        Returns:
            datetime: Timestamp for N days ago
        """
        return datetime.utcnow() - timedelta(days=days)

    @staticmethod
    def days_from_now(days: int) -> datetime:
        """Get datetime for N days from now.

        Args:
            days: Number of days from now

        Returns:
            datetime: Timestamp for N days from now
        """
        return datetime.utcnow() + timedelta(days=days)

    # =========================================================================
    # Assertion Helpers
    # =========================================================================

    def assert_user_created(self, user: User, email: str | None = None) -> None:
        """Assert that a user was created correctly.

        Args:
            user: User to validate
            email: Expected email (optional)
        """
        assert user is not None
        assert user.id is not None
        assert user.created_at is not None
        if email:
            assert user.email == email

    def assert_response_success(
        self,
        response: Response,
        expected_status: int = 200,
    ) -> None:
        """Assert that an HTTP response was successful.

        Args:
            response: HTTP response
            expected_status: Expected status code (default 200)
        """
        assert response.status_code == expected_status, (
            f"Expected {expected_status}, got {response.status_code}: "
            f"{response.text}"
        )

    def assert_response_error(
        self,
        response: Response,
        expected_status: int,
        error_detail: str | None = None,
    ) -> None:
        """Assert that an HTTP response was an error.

        Args:
            response: HTTP response
            expected_status: Expected error status code
            error_detail: Expected error message (optional)
        """
        assert response.status_code == expected_status
        if error_detail:
            data = response.json()
            assert "detail" in data
            assert error_detail in data["detail"]


class AuthenticatedTestCase(BaseTestCase):
    """Base class for tests requiring authentication.

    Extends BaseTestCase with authentication-specific utilities:
    - Token creation and validation
    - Auth header generation
    - Authenticated HTTP request helpers

    This class provides helper methods but relies on pytest fixtures
    for actual user/token creation (from tests/fixtures/auth.py).

    Example:
        class TestProtectedEndpoints(AuthenticatedTestCase):
            async def test_me_endpoint(self, client, authenticated_user):
                response = await self.make_authenticated_request(
                    client, "GET", "/api/v1/auth/me", authenticated_user.headers
                )
                self.assert_response_success(response)
    """

    # =========================================================================
    # Token Utilities
    # =========================================================================

    def create_access_token_for_user(self, user: User) -> str:
        """Create an access token for a user.

        Args:
            user: User to create token for

        Returns:
            str: JWT access token
        """
        token, _ = create_access_token(user.id)
        return token

    def create_auth_headers_for_user(self, user: User) -> dict[str, str]:
        """Create Authorization headers for a user.

        Args:
            user: User to create headers for

        Returns:
            dict: Headers with Bearer token
        """
        token = self.create_access_token_for_user(user)
        return {"Authorization": f"Bearer {token}"}

    def create_auth_headers(self, access_token: str) -> dict[str, str]:
        """Create Authorization headers from a token.

        Args:
            access_token: JWT access token

        Returns:
            dict: Headers with Bearer token
        """
        return {"Authorization": f"Bearer {access_token}"}

    # =========================================================================
    # Authenticated HTTP Request Helpers
    # =========================================================================

    async def make_authenticated_request(
        self,
        client: AsyncClient,
        method: str,
        url: str,
        headers: dict[str, str],
        json: dict | None = None,
        **kwargs,
    ) -> Response:
        """Make an authenticated HTTP request.

        Args:
            client: AsyncClient instance
            method: HTTP method (GET, POST, PUT, DELETE, etc.)
            url: Request URL
            headers: Auth headers (from fixtures)
            json: Request body as JSON (optional)
            **kwargs: Additional arguments to pass to client

        Returns:
            Response: HTTP response
        """
        method = method.upper()
        request_func = getattr(client, method.lower())

        if json is not None:
            return await request_func(url, headers=headers, json=json, **kwargs)
        else:
            return await request_func(url, headers=headers, **kwargs)

    async def get_authenticated(
        self,
        client: AsyncClient,
        url: str,
        headers: dict[str, str],
        **kwargs,
    ) -> Response:
        """Make an authenticated GET request.

        Args:
            client: AsyncClient instance
            url: Request URL
            headers: Auth headers

        Returns:
            Response: HTTP response
        """
        return await self.make_authenticated_request(
            client, "GET", url, headers, **kwargs
        )

    async def post_authenticated(
        self,
        client: AsyncClient,
        url: str,
        headers: dict[str, str],
        json: dict | None = None,
        **kwargs,
    ) -> Response:
        """Make an authenticated POST request.

        Args:
            client: AsyncClient instance
            url: Request URL
            headers: Auth headers
            json: Request body

        Returns:
            Response: HTTP response
        """
        return await self.make_authenticated_request(
            client, "POST", url, headers, json=json, **kwargs
        )

    async def put_authenticated(
        self,
        client: AsyncClient,
        url: str,
        headers: dict[str, str],
        json: dict | None = None,
        **kwargs,
    ) -> Response:
        """Make an authenticated PUT request.

        Args:
            client: AsyncClient instance
            url: Request URL
            headers: Auth headers
            json: Request body

        Returns:
            Response: HTTP response
        """
        return await self.make_authenticated_request(
            client, "PUT", url, headers, json=json, **kwargs
        )

    async def delete_authenticated(
        self,
        client: AsyncClient,
        url: str,
        headers: dict[str, str],
        **kwargs,
    ) -> Response:
        """Make an authenticated DELETE request.

        Args:
            client: AsyncClient instance
            url: Request URL
            headers: Auth headers

        Returns:
            Response: HTTP response
        """
        return await self.make_authenticated_request(
            client, "DELETE", url, headers, **kwargs
        )

    # =========================================================================
    # Authentication Assertion Helpers
    # =========================================================================

    def assert_unauthorized(self, response: Response) -> None:
        """Assert that a response is 401 Unauthorized.

        Args:
            response: HTTP response
        """
        self.assert_response_error(response, 401)

    def assert_forbidden(self, response: Response) -> None:
        """Assert that a response is 403 Forbidden.

        Args:
            response: HTTP response
        """
        self.assert_response_error(response, 403)

    def assert_token_valid(self, token: str) -> None:
        """Assert that a JWT token is valid.

        Args:
            token: JWT token to validate

        Raises:
            AssertionError: If token is invalid
        """
        from src.core.security import verify_token

        try:
            user_id = verify_token(token, token_type="access")
            assert user_id is not None
        except Exception as e:
            raise AssertionError(f"Token is invalid: {e}")

    def assert_token_expired(self, token: str) -> None:
        """Assert that a JWT token is expired.

        Args:
            token: JWT token to check

        Raises:
            AssertionError: If token is not expired
        """
        from src.core.exceptions import TokenExpiredException
        from src.core.security import verify_token

        try:
            verify_token(token, token_type="access")
            raise AssertionError("Token should be expired but is valid")
        except TokenExpiredException:
            pass  # Expected
        except Exception as e:
            raise AssertionError(f"Unexpected error: {e}")


# =============================================================================
# Pytest Markers for Test Classes
# =============================================================================

# These can be used as class decorators for automatic marking
unit = pytest.mark.unit
integration = pytest.mark.integration
slow = pytest.mark.slow
auth = pytest.mark.auth
api = pytest.mark.api
db = pytest.mark.db
```

### STEP 3: Update Fixtures __init__.py

**File to Modify**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/fixtures/__init__.py`

```python
"""Test fixtures package.

This package contains reusable test fixtures:
- database.py: Database session and engine fixtures (PostgreSQL only)
- auth.py: Authentication-related fixtures (users, tokens, headers)

Import fixtures in conftest.py to make them available globally.

Available Database Fixtures:
    db_engine: Async PostgreSQL engine (creates/drops tables per test)
    db_session: Async session with automatic rollback
    db_session_with_savepoint: Session using savepoint pattern
    session_db_engine: Shared engine across test session (faster)
    fast_db_session: Session using shared engine (faster, less isolated)

Available Auth Fixtures:
    test_user: Regular active user
    test_superuser: Admin user with superuser privileges
    test_verified_user: User with verified email
    test_inactive_user: Deactivated user account
    test_user_tokens: JWT tokens for test_user
    auth_headers: Authorization headers for test_user
    superuser_auth_headers: Authorization headers for superuser
    authenticated_user: Complete bundle (user, tokens, headers)
    expired_access_token: Expired token for error testing
    invalid_token: Invalid token for error testing

Note: All fixtures use PostgreSQL. SQLite is not supported due to
      PostgreSQL-specific features (native enums, uuid_generate_v4, etc.).

Usage:
    # In conftest.py
    from tests.fixtures.database import db_engine, db_session
    from tests.fixtures.auth import test_user, auth_headers

    # In test files
    async def test_something(db_session: AsyncSession, auth_headers: dict):
        ...
"""

from tests.fixtures.database import (
    clean_tables,
    create_test_engine,
    create_test_session_factory,
    db_engine,
    db_session,
    db_session_with_savepoint,
    db_url,
    fast_db_session,
    session_db_engine,
    verify_isolation,
)

from tests.fixtures.auth import (
    # User fixtures
    test_user,
    test_superuser,
    test_verified_user,
    test_inactive_user,
    two_users,
    # Token fixtures
    test_user_tokens,
    superuser_tokens,
    access_token,
    refresh_token_value,
    # Header fixtures
    auth_headers,
    superuser_auth_headers,
    expired_auth_headers,
    # Bundle fixtures
    authenticated_user,
    authenticated_superuser,
    # Error testing fixtures
    expired_access_token,
    invalid_token,
    # Utility functions
    create_test_user_data,
    create_user_with_settings,
    create_tokens_for_user,
    create_auth_headers,
    # Types
    AuthTokens,
    AuthenticatedUser,
)

__all__ = [
    # Database fixtures
    "db_engine",
    "db_session",
    "db_session_with_savepoint",
    "session_db_engine",
    "fast_db_session",
    "db_url",
    "clean_tables",
    "verify_isolation",
    "create_test_engine",
    "create_test_session_factory",
    # User fixtures
    "test_user",
    "test_superuser",
    "test_verified_user",
    "test_inactive_user",
    "two_users",
    # Token fixtures
    "test_user_tokens",
    "superuser_tokens",
    "access_token",
    "refresh_token_value",
    # Header fixtures
    "auth_headers",
    "superuser_auth_headers",
    "expired_auth_headers",
    # Bundle fixtures
    "authenticated_user",
    "authenticated_superuser",
    # Error testing fixtures
    "expired_access_token",
    "invalid_token",
    # Utility functions
    "create_test_user_data",
    "create_user_with_settings",
    "create_tokens_for_user",
    "create_auth_headers",
    # Types
    "AuthTokens",
    "AuthenticatedUser",
]
```

### STEP 4: Update Global conftest.py

**File to Modify**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/conftest.py`

Add the following imports at the top of the file after existing imports:

```python
# Import auth fixtures from fixtures package
from tests.fixtures.auth import (
    # User fixtures
    test_user,
    test_superuser,
    test_verified_user,
    test_inactive_user,
    two_users,
    # Token fixtures
    test_user_tokens,
    superuser_tokens,
    access_token,
    refresh_token_value,
    # Header fixtures
    auth_headers,
    superuser_auth_headers,
    expired_auth_headers,
    # Bundle fixtures
    authenticated_user,
    authenticated_superuser,
    # Error testing fixtures
    expired_access_token,
    invalid_token,
)

# Update __all__ to include auth fixtures
__all__ = [
    # Database fixtures
    "db_engine",
    "db_session",
    "db_session_with_savepoint",
    "session_db_engine",
    "fast_db_session",
    "db_url",
    "clean_tables",
    "verify_isolation",
    # Auth fixtures
    "test_user",
    "test_superuser",
    "test_verified_user",
    "test_inactive_user",
    "two_users",
    "test_user_tokens",
    "superuser_tokens",
    "access_token",
    "refresh_token_value",
    "auth_headers",
    "superuser_auth_headers",
    "expired_auth_headers",
    "authenticated_user",
    "authenticated_superuser",
    "expired_access_token",
    "invalid_token",
]
```

### STEP 5: Create Base Class Tests

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/unit/test_base_classes.py`

```python
"""Tests for base test classes and auth fixtures.

This module verifies that:
- BaseTestCase utility methods work correctly
- AuthenticatedTestCase auth methods work correctly
- Auth fixtures create valid users and tokens
- Token fixtures are properly formatted
- Error fixtures (expired, invalid) behave correctly
"""

import uuid

import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.security import verify_token
from src.db.models import User, Deck, Card, DeckLevel
from tests.base import BaseTestCase, AuthenticatedTestCase
from tests.fixtures.auth import AuthTokens, AuthenticatedUser


# =============================================================================
# BaseTestCase Tests
# =============================================================================


class TestBaseTestCaseUserCreation(BaseTestCase):
    """Tests for BaseTestCase user creation methods."""

    async def test_create_test_user_basic(self, db_session: AsyncSession):
        """Test creating a basic test user."""
        user = await self.create_test_user(db_session)

        assert user is not None
        assert user.id is not None
        assert user.email is not None
        assert "@example.com" in user.email
        assert user.is_active is True
        assert user.is_superuser is False
        assert user.settings is not None

    async def test_create_test_user_custom_email(self, db_session: AsyncSession):
        """Test creating a user with custom email."""
        email = "custom@test.com"
        user = await self.create_test_user(db_session, email=email)

        assert user.email == email

    async def test_create_test_user_superuser(self, db_session: AsyncSession):
        """Test creating a superuser."""
        user = await self.create_test_user(db_session, is_superuser=True)

        assert user.is_superuser is True

    async def test_create_test_user_inactive(self, db_session: AsyncSession):
        """Test creating an inactive user."""
        user = await self.create_test_user(db_session, is_active=False)

        assert user.is_active is False

    async def test_create_test_user_verified(self, db_session: AsyncSession):
        """Test creating a verified user."""
        user = await self.create_test_user(db_session, email_verified=True)

        assert user.email_verified_at is not None

    async def test_create_test_superuser_helper(self, db_session: AsyncSession):
        """Test the create_test_superuser helper method."""
        user = await self.create_test_superuser(db_session)

        assert user.is_superuser is True
        assert user.is_active is True
        assert user.email_verified_at is not None


class TestBaseTestCaseDeckCardCreation(BaseTestCase):
    """Tests for BaseTestCase deck and card creation methods."""

    async def test_create_test_deck(self, db_session: AsyncSession):
        """Test creating a test deck."""
        deck = await self.create_test_deck(db_session)

        assert deck is not None
        assert deck.id is not None
        assert deck.name == "Test Deck"
        assert deck.level == DeckLevel.A1
        assert deck.is_active is True

    async def test_create_test_deck_custom(self, db_session: AsyncSession):
        """Test creating a deck with custom attributes."""
        deck = await self.create_test_deck(
            db_session,
            name="Greek B2 Vocabulary",
            level=DeckLevel.B2,
        )

        assert deck.name == "Greek B2 Vocabulary"
        assert deck.level == DeckLevel.B2

    async def test_create_test_card(self, db_session: AsyncSession):
        """Test creating a test card."""
        deck = await self.create_test_deck(db_session)
        card = await self.create_test_card(db_session, deck)

        assert card is not None
        assert card.id is not None
        assert card.deck_id == deck.id
        assert card.front_text == "Hello"
        assert card.back_text == "Yeia"

    async def test_create_deck_with_cards(self, db_session: AsyncSession):
        """Test creating a deck with multiple cards."""
        deck, cards = await self.create_deck_with_cards(
            db_session,
            name="Test Deck with Cards",
            card_count=5,
        )

        assert deck is not None
        assert len(cards) == 5
        for i, card in enumerate(cards):
            assert card.deck_id == deck.id
            assert card.order_index == i


class TestBaseTestCaseDatabaseHelpers(BaseTestCase):
    """Tests for BaseTestCase database helper methods."""

    async def test_count_table_rows(self, db_session: AsyncSession):
        """Test counting table rows."""
        # Create some users
        for i in range(3):
            await self.create_test_user(db_session)

        count = await self.count_table_rows(db_session, "users")
        assert count >= 3

    async def test_table_exists(self, db_session: AsyncSession):
        """Test checking if table exists."""
        assert await self.table_exists(db_session, "users") is True
        assert await self.table_exists(db_session, "nonexistent_table") is False

    async def test_get_entity_by_id(self, db_session: AsyncSession):
        """Test getting entity by ID."""
        user = await self.create_test_user(db_session)

        found_user = await self.get_entity_by_id(db_session, User, user.id)
        assert found_user is not None
        assert found_user.id == user.id


class TestBaseTestCaseTimestampUtilities(BaseTestCase):
    """Tests for BaseTestCase timestamp utilities."""

    def test_utc_now(self):
        """Test getting current UTC time."""
        now = self.utc_now()
        assert now is not None

    def test_days_ago(self):
        """Test getting past timestamp."""
        past = self.days_ago(7)
        now = self.utc_now()
        assert past < now

    def test_days_from_now(self):
        """Test getting future timestamp."""
        future = self.days_from_now(7)
        now = self.utc_now()
        assert future > now


class TestBaseTestCaseAssertions(BaseTestCase):
    """Tests for BaseTestCase assertion helpers."""

    async def test_assert_user_created(self, db_session: AsyncSession):
        """Test the assert_user_created helper."""
        user = await self.create_test_user(db_session, email="test@test.com")
        # Should not raise
        self.assert_user_created(user, email="test@test.com")


# =============================================================================
# AuthenticatedTestCase Tests
# =============================================================================


class TestAuthenticatedTestCaseTokenUtilities(AuthenticatedTestCase):
    """Tests for AuthenticatedTestCase token utilities."""

    async def test_create_access_token_for_user(self, db_session: AsyncSession):
        """Test creating access token for user."""
        user = await self.create_test_user(db_session)
        token = self.create_access_token_for_user(user)

        assert token is not None
        assert isinstance(token, str)
        assert len(token) > 50  # JWT tokens are typically long

    async def test_create_auth_headers_for_user(self, db_session: AsyncSession):
        """Test creating auth headers for user."""
        user = await self.create_test_user(db_session)
        headers = self.create_auth_headers_for_user(user)

        assert "Authorization" in headers
        assert headers["Authorization"].startswith("Bearer ")

    def test_create_auth_headers_from_token(self):
        """Test creating auth headers from token string."""
        token = "test-token-value"
        headers = self.create_auth_headers(token)

        assert headers["Authorization"] == "Bearer test-token-value"


class TestAuthenticatedTestCaseAssertions(AuthenticatedTestCase):
    """Tests for AuthenticatedTestCase assertion helpers."""

    async def test_assert_token_valid(self, db_session: AsyncSession):
        """Test validating a valid token."""
        user = await self.create_test_user(db_session)
        token = self.create_access_token_for_user(user)

        # Should not raise
        self.assert_token_valid(token)

    async def test_assert_token_expired(self, expired_access_token: str):
        """Test detecting an expired token."""
        # Should not raise (token is expected to be expired)
        self.assert_token_expired(expired_access_token)


# =============================================================================
# Auth Fixtures Tests
# =============================================================================


class TestAuthFixturesUserCreation:
    """Tests for auth fixture user creation."""

    async def test_test_user_fixture(self, test_user: User):
        """Test that test_user fixture creates valid user."""
        assert test_user is not None
        assert test_user.id is not None
        assert test_user.email is not None
        assert test_user.is_active is True
        assert test_user.is_superuser is False
        assert test_user.settings is not None

    async def test_test_superuser_fixture(self, test_superuser: User):
        """Test that test_superuser fixture creates admin user."""
        assert test_superuser is not None
        assert test_superuser.is_superuser is True
        assert test_superuser.is_active is True
        assert test_superuser.email_verified_at is not None

    async def test_test_verified_user_fixture(self, test_verified_user: User):
        """Test that test_verified_user has verified email."""
        assert test_verified_user is not None
        assert test_verified_user.email_verified_at is not None

    async def test_test_inactive_user_fixture(self, test_inactive_user: User):
        """Test that test_inactive_user is inactive."""
        assert test_inactive_user is not None
        assert test_inactive_user.is_active is False

    async def test_two_users_fixture(self, two_users: tuple[User, User]):
        """Test that two_users fixture creates different users."""
        user1, user2 = two_users
        assert user1.id != user2.id
        assert user1.email != user2.email


class TestAuthFixturesTokenCreation:
    """Tests for auth fixture token creation."""

    async def test_test_user_tokens_fixture(self, test_user_tokens: AuthTokens):
        """Test that test_user_tokens creates valid tokens."""
        assert test_user_tokens is not None
        assert test_user_tokens.access_token is not None
        assert test_user_tokens.refresh_token is not None
        assert test_user_tokens.access_expires is not None
        assert test_user_tokens.refresh_expires is not None

    async def test_access_token_is_valid(
        self,
        test_user: User,
        test_user_tokens: AuthTokens,
    ):
        """Test that access token can be verified."""
        user_id = verify_token(test_user_tokens.access_token, token_type="access")
        assert user_id == test_user.id

    async def test_superuser_tokens_fixture(self, superuser_tokens: AuthTokens):
        """Test that superuser_tokens creates valid tokens."""
        assert superuser_tokens is not None
        assert superuser_tokens.access_token is not None


class TestAuthFixturesHeaders:
    """Tests for auth fixture header creation."""

    async def test_auth_headers_fixture(self, auth_headers: dict[str, str]):
        """Test that auth_headers has correct format."""
        assert "Authorization" in auth_headers
        assert auth_headers["Authorization"].startswith("Bearer ")
        # Token should be present after "Bearer "
        token = auth_headers["Authorization"].replace("Bearer ", "")
        assert len(token) > 50

    async def test_superuser_auth_headers_fixture(
        self,
        superuser_auth_headers: dict[str, str],
    ):
        """Test that superuser_auth_headers has correct format."""
        assert "Authorization" in superuser_auth_headers
        assert superuser_auth_headers["Authorization"].startswith("Bearer ")


class TestAuthFixturesBundles:
    """Tests for auth fixture bundles."""

    async def test_authenticated_user_bundle(
        self,
        authenticated_user: AuthenticatedUser,
    ):
        """Test that authenticated_user bundle contains all components."""
        assert authenticated_user.user is not None
        assert authenticated_user.tokens is not None
        assert authenticated_user.headers is not None
        assert authenticated_user.user.id is not None
        assert authenticated_user.tokens.access_token is not None

    async def test_authenticated_superuser_bundle(
        self,
        authenticated_superuser: AuthenticatedUser,
    ):
        """Test that authenticated_superuser bundle contains admin user."""
        assert authenticated_superuser.user.is_superuser is True


class TestAuthFixturesErrorCases:
    """Tests for auth fixtures that test error cases."""

    def test_expired_access_token_fixture(self, expired_access_token: str):
        """Test that expired_access_token is actually expired."""
        from src.core.exceptions import TokenExpiredException

        with pytest.raises(TokenExpiredException):
            verify_token(expired_access_token, token_type="access")

    def test_invalid_token_fixture(self, invalid_token: str):
        """Test that invalid_token is properly invalid."""
        from src.core.exceptions import TokenInvalidException

        with pytest.raises(TokenInvalidException):
            verify_token(invalid_token, token_type="access")

    def test_expired_auth_headers_fixture(self, expired_auth_headers: dict[str, str]):
        """Test that expired_auth_headers has correct format."""
        assert "Authorization" in expired_auth_headers
        assert expired_auth_headers["Authorization"].startswith("Bearer ")


# =============================================================================
# Integration Tests with HTTP Client
# =============================================================================


@pytest.mark.integration
class TestAuthenticatedHTTPRequests(AuthenticatedTestCase):
    """Test making authenticated HTTP requests."""

    async def test_authenticated_get_request(
        self,
        client: AsyncClient,
        auth_headers: dict[str, str],
    ):
        """Test making authenticated GET request to /me endpoint."""
        response = await self.get_authenticated(
            client, "/api/v1/auth/me", auth_headers
        )

        # Should succeed with valid auth
        self.assert_response_success(response, 200)

    async def test_unauthenticated_request_fails(self, client: AsyncClient):
        """Test that unauthenticated request to protected endpoint fails."""
        response = await client.get("/api/v1/auth/me")

        self.assert_unauthorized(response)

    async def test_expired_token_fails(
        self,
        client: AsyncClient,
        expired_auth_headers: dict[str, str],
    ):
        """Test that expired token returns 401."""
        response = await self.get_authenticated(
            client, "/api/v1/auth/me", expired_auth_headers
        )

        self.assert_unauthorized(response)

    async def test_invalid_token_fails(self, client: AsyncClient):
        """Test that invalid token returns 401."""
        headers = {"Authorization": "Bearer invalid-token"}
        response = await client.get("/api/v1/auth/me", headers=headers)

        self.assert_unauthorized(response)
```

---

## Test Patterns

### Pattern 1: Using BaseTestCase

```python
from tests.base import BaseTestCase

class TestMyFeature(BaseTestCase):
    """Tests for my feature."""

    async def test_create_user_and_deck(self, db_session):
        """Test creating user and deck together."""
        user = await self.create_test_user(db_session)
        deck = await self.create_test_deck(db_session)

        self.assert_user_created(user)
        assert deck.id is not None
```

### Pattern 2: Using AuthenticatedTestCase with Fixtures

```python
from tests.base import AuthenticatedTestCase

class TestProtectedEndpoints(AuthenticatedTestCase):
    """Tests for protected API endpoints."""

    async def test_get_user_profile(self, client, auth_headers):
        """Test getting authenticated user profile."""
        response = await self.get_authenticated(
            client, "/api/v1/auth/me", auth_headers
        )
        self.assert_response_success(response)

    async def test_admin_only_endpoint(self, client, superuser_auth_headers):
        """Test admin-only endpoint."""
        response = await self.get_authenticated(
            client, "/api/v1/admin/stats", superuser_auth_headers
        )
        self.assert_response_success(response)

    async def test_unauthorized_access(self, client):
        """Test that unauthorized access fails."""
        response = await client.get("/api/v1/auth/me")
        self.assert_unauthorized(response)
```

### Pattern 3: Using authenticated_user Bundle

```python
async def test_with_user_bundle(client, authenticated_user):
    """Test using the complete authenticated user bundle."""
    user = authenticated_user.user
    headers = authenticated_user.headers

    response = await client.get("/api/v1/auth/me", headers=headers)
    assert response.status_code == 200

    data = response.json()
    assert data["email"] == user.email
```

### Pattern 4: Testing User Isolation

```python
async def test_user_cannot_access_other_data(client, two_users, db_session):
    """Test that users cannot access each other's data."""
    user1, user2 = two_users

    # Create data for user1
    # ... create deck owned by user1 ...

    # Get tokens for user2
    from tests.fixtures.auth import create_tokens_for_user, create_auth_headers
    user2_tokens = create_tokens_for_user(user2)
    user2_headers = create_auth_headers(user2_tokens.access_token)

    # User2 should not see user1's data
    response = await client.get("/api/v1/decks", headers=user2_headers)
    data = response.json()
    # Assert user1's deck is not in the list
```

---

## Implementation Checklist

### Phase 1: Create Auth Fixtures
- [ ] Create `tests/fixtures/auth.py` with user fixtures
- [ ] Add token creation fixtures
- [ ] Add auth header fixtures
- [ ] Add bundle fixtures (authenticated_user, authenticated_superuser)
- [ ] Add error fixtures (expired_access_token, invalid_token)

### Phase 2: Create Base Classes
- [ ] Create `tests/base.py`
- [ ] Implement `BaseTestCase` with user creation utilities
- [ ] Implement deck/card creation utilities
- [ ] Implement database helper methods
- [ ] Implement assertion helpers
- [ ] Implement `AuthenticatedTestCase` with token utilities
- [ ] Implement authenticated request helpers

### Phase 3: Update Existing Files
- [ ] Update `tests/fixtures/__init__.py` to export auth fixtures
- [ ] Update `tests/conftest.py` to import auth fixtures

### Phase 4: Create Tests
- [ ] Create `tests/unit/test_base_classes.py`
- [ ] Test BaseTestCase user creation
- [ ] Test BaseTestCase deck/card creation
- [ ] Test BaseTestCase database helpers
- [ ] Test AuthenticatedTestCase token methods
- [ ] Test auth fixtures create valid users
- [ ] Test auth fixtures create valid tokens
- [ ] Test error fixtures (expired, invalid)
- [ ] Test authenticated HTTP requests

### Phase 5: Verification
- [ ] Run all tests: `poetry run pytest tests/ -v`
- [ ] Run only base class tests: `poetry run pytest tests/unit/test_base_classes.py -v`
- [ ] Verify existing tests still pass

---

## Acceptance Criteria

### Functional Requirements

1. **BaseTestCase**
   - [ ] `create_test_user()` creates valid user with settings
   - [ ] `create_test_superuser()` creates admin user
   - [ ] `create_test_deck()` creates valid deck
   - [ ] `create_test_card()` creates valid card
   - [ ] `create_deck_with_cards()` creates deck with N cards
   - [ ] `count_table_rows()` returns correct count
   - [ ] `table_exists()` correctly detects tables
   - [ ] Timestamp utilities work correctly

2. **AuthenticatedTestCase**
   - [ ] `create_access_token_for_user()` creates valid JWT
   - [ ] `create_auth_headers_for_user()` creates proper headers
   - [ ] `make_authenticated_request()` works with all HTTP methods
   - [ ] `assert_unauthorized()` detects 401 responses
   - [ ] `assert_forbidden()` detects 403 responses
   - [ ] `assert_token_valid()` validates good tokens
   - [ ] `assert_token_expired()` detects expired tokens

3. **Auth Fixtures**
   - [ ] `test_user` creates active regular user
   - [ ] `test_superuser` creates admin user
   - [ ] `test_verified_user` has verified email
   - [ ] `test_inactive_user` is inactive
   - [ ] `test_user_tokens` creates valid access/refresh tokens
   - [ ] `auth_headers` has proper Bearer format
   - [ ] `authenticated_user` bundles user, tokens, headers
   - [ ] `expired_access_token` is actually expired
   - [ ] `invalid_token` is properly invalid

### Test Requirements

- [ ] All existing tests pass
- [ ] 15+ new tests for base classes pass
- [ ] No deprecation warnings
- [ ] Test isolation works (no data leakage)

### Code Quality

- [ ] All code has type hints
- [ ] All functions have docstrings
- [ ] Follows existing code style
- [ ] No circular imports

---

## Troubleshooting Guide

### Issue 1: "ImportError: cannot import name 'test_user'"

**Cause**: Fixture not properly exported

**Solution**:
1. Check `tests/fixtures/auth.py` defines the fixture
2. Check `tests/fixtures/__init__.py` exports it
3. Check `tests/conftest.py` imports it

### Issue 2: "Fixture 'test_user' not found"

**Cause**: Fixture not imported in conftest.py

**Solution**:
```python
# In tests/conftest.py
from tests.fixtures.auth import test_user
```

### Issue 3: "Token is invalid" errors

**Cause**: Token created with different secret or algorithm

**Solution**: Ensure `src.config.settings` is properly loaded in tests

### Issue 4: Circular import between base.py and fixtures

**Cause**: base.py imports from fixtures, fixtures import from base

**Solution**: Keep imports minimal in base.py, use local imports for fixtures

### Issue 5: "User has no attribute 'settings'"

**Cause**: User created without settings

**Solution**: Use `create_user_with_settings()` helper or ensure settings are created

### Issue 6: Tests polluting each other

**Cause**: Fixture scope too wide or missing rollback

**Solution**: Ensure fixtures use `scope="function"` and db_session rolls back

---

## Quick Reference

### Test Commands

```bash
# Run all tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/ -v

# Run only base class tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_base_classes.py -v

# Run auth-related tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest -m auth -v

# Run integration tests only
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest -m integration -v
```

### File Locations

| File | Purpose |
|------|---------|
| `tests/base.py` | BaseTestCase and AuthenticatedTestCase |
| `tests/fixtures/auth.py` | Authentication fixtures |
| `tests/fixtures/__init__.py` | Fixture exports |
| `tests/conftest.py` | Global fixture imports |
| `tests/unit/test_base_classes.py` | Tests for base classes |

### Key Fixtures

| Fixture | Purpose | Returns |
|---------|---------|---------|
| `test_user` | Regular active user | `User` |
| `test_superuser` | Admin user | `User` |
| `auth_headers` | Ready-to-use headers | `dict[str, str]` |
| `authenticated_user` | Complete user bundle | `AuthenticatedUser` |
| `expired_access_token` | For error testing | `str` |

---

**Document Version**: 1.0
**Created**: 2025-11-30
**Author**: Architecture Team
**Status**: Ready for Implementation
**Priority**: High
**Estimated Duration**: 60-90 minutes
