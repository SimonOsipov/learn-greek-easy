# Task 03.06: Google OAuth Authentication - Technical Architecture Document

**Document Version**: 1.0
**Created**: 2025-12-04
**Status**: Ready for Implementation
**Estimated Duration**: 3-4 hours
**Priority**: Medium
**Dependencies**: Tasks 03.01-03.05, 03.07, 03.09 (Core Authentication System) - COMPLETED

---

## Table of Contents
1. [Overview & Goals](#overview--goals)
2. [Dependencies](#dependencies)
3. [Configuration](#configuration)
4. [Architecture Design](#architecture-design)
5. [Implementation Details](#implementation-details)
6. [Account Linking Strategy](#account-linking-strategy)
7. [Error Handling](#error-handling)
8. [Security Considerations](#security-considerations)
9. [Testing Strategy](#testing-strategy)
10. [Implementation Checklist](#implementation-checklist)

---

## Overview & Goals

### Objectives

Implement Google OAuth authentication that:
- Allows users to sign in with their Google account
- Integrates seamlessly with the existing JWT token system
- Reuses existing Redis session storage and token rotation
- Supports account linking for users with existing email accounts
- Auto-verifies email for Google OAuth users
- Works in both development and production environments

### Success Criteria

- [ ] Users can authenticate via Google OAuth
- [ ] New users are automatically created with Google account info
- [ ] Existing email users can link their Google account
- [ ] JWT tokens (access + refresh) are issued using existing system
- [ ] Sessions are stored in Redis using existing `SessionRepository`
- [ ] Email is automatically verified for Google OAuth users
- [ ] Feature flag `feature_google_oauth` controls endpoint visibility
- [ ] Unit tests achieve 90%+ coverage
- [ ] Integration tests verify complete OAuth flow

### Out of Scope

- Google OAuth for account unlinking (future feature)
- Multiple OAuth providers (Apple, Facebook, etc.)
- OAuth token refresh with Google (we issue our own tokens)
- Social features (friends, sharing via Google)

---

## Dependencies

### New Package Required

```toml
# In pyproject.toml, add:
[tool.poetry.dependencies]
google-auth = "^2.25.0"  # Google's official auth library for ID token verification
```

**Why `google-auth` instead of alternatives?**
- Official Google library with maintained security updates
- Supports ID token verification with caching of Google's public keys
- No heavy dependencies (unlike `google-api-python-client`)
- Production-tested and widely used

### Installation

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry add google-auth
```

### Existing Dependencies (Already Installed)

- `python-jose[cryptography]` - JWT token generation (existing)
- `pydantic` - Request/response validation (existing)
- `redis` - Session storage (existing)
- `sqlalchemy` - Database ORM (existing)

---

## Configuration

### New Environment Variables

Add to `src/config.py` Settings class (already partially defined):

```python
# Google OAuth (existing fields in config.py)
google_client_id: Optional[str] = Field(
    default=None,
    description="Google OAuth client ID"
)
google_client_secret: Optional[str] = Field(
    default=None,
    description="Google OAuth client secret (not used for ID token flow, but reserved)"
)
google_redirect_uri: Optional[str] = Field(
    default=None,
    description="Google OAuth redirect URI (for authorization code flow, if needed)"
)

# Feature flag (existing in config.py)
feature_google_oauth: bool = Field(
    default=False,
    description="Enable Google OAuth"
)
```

### Development Environment Placeholders

Create `.env.example` additions:

```bash
# =============================================================================
# Google OAuth Configuration
# =============================================================================
# To set up Google OAuth:
# 1. Go to https://console.cloud.google.com/
# 2. Create a new project or select existing
# 3. Enable "Google+ API" or "Google Identity" API
# 4. Go to Credentials > Create Credentials > OAuth 2.0 Client IDs
# 5. Application type: Web application
# 6. Add authorized JavaScript origins:
#    - http://localhost:5173 (frontend dev)
#    - https://your-production-domain.com
# 7. Add authorized redirect URIs (if using authorization code flow):
#    - http://localhost:5173/auth/google/callback
#    - https://your-production-domain.com/auth/google/callback
# 8. Copy Client ID below

GOOGLE_CLIENT_ID=your-google-client-id.apps.googleusercontent.com
# GOOGLE_CLIENT_SECRET=your-google-client-secret  # Optional for ID token flow
# GOOGLE_REDIRECT_URI=http://localhost:5173/auth/google/callback

# Enable the feature
FEATURE_GOOGLE_OAUTH=true
```

### Configuration Validation

Add helper property to `Settings` class:

```python
@property
def google_oauth_configured(self) -> bool:
    """Check if Google OAuth is properly configured."""
    return (
        self.feature_google_oauth
        and self.google_client_id is not None
        and len(self.google_client_id) > 0
    )
```

---

## Architecture Design

### OAuth Flow Diagram (ID Token Flow)

The implementation uses Google's **ID Token flow** (also known as "Sign In with Google"), which is simpler and more secure than the authorization code flow for authentication-only use cases.

```
+------------------+                                    +------------------+
|                  |                                    |                  |
|  React Frontend  |                                    |  FastAPI Backend |
|                  |                                    |                  |
+--------+---------+                                    +--------+---------+
         |                                                       |
         |  1. User clicks "Sign in with Google"                 |
         |                                                       |
         v                                                       |
+--------+---------+                                             |
|                  |                                             |
|  Google Sign-In  |                                             |
|  (JavaScript SDK)|                                             |
|                  |                                             |
+--------+---------+                                             |
         |                                                       |
         |  2. User authenticates with Google                    |
         |     (Google handles credential UI)                    |
         |                                                       |
         v                                                       |
+--------+---------+                                             |
|                  |                                             |
|  Google Returns  |                                             |
|  ID Token (JWT)  |                                             |
|                  |                                             |
+--------+---------+                                             |
         |                                                       |
         |  3. Frontend sends ID token to backend                |
         |     POST /api/v1/auth/google                          |
         |     { "id_token": "eyJhbG..." }                       |
         |                                                       |
         +------------------------------------------------------>|
                                                                 |
                                                                 v
                                                   +-------------+-------------+
                                                   |                           |
                                                   |  4. Verify ID token       |
                                                   |     with Google's         |
                                                   |     public keys           |
                                                   |                           |
                                                   +-------------+-------------+
                                                                 |
                                                                 v
                                                   +-------------+-------------+
                                                   |                           |
                                                   |  5. Extract user info     |
                                                   |     - email               |
                                                   |     - google_id (sub)     |
                                                   |     - name                |
                                                   |     - email_verified      |
                                                   |                           |
                                                   +-------------+-------------+
                                                                 |
                                                                 v
                                                   +-------------+-------------+
                                                   |                           |
                                                   |  6. Find or create user   |
                                                   |     (Account linking      |
                                                   |      logic applies)       |
                                                   |                           |
                                                   +-------------+-------------+
                                                                 |
                                                                 v
                                                   +-------------+-------------+
                                                   |                           |
                                                   |  7. Generate JWT tokens   |
                                                   |     (reuse existing       |
                                                   |      create_access_token  |
                                                   |      create_refresh_token)|
                                                   |                           |
                                                   +-------------+-------------+
                                                                 |
                                                                 v
                                                   +-------------+-------------+
                                                   |                           |
                                                   |  8. Store session in      |
                                                   |     Redis (reuse          |
                                                   |     SessionRepository)    |
                                                   |                           |
                                                   +-------------+-------------+
                                                                 |
         +<------------------------------------------------------+
         |
         |  9. Return TokenResponse
         |     { access_token, refresh_token, expires_in }
         |
         v
+--------+---------+
|                  |
|  Frontend stores |
|  tokens, user is |
|  authenticated   |
|                  |
+------------------+
```

### Component Interactions

```
src/
├── api/v1/auth.py              # New endpoint: POST /google
│   └── google_login()          # Endpoint handler
│       ├── Validates request (GoogleAuthRequest schema)
│       ├── Calls AuthService.authenticate_google()
│       └── Returns TokenResponse (reuses existing schema)
│
├── services/auth_service.py    # New method: authenticate_google()
│   └── authenticate_google()
│       ├── Calls verify_google_id_token()
│       ├── Implements account linking logic
│       ├── Creates or updates user
│       ├── Reuses create_access_token(), create_refresh_token()
│       └── Reuses SessionRepository.create_session()
│
├── core/
│   ├── security.py             # New function: verify_google_id_token()
│   │   └── verify_google_id_token()
│   │       ├── Uses google.oauth2.id_token.verify_oauth2_token()
│   │       └── Returns GoogleUserInfo dataclass
│   │
│   └── exceptions.py           # New exceptions
│       ├── GoogleOAuthDisabledException
│       ├── GoogleTokenInvalidException
│       └── AccountLinkingConflictException
│
├── schemas/user.py             # New schemas
│   ├── GoogleAuthRequest       # Input: { id_token: str }
│   └── GoogleUserInfo          # Internal: parsed Google user data
│
└── config.py                   # Already has google_* fields
```

### Data Flow Summary

1. **Frontend** obtains Google ID token via Google Sign-In JavaScript SDK
2. **Frontend** sends ID token to `POST /api/v1/auth/google`
3. **Backend** verifies token with Google's public keys (cached)
4. **Backend** extracts user info (email, google_id, name)
5. **Backend** finds existing user by `google_id` OR by `email`
6. **Backend** creates new user OR links Google account to existing user
7. **Backend** generates JWT tokens using existing utilities
8. **Backend** stores session in Redis using existing `SessionRepository`
9. **Backend** returns `TokenResponse` to frontend

---

## Implementation Details

### 1. Config Changes

**File**: `src/config.py`

Add helper property (minimal change, most config already exists):

```python
@property
def google_oauth_configured(self) -> bool:
    """Check if Google OAuth is properly configured."""
    return (
        self.feature_google_oauth
        and self.google_client_id is not None
        and len(self.google_client_id) > 0
    )
```

### 2. New Schemas

**File**: `src/schemas/user.py`

Add new schemas for Google OAuth:

```python
# ============================================================================
# Google OAuth Schemas
# ============================================================================

class GoogleAuthRequest(BaseModel):
    """Schema for Google OAuth authentication request.

    The frontend obtains this token from Google Sign-In SDK
    and sends it to the backend for verification.
    """
    id_token: str = Field(
        ...,
        min_length=100,  # Google ID tokens are ~1000+ chars
        description="Google ID token (JWT) from Google Sign-In"
    )


class GoogleUserInfo(BaseModel):
    """Internal schema for parsed Google user information.

    Extracted from verified Google ID token payload.
    Not used in API responses.
    """
    google_id: str = Field(..., description="Google's unique user identifier (sub claim)")
    email: EmailStr = Field(..., description="User's email from Google")
    email_verified: bool = Field(..., description="Whether Google has verified the email")
    full_name: Optional[str] = Field(None, description="User's full name from Google")
    picture_url: Optional[str] = Field(None, description="Profile picture URL")

    model_config = ConfigDict(frozen=True)  # Immutable
```

### 3. Security Utilities (Google Token Verification)

**File**: `src/core/security.py`

Add new function for Google ID token verification:

```python
# Add imports at top
from google.oauth2 import id_token as google_id_token
from google.auth.transport import requests as google_requests

from src.schemas.user import GoogleUserInfo


def verify_google_id_token(token: str, client_id: str) -> GoogleUserInfo:
    """Verify Google ID token and extract user information.

    Uses Google's official library to verify the token signature
    against Google's public keys (automatically cached).

    Args:
        token: Google ID token (JWT) from frontend
        client_id: Google OAuth client ID for audience verification

    Returns:
        GoogleUserInfo with extracted user data

    Raises:
        GoogleTokenInvalidException: If token is invalid, expired, or
            doesn't match the expected audience (client_id)

    Security Notes:
        - Token signature is verified against Google's public keys
        - Token expiration is automatically checked
        - Audience (aud) claim must match our client_id
        - Issuer (iss) must be accounts.google.com or https://accounts.google.com
    """
    try:
        # Verify the token with Google's public keys
        # This handles signature verification, expiration, and issuer validation
        idinfo = google_id_token.verify_oauth2_token(
            token,
            google_requests.Request(),
            client_id
        )

        # Additional validation: check issuer
        issuer = idinfo.get("iss", "")
        if issuer not in ["accounts.google.com", "https://accounts.google.com"]:
            raise GoogleTokenInvalidException(
                detail=f"Invalid token issuer: {issuer}"
            )

        # Extract user information
        return GoogleUserInfo(
            google_id=idinfo["sub"],  # Unique Google user ID
            email=idinfo["email"],
            email_verified=idinfo.get("email_verified", False),
            full_name=idinfo.get("name"),
            picture_url=idinfo.get("picture"),
        )

    except ValueError as e:
        # ValueError is raised for invalid tokens
        raise GoogleTokenInvalidException(
            detail=f"Invalid Google ID token: {str(e)}"
        )
    except Exception as e:
        # Catch any other verification errors
        raise GoogleTokenInvalidException(
            detail=f"Failed to verify Google ID token: {str(e)}"
        )
```

**Update `__all__` exports**:

```python
__all__ = [
    # ... existing exports ...
    "verify_google_id_token",
]
```

### 4. New Exceptions

**File**: `src/core/exceptions.py`

Add new exception classes:

```python
# ============================================================================
# Google OAuth Exceptions
# ============================================================================

class GoogleOAuthDisabledException(BaseAPIException):
    """Google OAuth is not enabled or configured."""

    def __init__(
        self,
        detail: str = "Google OAuth is not enabled. Please use email/password authentication."
    ) -> None:
        super().__init__(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=detail,
            error_code="GOOGLE_OAUTH_DISABLED",
        )


class GoogleTokenInvalidException(BaseAPIException):
    """Google ID token is invalid or could not be verified."""

    def __init__(self, detail: str = "Invalid or expired Google token") -> None:
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            error_code="GOOGLE_TOKEN_INVALID",
        )


class AccountLinkingConflictException(BaseAPIException):
    """Account linking conflict - email exists with different Google ID."""

    def __init__(
        self,
        detail: str = "This email is already registered. Please login with your password to link your Google account."
    ) -> None:
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail,
            error_code="ACCOUNT_LINKING_CONFLICT",
        )
```

### 5. Auth Service Method

**File**: `src/services/auth_service.py`

Add new method to `AuthService` class:

```python
from src.core.exceptions import (
    # ... existing imports ...
    GoogleOAuthDisabledException,
    GoogleTokenInvalidException,
    AccountLinkingConflictException,
)
from src.core.security import verify_google_id_token
from src.schemas.user import GoogleUserInfo


async def authenticate_google(
    self,
    id_token: str,
    client_ip: Optional[str] = None,
    user_agent: Optional[str] = None,
) -> Tuple[User, TokenResponse]:
    """Authenticate user with Google OAuth ID token.

    This method handles the complete Google OAuth flow:
    1. Verify Google ID token
    2. Find existing user by google_id or email
    3. Create new user or link Google account
    4. Generate JWT tokens
    5. Store session in Redis

    Account Linking Logic:
    - If user exists with this google_id -> login that user
    - If user exists with this email but no google_id -> link Google account
    - If user exists with this email AND different google_id -> error (conflict)
    - If no user exists -> create new user

    Args:
        id_token: Google ID token from frontend
        client_ip: Optional client IP for session tracking
        user_agent: Optional user agent for session tracking

    Returns:
        Tuple of (User, TokenResponse)

    Raises:
        GoogleOAuthDisabledException: Google OAuth not configured
        GoogleTokenInvalidException: Invalid or expired Google token
        AccountLinkingConflictException: Email exists with different Google account
    """
    from src.config import settings

    # Check if Google OAuth is enabled and configured
    if not settings.google_oauth_configured:
        raise GoogleOAuthDisabledException()

    # Step 1: Verify Google ID token
    google_user = verify_google_id_token(
        token=id_token,
        client_id=settings.google_client_id,
    )

    # Step 2: Find existing user by google_id
    user = await self._get_user_by_google_id(google_user.google_id)

    if user:
        # User found by google_id - this is a returning Google user
        logger.info(
            "Google OAuth login - existing user",
            extra={"user_id": str(user.id), "email": user.email},
        )
    else:
        # No user with this google_id, check by email
        user = await self._get_user_by_email(google_user.email)

        if user:
            # User exists with this email - attempt to link Google account
            if user.google_id is not None and user.google_id != google_user.google_id:
                # Email linked to a DIFFERENT Google account - conflict
                logger.warning(
                    "Google OAuth conflict - email linked to different Google account",
                    extra={
                        "email": google_user.email,
                        "existing_google_id": user.google_id[:10] + "...",
                        "new_google_id": google_user.google_id[:10] + "...",
                    },
                )
                raise AccountLinkingConflictException()

            # Link Google account to existing user
            user.google_id = google_user.google_id

            # Auto-verify email if Google says it's verified
            if google_user.email_verified and user.email_verified_at is None:
                user.email_verified_at = datetime.utcnow()

            # Update name if not set
            if user.full_name is None and google_user.full_name:
                user.full_name = google_user.full_name

            logger.info(
                "Google OAuth - linked to existing email account",
                extra={"user_id": str(user.id), "email": user.email},
            )
        else:
            # No user exists - create new user
            user = await self._create_google_user(google_user)
            logger.info(
                "Google OAuth - new user created",
                extra={"user_id": str(user.id), "email": user.email},
            )

    # Step 3: Validate user is active
    if not user.is_active:
        logger.warning(
            "Google OAuth attempt by inactive user",
            extra={"user_id": str(user.id), "email": user.email},
        )
        raise InvalidCredentialsException("Account is deactivated")

    # Step 4: Update last login
    user.last_login_at = datetime.utcnow()
    if client_ip:
        user.last_login_ip = client_ip

    # Step 5: Generate JWT tokens (reuse existing functions)
    access_token, access_expires = create_access_token(user.id)
    refresh_token, refresh_expires, token_id = create_refresh_token(user.id)

    # Step 6: Store session in Redis (reuse existing SessionRepository)
    redis_stored = await self.session_repo.create_session(
        user_id=user.id,
        token_id=token_id,
        token=refresh_token,
        expires_at=refresh_expires,
        ip_address=client_ip,
        user_agent=user_agent,
    )

    if not redis_stored:
        logger.warning(
            "Redis unavailable for Google OAuth session",
            extra={"user_id": str(user.id)},
        )

    # Commit all changes
    await self.db.commit()

    # Calculate expiry in seconds
    expires_in = int((access_expires - datetime.utcnow()).total_seconds())

    # Create token response (reuse existing schema)
    token_response = TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=expires_in,
    )

    return user, token_response


async def _get_user_by_google_id(self, google_id: str) -> Optional[User]:
    """Get user by Google ID.

    Args:
        google_id: Google's unique user identifier (sub claim)

    Returns:
        User model if found, None otherwise
    """
    result = await self.db.execute(
        select(User)
        .where(User.google_id == google_id)
        .options(selectinload(User.settings))
    )
    return result.scalar_one_or_none()


async def _create_google_user(self, google_user: GoogleUserInfo) -> User:
    """Create a new user from Google OAuth data.

    Args:
        google_user: Verified Google user information

    Returns:
        Created User model with settings
    """
    # Create user without password (OAuth-only user)
    user = User(
        email=google_user.email,
        password_hash=None,  # No password for OAuth users
        full_name=google_user.full_name,
        google_id=google_user.google_id,
        is_active=True,
        is_superuser=False,
        # Auto-verify email if Google says it's verified
        email_verified_at=datetime.utcnow() if google_user.email_verified else None,
    )

    self.db.add(user)
    await self.db.flush()  # Get user.id

    # Create default user settings (same as email registration)
    user_settings = UserSettings(
        user_id=user.id,
        daily_goal=20,
        email_notifications=True,
    )

    self.db.add(user_settings)

    return user
```

### 6. API Endpoint

**File**: `src/api/v1/auth.py`

Add new endpoint:

```python
from src.core.exceptions import (
    # ... existing imports ...
    GoogleOAuthDisabledException,
    GoogleTokenInvalidException,
    AccountLinkingConflictException,
)
from src.schemas.user import GoogleAuthRequest


@router.post(
    "/google",
    response_model=TokenResponse,
    summary="Login with Google",
    description="Authenticate using Google Sign-In ID token",
    responses={
        200: {
            "description": "Successfully authenticated with Google",
            "content": {
                "application/json": {
                    "example": {
                        "access_token": "eyJhbGciOiJIUzI1NiIs...",
                        "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
                        "token_type": "bearer",
                        "expires_in": 1800,
                    }
                }
            },
        },
        401: {
            "description": "Invalid Google token",
            "content": {
                "application/json": {
                    "example": {"detail": "Invalid or expired Google token"}
                }
            },
        },
        409: {
            "description": "Account linking conflict",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "This email is already registered. Please login with your password to link your Google account."
                    }
                }
            },
        },
        503: {
            "description": "Google OAuth not enabled",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Google OAuth is not enabled. Please use email/password authentication."
                    }
                }
            },
        },
    },
)
async def google_login(
    auth_data: GoogleAuthRequest,
    request: Request,
    db: AsyncSession = Depends(get_db),
) -> TokenResponse:
    """Authenticate with Google Sign-In.

    This endpoint accepts a Google ID token obtained from the Google Sign-In
    JavaScript SDK on the frontend. The token is verified against Google's
    public keys, and if valid, the user is authenticated.

    **New Users**: A new account is created automatically with the email
    and name from Google. The email is auto-verified.

    **Existing Users (by email)**: If an account exists with the same email
    but no Google account linked, the Google account is automatically linked.

    **Existing Google Users**: If the user has previously logged in with Google,
    they are authenticated to their existing account.

    Args:
        auth_data: Google ID token from frontend
        request: FastAPI request object for client IP
        db: Database session (injected)

    Returns:
        TokenResponse containing access and refresh tokens

    Raises:
        HTTPException(401): If Google token is invalid or expired
        HTTPException(409): If email is registered with a different Google account
        HTTPException(503): If Google OAuth is not enabled
    """
    service = AuthService(db)

    # Extract client info for session tracking
    client_ip = request.client.host if request.client else None
    user_agent = request.headers.get("user-agent")

    try:
        user, token_response = await service.authenticate_google(
            id_token=auth_data.id_token,
            client_ip=client_ip,
            user_agent=user_agent,
        )
        return token_response

    except GoogleOAuthDisabledException as e:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=e.detail,
        )

    except GoogleTokenInvalidException as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=e.detail,
        )

    except AccountLinkingConflictException as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=e.detail,
        )

    except InvalidCredentialsException as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=e.detail,
        )
```

**Optional: Control endpoint visibility with feature flag**

If you want to hide the endpoint from Swagger when disabled:

```python
# Add at module level
from src.config import settings

# Modify the router.post decorator:
@router.post(
    "/google",
    response_model=TokenResponse,
    include_in_schema=settings.feature_google_oauth,  # Hide if disabled
    # ... rest of decorator ...
)
```

---

## Account Linking Strategy

### Decision Matrix

| Scenario | google_id match | email match | google_id on user | Action |
|----------|----------------|-------------|-------------------|--------|
| 1. Returning Google user | Yes | - | - | Login to existing account |
| 2. New Google user | No | No | - | Create new account |
| 3. Email exists, no Google | No | Yes | None | Link Google to existing account |
| 4. Email exists, same Google | No | Yes | Same | Link (idempotent) |
| 5. Email exists, different Google | No | Yes | Different | Error - conflict |

### Detailed Scenarios

**Scenario 1: Returning Google User**
- User has logged in with Google before
- Lookup by `google_id` finds existing user
- Action: Login to that user account
- No changes to user record (except `last_login_at`)

**Scenario 2: New Google User**
- First-time Google login
- No user exists with this `google_id` or `email`
- Action: Create new user with:
  - `email` from Google
  - `google_id` from Google
  - `full_name` from Google
  - `password_hash = None` (OAuth-only)
  - `email_verified_at = now()` if Google email is verified

**Scenario 3: Email Exists, No Google Linked**
- User registered with email/password
- Same email tries Google login
- User's `google_id` is `None`
- Action: Link Google account
  - Set `user.google_id = google_user.google_id`
  - Auto-verify email if not verified
  - User can now login with either method

**Scenario 4: Email Exists, Same Google Already Linked**
- Edge case: link was already done
- Idempotent operation - just login

**Scenario 5: Email Exists, Different Google Account**
- User has email registered
- That email's account is linked to a DIFFERENT Google account
- This is a conflict - cannot have two Google accounts for one email
- Action: Raise `AccountLinkingConflictException`
- User should:
  1. Login with password
  2. Unlink existing Google (future feature)
  3. Then link new Google account

### Security Considerations for Account Linking

1. **Email Verification**: Only auto-verify email if Google reports `email_verified: true`
2. **No Password Override**: Linking Google doesn't affect existing password
3. **Audit Logging**: Log all account linking events
4. **User Notification**: Consider email notification on account link (future)

---

## Error Handling

### Exception Hierarchy

```
BaseAPIException
├── GoogleOAuthDisabledException (503)
│   - Google OAuth feature not enabled
│   - Google client ID not configured
│
├── GoogleTokenInvalidException (401)
│   - Token signature verification failed
│   - Token expired
│   - Wrong audience (client_id mismatch)
│   - Wrong issuer
│   - Malformed token
│
├── AccountLinkingConflictException (409)
│   - Email registered with different Google account
│
└── InvalidCredentialsException (401)
    - User account is deactivated
```

### Error Response Examples

**Google OAuth Disabled**:
```json
{
    "detail": "Google OAuth is not enabled. Please use email/password authentication."
}
```
Status: `503 Service Unavailable`

**Invalid Token**:
```json
{
    "detail": "Invalid or expired Google token"
}
```
Status: `401 Unauthorized`

**Account Conflict**:
```json
{
    "detail": "This email is already registered. Please login with your password to link your Google account."
}
```
Status: `409 Conflict`

**Deactivated User**:
```json
{
    "detail": "Account is deactivated"
}
```
Status: `401 Unauthorized`

### Logging Strategy

```python
# Info-level logs (successful operations)
"Google OAuth login - existing user"        # Returning user
"Google OAuth - linked to existing email"   # Account linked
"Google OAuth - new user created"           # New registration

# Warning-level logs (security events)
"Google OAuth conflict - email linked to different Google account"
"Google OAuth attempt by inactive user"
"Redis unavailable for Google OAuth session"

# Error-level logs (verification failures)
"Failed to verify Google ID token: {error}"
```

---

## Security Considerations

### Token Verification

1. **Use Official Library**: `google-auth` library handles token verification correctly
2. **Audience Verification**: Token's `aud` claim must match our `GOOGLE_CLIENT_ID`
3. **Issuer Verification**: Token must be issued by `accounts.google.com`
4. **Expiration Check**: Library automatically checks `exp` claim
5. **Signature Verification**: Library verifies against Google's public keys (cached)

### Key Caching

The `google-auth` library automatically caches Google's public keys:
- Keys are fetched from `https://www.googleapis.com/oauth2/v3/certs`
- Cached based on HTTP `Cache-Control` headers (typically 6 hours)
- Automatic refresh when keys expire

### Defense in Depth

1. **Input Validation**: Pydantic schema validates `id_token` is present and minimum length
2. **Server-Side Verification**: Never trust client-provided user info
3. **Database Constraints**: `google_id` column is unique (prevents duplicates)
4. **Rate Limiting**: Endpoint should use existing rate limiting
5. **HTTPS Only**: Tokens must be transmitted over HTTPS in production

### OAuth Security Best Practices

- **No Client Secret Needed**: ID token flow doesn't require client secret
- **Token Never Stored**: We generate our own JWT tokens, don't store Google's
- **One-Time Use**: Each Google ID token is used once to get our tokens
- **Scope Limitation**: We only request `openid email profile` scopes

### Account Takeover Prevention

1. **Email from Token Only**: Use email from verified token, not user input
2. **Google ID as Primary**: Match users by `google_id` first, more reliable
3. **Conflict Detection**: Prevent linking to accounts with different Google IDs
4. **Audit Trail**: Log all Google OAuth events

---

## Testing Strategy

### Unit Tests

**File**: `tests/unit/core/test_security_google.py`

```python
"""Unit tests for Google ID token verification."""

import pytest
from unittest.mock import patch, MagicMock

from src.core.security import verify_google_id_token
from src.core.exceptions import GoogleTokenInvalidException


class TestVerifyGoogleIdToken:
    """Tests for verify_google_id_token function."""

    @patch("src.core.security.google_id_token.verify_oauth2_token")
    def test_valid_token_returns_user_info(self, mock_verify):
        """Test successful token verification."""
        mock_verify.return_value = {
            "sub": "google-user-123",
            "email": "test@example.com",
            "email_verified": True,
            "name": "Test User",
            "picture": "https://example.com/photo.jpg",
            "iss": "accounts.google.com",
        }

        result = verify_google_id_token("valid-token", "client-id")

        assert result.google_id == "google-user-123"
        assert result.email == "test@example.com"
        assert result.email_verified is True
        assert result.full_name == "Test User"
        assert result.picture_url == "https://example.com/photo.jpg"

    @patch("src.core.security.google_id_token.verify_oauth2_token")
    def test_invalid_token_raises_exception(self, mock_verify):
        """Test invalid token raises GoogleTokenInvalidException."""
        mock_verify.side_effect = ValueError("Invalid token")

        with pytest.raises(GoogleTokenInvalidException) as exc_info:
            verify_google_id_token("invalid-token", "client-id")

        assert "Invalid Google ID token" in str(exc_info.value.detail)

    @patch("src.core.security.google_id_token.verify_oauth2_token")
    def test_wrong_issuer_raises_exception(self, mock_verify):
        """Test wrong issuer raises exception."""
        mock_verify.return_value = {
            "sub": "google-user-123",
            "email": "test@example.com",
            "iss": "malicious-issuer.com",
        }

        with pytest.raises(GoogleTokenInvalidException) as exc_info:
            verify_google_id_token("token", "client-id")

        assert "Invalid token issuer" in str(exc_info.value.detail)

    @patch("src.core.security.google_id_token.verify_oauth2_token")
    def test_minimal_claims_still_works(self, mock_verify):
        """Test token with only required claims."""
        mock_verify.return_value = {
            "sub": "google-user-123",
            "email": "test@example.com",
            "iss": "accounts.google.com",
        }

        result = verify_google_id_token("token", "client-id")

        assert result.google_id == "google-user-123"
        assert result.email == "test@example.com"
        assert result.email_verified is False  # Default
        assert result.full_name is None
        assert result.picture_url is None
```

**File**: `tests/unit/services/test_auth_service_google.py`

```python
"""Unit tests for AuthService.authenticate_google method."""

import pytest
from datetime import datetime
from unittest.mock import AsyncMock, patch, MagicMock
from uuid import uuid4

from src.services.auth_service import AuthService
from src.core.exceptions import (
    GoogleOAuthDisabledException,
    GoogleTokenInvalidException,
    AccountLinkingConflictException,
    InvalidCredentialsException,
)
from src.schemas.user import GoogleUserInfo


class TestAuthenticateGoogle:
    """Tests for authenticate_google method."""

    @pytest.fixture
    def mock_settings(self):
        """Mock settings with Google OAuth enabled."""
        with patch("src.services.auth_service.settings") as mock:
            mock.google_oauth_configured = True
            mock.google_client_id = "test-client-id"
            mock.jwt_access_token_expire_minutes = 30
            yield mock

    @pytest.fixture
    def google_user_info(self):
        """Sample Google user info."""
        return GoogleUserInfo(
            google_id="google-123",
            email="test@example.com",
            email_verified=True,
            full_name="Test User",
            picture_url=None,
        )

    @pytest.mark.asyncio
    async def test_oauth_disabled_raises_exception(self, db_session):
        """Test that disabled OAuth raises exception."""
        with patch("src.services.auth_service.settings") as mock_settings:
            mock_settings.google_oauth_configured = False

            service = AuthService(db_session)

            with pytest.raises(GoogleOAuthDisabledException):
                await service.authenticate_google("token")

    @pytest.mark.asyncio
    async def test_new_user_created(
        self, db_session, mock_settings, google_user_info
    ):
        """Test new user is created for new Google account."""
        with patch("src.services.auth_service.verify_google_id_token") as mock_verify:
            mock_verify.return_value = google_user_info

            service = AuthService(db_session)
            service.session_repo = AsyncMock()
            service.session_repo.create_session = AsyncMock(return_value=True)

            user, tokens = await service.authenticate_google("valid-token")

            assert user.email == "test@example.com"
            assert user.google_id == "google-123"
            assert user.password_hash is None
            assert user.email_verified_at is not None

    @pytest.mark.asyncio
    async def test_existing_google_user_login(
        self, db_session, mock_settings, google_user_info, test_user
    ):
        """Test existing Google user can login."""
        # Set up existing user with Google ID
        test_user.google_id = google_user_info.google_id
        await db_session.commit()

        with patch("src.services.auth_service.verify_google_id_token") as mock_verify:
            mock_verify.return_value = google_user_info

            service = AuthService(db_session)
            service.session_repo = AsyncMock()
            service.session_repo.create_session = AsyncMock(return_value=True)

            user, tokens = await service.authenticate_google("valid-token")

            assert user.id == test_user.id

    @pytest.mark.asyncio
    async def test_account_linking(
        self, db_session, mock_settings, google_user_info, test_user
    ):
        """Test Google account linked to existing email user."""
        # Set up existing user WITHOUT Google ID
        test_user.email = google_user_info.email
        test_user.google_id = None
        await db_session.commit()

        with patch("src.services.auth_service.verify_google_id_token") as mock_verify:
            mock_verify.return_value = google_user_info

            service = AuthService(db_session)
            service.session_repo = AsyncMock()
            service.session_repo.create_session = AsyncMock(return_value=True)

            user, tokens = await service.authenticate_google("valid-token")

            assert user.id == test_user.id
            assert user.google_id == google_user_info.google_id

    @pytest.mark.asyncio
    async def test_account_conflict_raises_exception(
        self, db_session, mock_settings, google_user_info, test_user
    ):
        """Test conflict when email linked to different Google account."""
        # Set up existing user with DIFFERENT Google ID
        test_user.email = google_user_info.email
        test_user.google_id = "different-google-id"
        await db_session.commit()

        with patch("src.services.auth_service.verify_google_id_token") as mock_verify:
            mock_verify.return_value = google_user_info

            service = AuthService(db_session)

            with pytest.raises(AccountLinkingConflictException):
                await service.authenticate_google("valid-token")

    @pytest.mark.asyncio
    async def test_inactive_user_rejected(
        self, db_session, mock_settings, google_user_info, test_user
    ):
        """Test inactive user cannot login via Google."""
        test_user.google_id = google_user_info.google_id
        test_user.is_active = False
        await db_session.commit()

        with patch("src.services.auth_service.verify_google_id_token") as mock_verify:
            mock_verify.return_value = google_user_info

            service = AuthService(db_session)

            with pytest.raises(InvalidCredentialsException):
                await service.authenticate_google("valid-token")
```

### Integration Tests

**File**: `tests/integration/test_auth_google.py`

```python
"""Integration tests for Google OAuth endpoint."""

import pytest
from unittest.mock import patch
from httpx import AsyncClient

from src.main import app


class TestGoogleOAuthEndpoint:
    """Integration tests for POST /api/v1/auth/google."""

    @pytest.mark.asyncio
    async def test_google_oauth_disabled_returns_503(self, client: AsyncClient):
        """Test 503 returned when Google OAuth is disabled."""
        with patch("src.config.settings.google_oauth_configured", False):
            response = await client.post(
                "/api/v1/auth/google",
                json={"id_token": "x" * 200}
            )

            assert response.status_code == 503
            assert "not enabled" in response.json()["detail"]

    @pytest.mark.asyncio
    async def test_invalid_token_returns_401(self, client: AsyncClient):
        """Test 401 returned for invalid token."""
        with patch("src.config.settings.google_oauth_configured", True):
            with patch("src.core.security.google_id_token.verify_oauth2_token") as mock:
                mock.side_effect = ValueError("Invalid token")

                response = await client.post(
                    "/api/v1/auth/google",
                    json={"id_token": "invalid-token" * 20}
                )

                assert response.status_code == 401

    @pytest.mark.asyncio
    async def test_successful_google_login_returns_tokens(
        self, client: AsyncClient
    ):
        """Test successful Google login returns tokens."""
        with patch("src.config.settings.google_oauth_configured", True):
            with patch("src.core.security.google_id_token.verify_oauth2_token") as mock:
                mock.return_value = {
                    "sub": "google-123",
                    "email": "newuser@example.com",
                    "email_verified": True,
                    "name": "New User",
                    "iss": "accounts.google.com",
                }

                response = await client.post(
                    "/api/v1/auth/google",
                    json={"id_token": "valid-token" * 50}
                )

                assert response.status_code == 200
                data = response.json()
                assert "access_token" in data
                assert "refresh_token" in data
                assert data["token_type"] == "bearer"
```

### Test Coverage Goals

- **Token Verification**: 100%
- **AuthService.authenticate_google**: 95%
- **API Endpoint**: 90%
- **Account Linking Logic**: 100%
- **Error Handling**: 100%

---

## Implementation Checklist

### Phase 1: Setup (15 min)

- [ ] Add `google-auth` dependency to `pyproject.toml`
- [ ] Run `poetry install`
- [ ] Add `.env.example` documentation for Google OAuth config

### Phase 2: Core Implementation (2 hours)

- [ ] Add `google_oauth_configured` property to `Settings` class
- [ ] Add `GoogleAuthRequest` and `GoogleUserInfo` schemas to `src/schemas/user.py`
- [ ] Add `GoogleOAuthDisabledException`, `GoogleTokenInvalidException`, `AccountLinkingConflictException` to `src/core/exceptions.py`
- [ ] Add `verify_google_id_token()` function to `src/core/security.py`
- [ ] Add `authenticate_google()` method to `AuthService`
- [ ] Add `_get_user_by_google_id()` helper method to `AuthService`
- [ ] Add `_create_google_user()` helper method to `AuthService`
- [ ] Add `POST /api/v1/auth/google` endpoint to `src/api/v1/auth.py`

### Phase 3: Testing (1.5 hours)

- [ ] Create `tests/unit/core/test_security_google.py`
- [ ] Create `tests/unit/services/test_auth_service_google.py`
- [ ] Create `tests/integration/test_auth_google.py`
- [ ] Create verification script `scripts/verify_google_oauth.py`
- [ ] Run all tests, ensure 90%+ coverage

### Phase 4: Documentation & Verification (30 min)

- [ ] Update API documentation (Swagger shows new endpoint)
- [ ] Update `.env.example` with Google OAuth placeholders
- [ ] Manual testing with real Google account (optional, requires setup)
- [ ] Create QA report

### Post-Implementation

- [ ] Set `FEATURE_GOOGLE_OAUTH=true` in environment
- [ ] Configure `GOOGLE_CLIENT_ID` in Google Cloud Console
- [ ] Update frontend to use Google Sign-In SDK
- [ ] Test end-to-end flow

---

## Frontend Integration Notes

For the frontend team implementing Google Sign-In:

### Google Sign-In JavaScript SDK

```javascript
// Initialize Google Sign-In
google.accounts.id.initialize({
  client_id: "YOUR_GOOGLE_CLIENT_ID",
  callback: handleGoogleCredentialResponse,
});

// Render button
google.accounts.id.renderButton(
  document.getElementById("googleSignInButton"),
  { theme: "outline", size: "large" }
);

// Handle response
async function handleGoogleCredentialResponse(response) {
  const idToken = response.credential;

  // Send to backend
  const result = await fetch("/api/v1/auth/google", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ id_token: idToken }),
  });

  if (result.ok) {
    const tokens = await result.json();
    // Store tokens and redirect
  } else {
    // Handle errors
  }
}
```

### Error Handling on Frontend

| Status | Action |
|--------|--------|
| 200 | Store tokens, redirect to app |
| 401 | Show "Invalid Google account" error |
| 409 | Show "Please login with password to link" message |
| 503 | Hide Google button, show "unavailable" |

---

**Document End**

**Last Updated**: 2025-12-04
**Status**: Ready for Implementation
**Estimated Duration**: 3-4 hours
**Next Task**: Implement and test Google OAuth
