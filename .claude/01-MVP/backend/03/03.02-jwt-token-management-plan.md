# Subtask 03.02: JWT Token Generation and Validation - Detailed Implementation Plan

**Document Version**: 1.0
**Created**: 2025-11-25
**Status**: ✅ COMPLETED (2025-11-25)
**Actual Duration**: 60 minutes
**Priority**: Critical (Authentication Foundation)
**Dependencies**: Task 03.01 (Password Hashing) - COMPLETED

**Completion Summary**:
- ✅ All 4 JWT functions implemented (create_access_token, create_refresh_token, verify_token, extract_token_from_header)
- ✅ HTTPBearer security_scheme configured
- ✅ 28/28 unit tests passed (100% success rate)
- ✅ Test coverage: 100% for JWT functions
- ✅ Verification script: 8/8 checks passed
- ✅ Security: HS256 algorithm, token type validation, UTC timestamps, confused deputy attack prevention
- ✅ QA Report: [.claude/qa/03.02-jwt-token-verification.md](../../qa/03.02-jwt-token-verification.md)
- ✅ Status: READY FOR PRODUCTION

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites Verification](#prerequisites-verification)
3. [JWT Architecture & Design](#jwt-architecture--design)
4. [Step-by-Step Implementation](#step-by-step-implementation)
5. [Testing Instructions](#testing-instructions)
6. [Validation Checklist](#validation-checklist)
7. [Security Considerations](#security-considerations)
8. [Common Pitfalls & Solutions](#common-pitfalls--solutions)
9. [Integration Points](#integration-points)
10. [Next Steps](#next-steps)

---

## Overview

### Objective

Extend the existing `src/core/security.py` module with JWT token generation and validation functions that will power the authentication system for the Learn Greek Easy application.

### What You'll Build

**File**: `src/core/security.py` (EXTEND existing file)

**New Functions**:
1. `create_access_token(user_id: UUID) -> tuple[str, datetime]` - Generate short-lived access tokens
2. `create_refresh_token(user_id: UUID) -> tuple[str, datetime]` - Generate long-lived refresh tokens
3. `verify_token(token: str, token_type: str) -> UUID` - Validate tokens and extract user ID
4. `extract_token_from_header(credentials: HTTPAuthorizationCredentials | None) -> str` - Extract Bearer token

**Integration**:
- Works with existing `hash_password()` and `verify_password()` functions
- Uses `RefreshToken` model from Task 02 for database persistence
- Integrates with FastAPI dependency injection system
- Raises custom exceptions from `src/core/exceptions.py`

### Success Criteria

- Access tokens have 30-minute expiry (configurable)
- Refresh tokens have 30-day expiry (configurable)
- Token verification extracts correct user_id
- Token type validation (access vs refresh) works
- Expired tokens raise `TokenExpiredException`
- Invalid tokens raise `TokenInvalidException`
- Unit tests pass with 100% coverage for new code
- Type hints complete and mypy passes

---

## Prerequisites Verification

### Step 1: Verify Existing Security Module

Confirm Task 03.01 is completed:

```bash
# Check that security.py exists and has password functions
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.core.security import hash_password, verify_password; print('✓ Password hashing available')"
```

**Expected**: `✓ Password hashing available`

### Step 2: Verify JWT Dependencies

Check that python-jose is installed:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry show | grep jose
```

**Expected Output**:
```
python-jose    3.3.0  JOSE implementation in Python
```

**If missing**, install it:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry add "python-jose[cryptography]"
```

### Step 3: Verify Configuration Settings

Check JWT configuration exists:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.config import settings; print(f'JWT Secret: {settings.jwt_secret_key[:20]}...'); print(f'Algorithm: {settings.jwt_algorithm}'); print(f'Access Token Expiry: {settings.jwt_access_token_expire_minutes} min'); print(f'Refresh Token Expiry: {settings.jwt_refresh_token_expire_days} days')"
```

**Expected**: Should print JWT configuration values without errors

### Step 4: Verify Custom Exceptions Exist

Check that token exceptions are defined:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.core.exceptions import TokenExpiredException, TokenInvalidException; print('✓ Token exceptions available')"
```

**Expected**: `✓ Token exceptions available`

### Step 5: Verify RefreshToken Model

Check that the RefreshToken model exists:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.db.models import RefreshToken; print('✓ RefreshToken model available')"
```

**Expected**: `✓ RefreshToken model available`

---

## JWT Architecture & Design

### JWT Token Structure

Both access and refresh tokens follow the standard JWT structure:

```
HEADER.PAYLOAD.SIGNATURE

Example:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3OC05MGFiLWNkZWYtMTIzNC01Njc4OTBhYmNkZWYiLCJleHAiOjE3MDA1NjAwMDAsImlhdCI6MTcwMDU1ODIwMCwidHlwZSI6ImFjY2VzcyJ9.signature_here
```

### Payload Structure

**Access Token Payload**:
```json
{
  "sub": "user-uuid-here",           // Subject: user ID
  "exp": 1700560000,                 // Expiration timestamp (30 min from now)
  "iat": 1700558200,                 // Issued at timestamp (now)
  "type": "access"                   // Token type for validation
}
```

**Refresh Token Payload**:
```json
{
  "sub": "user-uuid-here",           // Subject: user ID
  "exp": 1702977600,                 // Expiration timestamp (30 days from now)
  "iat": 1700558200,                 // Issued at timestamp (now)
  "type": "refresh"                  // Token type for validation
}
```

### Token Lifecycle

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TOKEN LIFECYCLE                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. USER LOGS IN                                                    │
│     ├─> create_access_token(user_id)                               │
│     │   └─> Returns: (access_token, expires_at)                    │
│     │       • Valid for 30 minutes                                 │
│     │       • Used for API requests                                │
│     │       • NOT stored in database                               │
│     │                                                               │
│     └─> create_refresh_token(user_id)                              │
│         └─> Returns: (refresh_token, expires_at)                   │
│             • Valid for 30 days                                    │
│             • Used to get new access tokens                        │
│             • STORED in database (for revocation)                  │
│                                                                     │
│  2. USER MAKES API REQUEST                                          │
│     ├─> Client sends: Authorization: Bearer <access_token>         │
│     └─> verify_token(access_token, "access")                       │
│         └─> Returns: user_id (UUID)                                │
│                                                                     │
│  3. ACCESS TOKEN EXPIRES (after 30 min)                             │
│     ├─> API returns 401 Unauthorized                               │
│     └─> Client uses refresh token to get new access token          │
│                                                                     │
│  4. TOKEN REFRESH                                                   │
│     ├─> Client sends: POST /auth/refresh                           │
│     │   Body: { "refresh_token": "..." }                           │
│     │                                                               │
│     ├─> verify_token(refresh_token, "refresh")                     │
│     │   └─> Returns: user_id                                       │
│     │                                                               │
│     ├─> Check database: Is token still valid?                      │
│     │   • Not revoked                                              │
│     │   • Not expired in DB                                        │
│     │                                                               │
│     └─> Issue new access token                                     │
│         └─> create_access_token(user_id)                           │
│                                                                     │
│  5. USER LOGS OUT                                                   │
│     └─> Delete refresh token from database (revocation)            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Security Design Decisions

| Decision | Rationale |
|----------|-----------|
| **HS256 Algorithm** | Symmetric signing with shared secret. Simpler than RSA for single-server deployments. Fast and secure with proper key management. |
| **30-minute Access Tokens** | Balance between security (short-lived) and UX (not too frequent refreshes). If stolen, only valid for 30 min. |
| **30-day Refresh Tokens** | Allows "remember me" functionality. Long enough for mobile apps, short enough to force re-auth periodically. |
| **Type Field in Payload** | Prevents using a refresh token as an access token (confused deputy attack). |
| **Database-backed Refresh Tokens** | Enables revocation (logout, password change). Access tokens are stateless (no DB lookup per request). |
| **UTC Timestamps** | Avoids timezone issues. All timestamps in UTC. |
| **UUID as Subject** | User ID in token payload. Avoids additional DB lookups to identify user. |

---

## Step-by-Step Implementation

### STEP 1: Add JWT Imports to security.py

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/security.py`

**Action**: Add these imports at the top of the file (after existing imports):

```python
# Add these imports to the existing import section
from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID

from fastapi import status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from jose import JWTError, jwt

from src.config import settings
from src.core.exceptions import TokenExpiredException, TokenInvalidException
```

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -m py_compile src/core/security.py
```

Expected: No output (success)

---

### STEP 2: Add JWT Token Generation Functions

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/security.py`

**Action**: Add these functions AFTER the password strength validation section (before `__all__`):

```python
# ============================================================================
# JWT Token Generation
# ============================================================================


def create_access_token(user_id: UUID) -> tuple[str, datetime]:
    """Create a JWT access token for API authentication.

    Access tokens are short-lived (30 minutes) and used for authenticating
    API requests. They are NOT stored in the database - verification is
    purely cryptographic.

    Args:
        user_id (UUID): The unique identifier of the user.

    Returns:
        tuple[str, datetime]: A tuple containing:
            - str: The encoded JWT token string
            - datetime: The expiration timestamp (UTC)

    Raises:
        None: This function does not raise exceptions.

    Security Notes:
        - Token expires after jwt_access_token_expire_minutes (default: 30)
        - Contains user_id in "sub" claim for identification
        - Includes "type": "access" to prevent token confusion attacks
        - Uses HS256 algorithm with shared secret
        - Timestamps are in UTC to avoid timezone issues

    Example:
        >>> from uuid import uuid4
        >>> user_id = uuid4()
        >>> token, expires_at = create_access_token(user_id)
        >>> print(f"Token length: {len(token)}")  # ~200 characters
        Token length: 215
        >>> print(f"Expires: {expires_at}")
        Expires: 2024-11-25 15:30:00+00:00
        >>> # Verify the token
        >>> verified_user_id = verify_token(token, "access")
        >>> assert verified_user_id == user_id
    """
    now = datetime.utcnow()
    expires_at = now + timedelta(minutes=settings.jwt_access_token_expire_minutes)

    payload = {
        "sub": str(user_id),  # Subject: user ID (convert UUID to string)
        "exp": expires_at,    # Expiration time (datetime, auto-converted to timestamp)
        "iat": now,           # Issued at (datetime, auto-converted to timestamp)
        "type": "access",     # Token type for validation
    }

    # Encode the JWT token
    token = jwt.encode(
        payload,
        settings.jwt_secret_key,
        algorithm=settings.jwt_algorithm,
    )

    return token, expires_at


def create_refresh_token(user_id: UUID) -> tuple[str, datetime]:
    """Create a JWT refresh token for obtaining new access tokens.

    Refresh tokens are long-lived (30 days) and used to obtain new access
    tokens without re-entering credentials. They MUST be stored in the
    database to enable revocation (logout, password change).

    Args:
        user_id (UUID): The unique identifier of the user.

    Returns:
        tuple[str, datetime]: A tuple containing:
            - str: The encoded JWT token string
            - datetime: The expiration timestamp (UTC)

    Raises:
        None: This function does not raise exceptions.

    Security Notes:
        - Token expires after jwt_refresh_token_expire_days (default: 30)
        - MUST be stored in database (RefreshToken model)
        - Contains "type": "refresh" to prevent using as access token
        - Should be revoked on logout or password change
        - Uses same secret and algorithm as access tokens

    Example:
        >>> from uuid import uuid4
        >>> user_id = uuid4()
        >>> token, expires_at = create_refresh_token(user_id)
        >>> print(f"Token: {token[:50]}...")
        Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi...
        >>> # This token MUST be stored in the database
        >>> # refresh_token_record = RefreshToken(user_id=user_id, token=token, expires_at=expires_at)
    """
    now = datetime.utcnow()
    expires_at = now + timedelta(days=settings.jwt_refresh_token_expire_days)

    payload = {
        "sub": str(user_id),  # Subject: user ID
        "exp": expires_at,    # Expiration time
        "iat": now,           # Issued at
        "type": "refresh",    # Token type for validation
    }

    # Encode the JWT token
    token = jwt.encode(
        payload,
        settings.jwt_secret_key,
        algorithm=settings.jwt_algorithm,
    )

    return token, expires_at
```

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.core.security import create_access_token, create_refresh_token; from uuid import uuid4; token, exp = create_access_token(uuid4()); print(f'✓ Access token created: {len(token)} chars'); token, exp = create_refresh_token(uuid4()); print(f'✓ Refresh token created: {len(token)} chars')"
```

Expected:
```
✓ Access token created: ~200 chars
✓ Refresh token created: ~200 chars
```

---

### STEP 3: Add Token Verification Function

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/security.py`

**Action**: Add this function after the token generation functions:

```python
# ============================================================================
# JWT Token Verification
# ============================================================================


def verify_token(token: str, token_type: str = "access") -> UUID:
    """Verify a JWT token and extract the user ID.

    Validates the token signature, expiration, and type. This is a
    cryptographic operation - no database lookup is performed here.
    For refresh tokens, you MUST also check the database to ensure
    the token hasn't been revoked.

    Args:
        token (str): The JWT token string to verify.
        token_type (str): Expected token type ("access" or "refresh").
            Defaults to "access".

    Returns:
        UUID: The user ID extracted from the token's "sub" claim.

    Raises:
        TokenExpiredException: If the token has expired (exp claim).
        TokenInvalidException: If the token is invalid for any reason:
            - Invalid signature (wrong secret key)
            - Invalid format (malformed JWT)
            - Wrong token type (refresh token used as access, etc.)
            - Missing required claims (sub, type)
            - Invalid UUID format in sub claim

    Security Notes:
        - Always verify token type to prevent confused deputy attacks
        - Expired tokens raise TokenExpiredException (401 Unauthorized)
        - Invalid tokens raise TokenInvalidException (401 Unauthorized)
        - For refresh tokens, ALWAYS check database revocation after this
        - Uses constant-time signature verification (timing attack safe)

    Example:
        >>> from uuid import uuid4
        >>> user_id = uuid4()
        >>> # Create and verify access token
        >>> access_token, _ = create_access_token(user_id)
        >>> verified_id = verify_token(access_token, "access")
        >>> assert verified_id == user_id
        >>>
        >>> # Wrong token type raises exception
        >>> refresh_token, _ = create_refresh_token(user_id)
        >>> try:
        ...     verify_token(refresh_token, "access")  # Wrong type!
        ... except TokenInvalidException as e:
        ...     print(f"Caught: {e.detail}")
        Caught: Invalid token type, expected access
        >>>
        >>> # Expired token raises exception
        >>> # (Token with exp in the past would raise TokenExpiredException)
    """
    try:
        # Decode and verify the JWT token
        # This validates:
        # - Signature (using secret key)
        # - Expiration (exp claim)
        # - Algorithm (must match jwt_algorithm)
        payload = jwt.decode(
            token,
            settings.jwt_secret_key,
            algorithms=[settings.jwt_algorithm],
        )

        # Verify token type matches expected type
        # This prevents using a refresh token as an access token
        if payload.get("type") != token_type:
            raise TokenInvalidException(
                detail=f"Invalid token type, expected {token_type}"
            )

        # Extract user_id from "sub" claim
        user_id_str = payload.get("sub")
        if not user_id_str:
            raise TokenInvalidException(detail="Token missing subject claim")

        # Convert string UUID to UUID object
        try:
            user_id = UUID(user_id_str)
        except (ValueError, TypeError) as e:
            raise TokenInvalidException(detail=f"Invalid user ID format: {e}")

        return user_id

    except JWTError as e:
        # JWTError is the base exception from python-jose
        # It includes ExpiredSignatureError, JWTClaimsError, etc.

        error_str = str(e).lower()

        # Check if this is an expiration error
        # ExpiredSignatureError message contains "expired"
        if "expired" in error_str or "signature has expired" in error_str:
            raise TokenExpiredException()

        # All other JWT errors are considered invalid tokens
        raise TokenInvalidException(detail=str(e))
```

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "
from src.core.security import create_access_token, verify_token
from uuid import uuid4

user_id = uuid4()
token, _ = create_access_token(user_id)
verified_id = verify_token(token, 'access')

assert verified_id == user_id
print('✓ Token verification works correctly')
"
```

Expected: `✓ Token verification works correctly`

---

### STEP 4: Add Token Extraction Helper

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/security.py`

**Action**: Add this function and the HTTPBearer scheme instance:

```python
# ============================================================================
# Token Extraction from HTTP Headers
# ============================================================================

# HTTPBearer security scheme for FastAPI dependency injection
# This will extract the "Authorization: Bearer <token>" header
# auto_error=False means it won't automatically raise 403, we handle it manually
security_scheme = HTTPBearer(auto_error=False)


def extract_token_from_header(
    credentials: Optional[HTTPAuthorizationCredentials],
) -> str:
    """Extract JWT token from Authorization header.

    Used as a FastAPI dependency to extract the Bearer token from
    the Authorization header.

    Args:
        credentials (Optional[HTTPAuthorizationCredentials]):
            Credentials from HTTPBearer dependency.
            None if no Authorization header was provided.

    Returns:
        str: The extracted JWT token string.

    Raises:
        TokenInvalidException: If no credentials were provided.

    Security Notes:
        - Expects "Authorization: Bearer <token>" header
        - Does NOT validate the token (use verify_token for that)
        - Returns raw token string for further processing
        - Raises TokenInvalidException (401) if missing

    Example (in FastAPI endpoint):
        >>> from fastapi import Depends
        >>> from src.core.security import security_scheme, extract_token_from_header, verify_token
        >>>
        >>> @app.get("/protected")
        >>> async def protected_endpoint(
        ...     credentials: HTTPAuthorizationCredentials = Depends(security_scheme)
        ... ):
        ...     # Extract token
        ...     token = extract_token_from_header(credentials)
        ...     # Verify token and get user_id
        ...     user_id = verify_token(token, "access")
        ...     return {"user_id": str(user_id)}
    """
    if not credentials:
        raise TokenInvalidException(detail="No authentication token provided")

    # HTTPAuthorizationCredentials has:
    # - scheme: "Bearer"
    # - credentials: The actual token string
    return credentials.credentials
```

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "
from src.core.security import extract_token_from_header, security_scheme
from src.core.exceptions import TokenInvalidException
from fastapi.security import HTTPAuthorizationCredentials

# Test with valid credentials
creds = HTTPAuthorizationCredentials(scheme='Bearer', credentials='test-token-123')
token = extract_token_from_header(creds)
assert token == 'test-token-123'

# Test with None (should raise exception)
try:
    extract_token_from_header(None)
    assert False, 'Should have raised exception'
except TokenInvalidException:
    pass

print('✓ Token extraction works correctly')
"
```

Expected: `✓ Token extraction works correctly`

---

### STEP 5: Update __all__ Export List

**File**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/src/core/security.py`

**Action**: Update the `__all__` list at the end of the file to include new functions:

```python
# ============================================================================
# Export Public API
# ============================================================================

__all__ = [
    # Password hashing (from Task 03.01)
    "hash_password",
    "verify_password",
    "validate_password_strength",
    "pwd_context",
    # JWT token management (Task 03.02)
    "create_access_token",
    "create_refresh_token",
    "verify_token",
    "extract_token_from_header",
    "security_scheme",
]
```

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "
from src.core.security import (
    create_access_token,
    create_refresh_token,
    verify_token,
    extract_token_from_header,
    security_scheme,
)
print('✓ All JWT functions exported correctly')
"
```

Expected: `✓ All JWT functions exported correctly`

---

### STEP 6: Final Code Validation

**Run all validation checks**:

```bash
# Syntax check
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -m py_compile src/core/security.py

# Type checking
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run mypy src/core/security.py

# Import all functions
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.core.security import create_access_token, create_refresh_token, verify_token, extract_token_from_header, security_scheme; print('✓ All imports successful')"
```

**Expected**: All checks pass without errors

---

## Testing Instructions

### STEP 7: Create Comprehensive Unit Tests

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/tests/unit/test_jwt_tokens.py`

**Complete Test Code**:

```python
"""Unit tests for JWT token generation and validation.

Tests cover:
- Access token generation with correct expiry
- Refresh token generation with correct expiry
- Token verification with correct user_id extraction
- Token type validation (access vs refresh)
- Expired token handling
- Invalid token handling
- Token extraction from HTTP headers
"""

import time
from datetime import datetime, timedelta
from uuid import UUID, uuid4

import pytest
from fastapi.security import HTTPAuthorizationCredentials
from jose import jwt

from src.config import settings
from src.core.exceptions import TokenExpiredException, TokenInvalidException
from src.core.security import (
    create_access_token,
    create_refresh_token,
    extract_token_from_header,
    verify_token,
)


# ============================================================================
# Test Fixtures
# ============================================================================


@pytest.fixture
def sample_user_id() -> UUID:
    """Provide a sample user UUID for testing."""
    return uuid4()


@pytest.fixture
def sample_access_token(sample_user_id: UUID) -> tuple[str, datetime]:
    """Provide a sample access token and expiration."""
    return create_access_token(sample_user_id)


@pytest.fixture
def sample_refresh_token(sample_user_id: UUID) -> tuple[str, datetime]:
    """Provide a sample refresh token and expiration."""
    return create_refresh_token(sample_user_id)


# ============================================================================
# Access Token Generation Tests
# ============================================================================


class TestAccessTokenGeneration:
    """Tests for access token generation."""

    def test_create_access_token_returns_tuple(self, sample_user_id: UUID) -> None:
        """Test that create_access_token returns (token, expiration) tuple."""
        result = create_access_token(sample_user_id)
        assert isinstance(result, tuple)
        assert len(result) == 2
        token, expires_at = result
        assert isinstance(token, str)
        assert isinstance(expires_at, datetime)

    def test_access_token_is_valid_jwt(self, sample_access_token: tuple[str, datetime]) -> None:
        """Test that access token is a valid JWT format."""
        token, _ = sample_access_token
        # JWT format: header.payload.signature
        parts = token.split(".")
        assert len(parts) == 3

    def test_access_token_expiry_is_30_minutes(
        self, sample_user_id: UUID
    ) -> None:
        """Test that access token expires in 30 minutes (or configured value)."""
        before = datetime.utcnow()
        token, expires_at = create_access_token(sample_user_id)
        after = datetime.utcnow()

        # Calculate expected expiry range
        expected_delta = timedelta(minutes=settings.jwt_access_token_expire_minutes)
        min_expiry = before + expected_delta
        max_expiry = after + expected_delta

        # Expiration should be within this range
        assert min_expiry <= expires_at <= max_expiry

    def test_access_token_contains_correct_payload(
        self, sample_user_id: UUID
    ) -> None:
        """Test that access token payload contains correct claims."""
        token, expires_at = create_access_token(sample_user_id)

        # Decode WITHOUT verification to inspect payload
        payload = jwt.decode(
            token,
            settings.jwt_secret_key,
            algorithms=[settings.jwt_algorithm],
        )

        # Verify payload structure
        assert "sub" in payload
        assert "exp" in payload
        assert "iat" in payload
        assert "type" in payload

        # Verify payload values
        assert payload["sub"] == str(sample_user_id)
        assert payload["type"] == "access"

    def test_access_token_different_each_time(self, sample_user_id: UUID) -> None:
        """Test that generating access tokens produces different tokens each time."""
        token1, _ = create_access_token(sample_user_id)
        time.sleep(0.01)  # Small delay to ensure different iat
        token2, _ = create_access_token(sample_user_id)

        # Tokens should be different due to different "iat" timestamps
        assert token1 != token2


# ============================================================================
# Refresh Token Generation Tests
# ============================================================================


class TestRefreshTokenGeneration:
    """Tests for refresh token generation."""

    def test_create_refresh_token_returns_tuple(self, sample_user_id: UUID) -> None:
        """Test that create_refresh_token returns (token, expiration) tuple."""
        result = create_refresh_token(sample_user_id)
        assert isinstance(result, tuple)
        assert len(result) == 2
        token, expires_at = result
        assert isinstance(token, str)
        assert isinstance(expires_at, datetime)

    def test_refresh_token_is_valid_jwt(
        self, sample_refresh_token: tuple[str, datetime]
    ) -> None:
        """Test that refresh token is a valid JWT format."""
        token, _ = sample_refresh_token
        parts = token.split(".")
        assert len(parts) == 3

    def test_refresh_token_expiry_is_30_days(self, sample_user_id: UUID) -> None:
        """Test that refresh token expires in 30 days (or configured value)."""
        before = datetime.utcnow()
        token, expires_at = create_refresh_token(sample_user_id)
        after = datetime.utcnow()

        # Calculate expected expiry range
        expected_delta = timedelta(days=settings.jwt_refresh_token_expire_days)
        min_expiry = before + expected_delta
        max_expiry = after + expected_delta

        # Expiration should be within this range
        assert min_expiry <= expires_at <= max_expiry

    def test_refresh_token_contains_correct_payload(
        self, sample_user_id: UUID
    ) -> None:
        """Test that refresh token payload contains correct claims."""
        token, expires_at = create_refresh_token(sample_user_id)

        payload = jwt.decode(
            token,
            settings.jwt_secret_key,
            algorithms=[settings.jwt_algorithm],
        )

        # Verify payload structure
        assert "sub" in payload
        assert "exp" in payload
        assert "iat" in payload
        assert "type" in payload

        # Verify payload values
        assert payload["sub"] == str(sample_user_id)
        assert payload["type"] == "refresh"

    def test_refresh_token_different_from_access_token(
        self, sample_user_id: UUID
    ) -> None:
        """Test that access and refresh tokens are different."""
        access_token, _ = create_access_token(sample_user_id)
        refresh_token, _ = create_refresh_token(sample_user_id)

        assert access_token != refresh_token


# ============================================================================
# Token Verification Tests
# ============================================================================


class TestTokenVerification:
    """Tests for token verification and user_id extraction."""

    def test_verify_access_token_returns_user_id(
        self, sample_user_id: UUID, sample_access_token: tuple[str, datetime]
    ) -> None:
        """Test that verifying access token returns correct user_id."""
        token, _ = sample_access_token
        user_id = verify_token(token, "access")

        assert isinstance(user_id, UUID)
        assert user_id == sample_user_id

    def test_verify_refresh_token_returns_user_id(
        self, sample_user_id: UUID, sample_refresh_token: tuple[str, datetime]
    ) -> None:
        """Test that verifying refresh token returns correct user_id."""
        token, _ = sample_refresh_token
        user_id = verify_token(token, "refresh")

        assert isinstance(user_id, UUID)
        assert user_id == sample_user_id

    def test_verify_token_default_type_is_access(
        self, sample_access_token: tuple[str, datetime]
    ) -> None:
        """Test that verify_token defaults to 'access' type."""
        token, _ = sample_access_token
        # Should work without specifying token_type
        user_id = verify_token(token)
        assert isinstance(user_id, UUID)

    def test_verify_token_wrong_type_raises_exception(
        self, sample_access_token: tuple[str, datetime]
    ) -> None:
        """Test that using wrong token type raises TokenInvalidException."""
        token, _ = sample_access_token  # This is an access token

        # Try to verify as refresh token (should fail)
        with pytest.raises(TokenInvalidException) as exc_info:
            verify_token(token, "refresh")

        assert "Invalid token type" in str(exc_info.value.detail)

    def test_verify_token_invalid_signature_raises_exception(
        self, sample_user_id: UUID
    ) -> None:
        """Test that token with invalid signature raises TokenInvalidException."""
        # Create a token with different secret
        fake_token = jwt.encode(
            {"sub": str(sample_user_id), "type": "access"},
            "wrong-secret-key",
            algorithm=settings.jwt_algorithm,
        )

        with pytest.raises(TokenInvalidException):
            verify_token(fake_token, "access")

    def test_verify_token_malformed_token_raises_exception(self) -> None:
        """Test that malformed token raises TokenInvalidException."""
        malformed_tokens = [
            "not-a-jwt-token",
            "invalid.jwt",
            "",
            "header.payload",  # Missing signature
        ]

        for token in malformed_tokens:
            with pytest.raises(TokenInvalidException):
                verify_token(token, "access")

    def test_verify_token_missing_subject_raises_exception(self) -> None:
        """Test that token without 'sub' claim raises TokenInvalidException."""
        # Create token without sub claim
        token = jwt.encode(
            {"type": "access", "exp": datetime.utcnow() + timedelta(minutes=30)},
            settings.jwt_secret_key,
            algorithm=settings.jwt_algorithm,
        )

        with pytest.raises(TokenInvalidException) as exc_info:
            verify_token(token, "access")

        assert "missing subject" in str(exc_info.value.detail).lower()

    def test_verify_token_invalid_uuid_raises_exception(self) -> None:
        """Test that token with invalid UUID format raises TokenInvalidException."""
        # Create token with invalid UUID
        token = jwt.encode(
            {
                "sub": "not-a-valid-uuid",
                "type": "access",
                "exp": datetime.utcnow() + timedelta(minutes=30),
            },
            settings.jwt_secret_key,
            algorithm=settings.jwt_algorithm,
        )

        with pytest.raises(TokenInvalidException) as exc_info:
            verify_token(token, "access")

        assert "invalid user id" in str(exc_info.value.detail).lower()

    def test_verify_expired_token_raises_exception(self, sample_user_id: UUID) -> None:
        """Test that expired token raises TokenExpiredException."""
        # Create a token that expired 1 hour ago
        expired_payload = {
            "sub": str(sample_user_id),
            "exp": datetime.utcnow() - timedelta(hours=1),
            "iat": datetime.utcnow() - timedelta(hours=2),
            "type": "access",
        }

        expired_token = jwt.encode(
            expired_payload,
            settings.jwt_secret_key,
            algorithm=settings.jwt_algorithm,
        )

        with pytest.raises(TokenExpiredException):
            verify_token(expired_token, "access")


# ============================================================================
# Token Extraction Tests
# ============================================================================


class TestTokenExtraction:
    """Tests for extracting tokens from HTTP headers."""

    def test_extract_token_from_valid_credentials(self) -> None:
        """Test extracting token from valid HTTPAuthorizationCredentials."""
        token = "test-token-123"
        credentials = HTTPAuthorizationCredentials(scheme="Bearer", credentials=token)

        extracted = extract_token_from_header(credentials)
        assert extracted == token

    def test_extract_token_from_none_raises_exception(self) -> None:
        """Test that None credentials raises TokenInvalidException."""
        with pytest.raises(TokenInvalidException) as exc_info:
            extract_token_from_header(None)

        assert "No authentication token" in str(exc_info.value.detail)


# ============================================================================
# Integration Tests
# ============================================================================


class TestTokenIntegration:
    """Integration tests for complete token lifecycle."""

    def test_full_token_lifecycle(self, sample_user_id: UUID) -> None:
        """Test complete lifecycle: create access token -> verify -> extract user_id."""
        # Step 1: Create access token
        access_token, expires_at = create_access_token(sample_user_id)
        assert isinstance(access_token, str)
        assert isinstance(expires_at, datetime)

        # Step 2: Verify token
        verified_user_id = verify_token(access_token, "access")
        assert verified_user_id == sample_user_id

        # Step 3: Simulate HTTP header extraction
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer", credentials=access_token
        )
        extracted_token = extract_token_from_header(credentials)
        assert extracted_token == access_token

        # Step 4: Verify extracted token
        final_user_id = verify_token(extracted_token, "access")
        assert final_user_id == sample_user_id

    def test_refresh_token_cannot_be_used_as_access_token(
        self, sample_user_id: UUID
    ) -> None:
        """Test that refresh token cannot be used as access token (confused deputy attack prevention)."""
        refresh_token, _ = create_refresh_token(sample_user_id)

        # Attempting to verify refresh token as access token should fail
        with pytest.raises(TokenInvalidException) as exc_info:
            verify_token(refresh_token, "access")

        assert "Invalid token type" in str(exc_info.value.detail)

    def test_access_token_cannot_be_used_as_refresh_token(
        self, sample_user_id: UUID
    ) -> None:
        """Test that access token cannot be used as refresh token."""
        access_token, _ = create_access_token(sample_user_id)

        # Attempting to verify access token as refresh token should fail
        with pytest.raises(TokenInvalidException) as exc_info:
            verify_token(access_token, "refresh")

        assert "Invalid token type" in str(exc_info.value.detail)

    def test_multiple_users_have_unique_tokens(self) -> None:
        """Test that different users get different tokens."""
        user1_id = uuid4()
        user2_id = uuid4()

        token1, _ = create_access_token(user1_id)
        token2, _ = create_access_token(user2_id)

        # Tokens should be different
        assert token1 != token2

        # Each token should verify to its own user
        assert verify_token(token1, "access") == user1_id
        assert verify_token(token2, "access") == user2_id


# ============================================================================
# Edge Case Tests
# ============================================================================


class TestTokenEdgeCases:
    """Tests for edge cases and unusual scenarios."""

    def test_token_with_special_characters_in_uuid(self) -> None:
        """Test that tokens work with all valid UUID formats."""
        # UUID with various formats
        user_id = uuid4()
        token, _ = create_access_token(user_id)
        verified_id = verify_token(token, "access")
        assert verified_id == user_id

    def test_token_verification_is_case_sensitive(self, sample_user_id: UUID) -> None:
        """Test that token verification is case-sensitive."""
        token, _ = create_access_token(sample_user_id)

        # Changing case should invalidate the token
        invalid_token = token.upper()
        with pytest.raises(TokenInvalidException):
            verify_token(invalid_token, "access")

    def test_token_survives_whitespace_stripping(self, sample_user_id: UUID) -> None:
        """Test that tokens work after stripping whitespace (common in HTTP headers)."""
        token, _ = create_access_token(sample_user_id)

        # Add whitespace (common in HTTP headers)
        token_with_whitespace = f"  {token}  "

        # Should work after stripping
        verified_id = verify_token(token_with_whitespace.strip(), "access")
        assert verified_id == sample_user_id
```

**Run the tests**:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_jwt_tokens.py -v
```

**Expected Output**: All tests should PASS (40+ tests)

---

### STEP 8: Run Tests with Coverage

Check code coverage for the new JWT functions:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_jwt_tokens.py --cov=src.core.security --cov-report=term-missing -v
```

**Expected**: Coverage should be near 100% for the new JWT functions

---

### STEP 9: Create Integration Verification Script

**File to Create**: `/Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend/scripts/verify_jwt_tokens.py`

```python
"""Verify JWT token generation and validation implementation."""

from datetime import datetime, timedelta
from uuid import uuid4

from src.config import settings
from src.core.exceptions import TokenExpiredException, TokenInvalidException
from src.core.security import (
    create_access_token,
    create_refresh_token,
    verify_token,
)


def verify_jwt_implementation():
    """Verify JWT token implementation."""
    print("=" * 70)
    print("JWT TOKEN IMPLEMENTATION VERIFICATION")
    print("=" * 70)
    print()

    # Check 1: Configuration
    print("1. JWT Configuration:")
    print(f"   • Secret Key: {settings.jwt_secret_key[:20]}... (first 20 chars)")
    print(f"   • Algorithm: {settings.jwt_algorithm}")
    print(f"   • Access Token Expiry: {settings.jwt_access_token_expire_minutes} minutes")
    print(f"   • Refresh Token Expiry: {settings.jwt_refresh_token_expire_days} days")
    print("   [PASS] Configuration loaded")
    print()

    # Check 2: Access Token Generation
    print("2. Access Token Generation:")
    user_id = uuid4()
    access_token, access_expires_at = create_access_token(user_id)
    print(f"   • Token Length: {len(access_token)} characters")
    print(f"   • Token Preview: {access_token[:50]}...")
    print(f"   • Expires At: {access_expires_at}")

    # Verify expiry is ~30 minutes from now
    expected_expiry = datetime.utcnow() + timedelta(
        minutes=settings.jwt_access_token_expire_minutes
    )
    expiry_diff = abs((access_expires_at - expected_expiry).total_seconds())
    assert expiry_diff < 5, f"Expiry time incorrect (diff: {expiry_diff}s)"
    print(f"   • Expiry Check: ✓ (~{settings.jwt_access_token_expire_minutes} min from now)")
    print("   [PASS] Access token generation works")
    print()

    # Check 3: Refresh Token Generation
    print("3. Refresh Token Generation:")
    refresh_token, refresh_expires_at = create_refresh_token(user_id)
    print(f"   • Token Length: {len(refresh_token)} characters")
    print(f"   • Token Preview: {refresh_token[:50]}...")
    print(f"   • Expires At: {refresh_expires_at}")

    # Verify expiry is ~30 days from now
    expected_expiry = datetime.utcnow() + timedelta(
        days=settings.jwt_refresh_token_expire_days
    )
    expiry_diff = abs((refresh_expires_at - expected_expiry).total_seconds())
    assert expiry_diff < 5, f"Expiry time incorrect (diff: {expiry_diff}s)"
    print(f"   • Expiry Check: ✓ (~{settings.jwt_refresh_token_expire_days} days from now)")
    print("   [PASS] Refresh token generation works")
    print()

    # Check 4: Access Token Verification
    print("4. Access Token Verification:")
    verified_user_id = verify_token(access_token, "access")
    print(f"   • Original User ID:  {user_id}")
    print(f"   • Verified User ID:  {verified_user_id}")
    assert verified_user_id == user_id, "User ID mismatch!"
    print("   • User ID Match: ✓")
    print("   [PASS] Access token verification works")
    print()

    # Check 5: Refresh Token Verification
    print("5. Refresh Token Verification:")
    verified_user_id = verify_token(refresh_token, "refresh")
    print(f"   • Original User ID:  {user_id}")
    print(f"   • Verified User ID:  {verified_user_id}")
    assert verified_user_id == user_id, "User ID mismatch!"
    print("   • User ID Match: ✓")
    print("   [PASS] Refresh token verification works")
    print()

    # Check 6: Token Type Validation
    print("6. Token Type Validation:")
    # Try to use refresh token as access token
    try:
        verify_token(refresh_token, "access")
        print("   [FAIL] Should have rejected refresh token used as access token")
        raise AssertionError("Token type validation failed")
    except TokenInvalidException as e:
        print(f"   • Refresh as Access: ✗ Rejected ({e.detail})")

    # Try to use access token as refresh token
    try:
        verify_token(access_token, "refresh")
        print("   [FAIL] Should have rejected access token used as refresh token")
        raise AssertionError("Token type validation failed")
    except TokenInvalidException as e:
        print(f"   • Access as Refresh: ✗ Rejected ({e.detail})")

    print("   [PASS] Token type validation works")
    print()

    # Check 7: Invalid Token Handling
    print("7. Invalid Token Handling:")
    invalid_tokens = [
        ("empty string", ""),
        ("malformed", "not-a-jwt-token"),
        ("invalid format", "header.payload"),
    ]

    for name, token in invalid_tokens:
        try:
            verify_token(token, "access")
            print(f"   • {name}: [FAIL] Should have raised exception")
            raise AssertionError(f"Invalid token not rejected: {name}")
        except TokenInvalidException:
            print(f"   • {name}: ✓ Rejected")

    print("   [PASS] Invalid tokens rejected")
    print()

    # Check 8: Token Uniqueness
    print("8. Token Uniqueness (Salt Generation):")
    token1, _ = create_access_token(user_id)
    token2, _ = create_access_token(user_id)
    print(f"   • Token 1: {token1[:30]}...")
    print(f"   • Token 2: {token2[:30]}...")
    assert token1 != token2, "Tokens should be unique!"
    print("   • Tokens Different: ✓")

    # Both should verify to same user
    assert verify_token(token1, "access") == user_id
    assert verify_token(token2, "access") == user_id
    print("   • Both Verify to Same User: ✓")
    print("   [PASS] Token uniqueness works")
    print()

    print("=" * 70)
    print("ALL JWT TOKEN CHECKS PASSED!")
    print("=" * 70)
    print()
    print("Implementation Summary:")
    print(f"  • Access Tokens: {settings.jwt_access_token_expire_minutes} min expiry")
    print(f"  • Refresh Tokens: {settings.jwt_refresh_token_expire_days} day expiry")
    print(f"  • Algorithm: {settings.jwt_algorithm}")
    print("  • Token Type Validation: ✓ Enabled")
    print("  • User ID Extraction: ✓ Working")
    print("  • Invalid Token Rejection: ✓ Working")
    print()


if __name__ == "__main__":
    verify_jwt_implementation()
```

**Run the verification script**:

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python scripts/verify_jwt_tokens.py
```

**Expected**: All checks should pass

---

## Validation Checklist

Use this checklist to verify the implementation is complete:

### Code Quality Checks
- [ ] JWT functions added to `src/core/security.py`
- [ ] All imports resolve correctly
- [ ] Type hints complete and accurate
- [ ] Docstrings follow Google style
- [ ] `__all__` export list updated
- [ ] No syntax errors (`python -m py_compile`)
- [ ] Type checking passes (`mypy`)

### Functionality Checks
- [ ] `create_access_token()` generates valid JWT
- [ ] Access tokens expire in 30 minutes (configurable)
- [ ] `create_refresh_token()` generates valid JWT
- [ ] Refresh tokens expire in 30 days (configurable)
- [ ] `verify_token()` extracts correct user_id
- [ ] Token type validation works (access vs refresh)
- [ ] Expired tokens raise `TokenExpiredException`
- [ ] Invalid tokens raise `TokenInvalidException`
- [ ] `extract_token_from_header()` extracts Bearer token
- [ ] Missing Authorization header raises exception

### Security Checks
- [ ] HS256 algorithm used
- [ ] Secret key from config (not hardcoded)
- [ ] Token type field prevents confused deputy attacks
- [ ] User ID properly extracted and validated as UUID
- [ ] Timestamps in UTC
- [ ] Expired tokens properly rejected
- [ ] Invalid signatures rejected
- [ ] Malformed tokens rejected

### Testing Checks
- [ ] Unit tests created (`test_jwt_tokens.py`)
- [ ] All tests pass (40+ tests)
- [ ] Test coverage near 100% for JWT functions
- [ ] Verification script passes
- [ ] Edge cases tested (expired, invalid, wrong type)

### Integration Checks
- [ ] Works with existing `hash_password()` function
- [ ] Custom exceptions properly raised
- [ ] Configuration settings used correctly
- [ ] Ready for FastAPI dependency injection
- [ ] Compatible with `RefreshToken` model

---

## Security Considerations

### Why JWT?

**Advantages**:
- **Stateless**: No database lookup for every API request (only for refresh token validation)
- **Self-contained**: Token contains all needed information (user_id)
- **Standard**: Industry-standard format (RFC 7519)
- **Portable**: Works across different services

**Disadvantages** (and mitigations):
- **Cannot revoke**: Access tokens can't be revoked before expiry
  - *Mitigation*: Short expiry (30 min), refresh tokens can be revoked in DB
- **Size**: Larger than session IDs
  - *Mitigation*: Minimal payload (only user_id and metadata)

### Why HS256 (not RS256)?

| Algorithm | Pros | Cons | Best For |
|-----------|------|------|----------|
| **HS256** (Symmetric) | Fast, simple, smaller tokens | Shared secret (single server) | Monolithic apps, trusted services |
| **RS256** (Asymmetric) | Public key verification, distributed | Slower, larger tokens, key management | Microservices, third-party verification |

**Decision**: HS256 is perfect for our use case (single backend server, no third-party verification needed).

### Token Expiry Strategy

| Token Type | Expiry | Storage | Revocable? | Use Case |
|------------|--------|---------|------------|----------|
| **Access Token** | 30 min | Client-side only | No | Every API request |
| **Refresh Token** | 30 days | Database + Client | Yes | Get new access token |

**Why 30 minutes for access tokens?**
- Long enough: User doesn't need to refresh during normal session
- Short enough: If stolen, attacker only has 30 min window
- Balances security and UX

**Why 30 days for refresh tokens?**
- Long enough: Mobile apps don't force login too often
- Short enough: Forces re-authentication monthly
- Can be revoked: Logout, password change, suspicious activity

### Token Type Validation

**Confused Deputy Attack Prevention**:

```python
# WITHOUT token type validation (VULNERABLE):
refresh_token = get_refresh_token()
# Attacker uses refresh token in Authorization header
# verify_token(refresh_token)  # Would succeed! Attacker bypasses short expiry

# WITH token type validation (SECURE):
verify_token(refresh_token, "access")  # Raises TokenInvalidException ✓
```

**Always specify token type** when calling `verify_token()`.

### Common JWT Attacks (and defenses)

| Attack | Description | Defense |
|--------|-------------|---------|
| **None Algorithm** | Set alg: "none" to bypass signature | python-jose validates algorithm |
| **Weak Secret** | Brute force the secret key | Use strong, random secret (change in production!) |
| **Token Replay** | Reuse stolen token | Short expiry + HTTPS only |
| **Confused Deputy** | Use refresh token as access token | Token type validation |
| **Token Sidejacking** | Steal token from HTTP | HTTPS only, secure cookies |

### Best Practices Implemented

1. **Strong Secret Key**: Must be changed in production (>= 32 bytes)
2. **Short Access Token Expiry**: 30 minutes limits damage window
3. **Refresh Token Revocation**: Database-backed for logout/password change
4. **Token Type Validation**: Prevents confused deputy attacks
5. **UTC Timestamps**: Avoids timezone issues
6. **UUID Validation**: Ensures user_id is valid UUID format
7. **Proper Exception Handling**: Distinguishes expired vs invalid tokens

---

## Common Pitfalls & Solutions

### Pitfall 1: Forgetting to Check Token Type

**Problem**:
```python
# WRONG: Doesn't specify token type
user_id = verify_token(token)  # Defaults to "access", but what if it's a refresh token?
```

**Solution**:
```python
# CORRECT: Always specify expected token type
user_id = verify_token(token, "access")  # For access tokens
user_id = verify_token(token, "refresh")  # For refresh tokens
```

### Pitfall 2: Not Storing Refresh Tokens in Database

**Problem**: Creating refresh tokens but not storing them means you can't revoke them.

**Solution**: After calling `create_refresh_token()`, ALWAYS store it in the database:
```python
refresh_token, expires_at = create_refresh_token(user_id)

# MUST store in database
refresh_token_record = RefreshToken(
    user_id=user_id,
    token=refresh_token,
    expires_at=expires_at,
)
db.add(refresh_token_record)
await db.commit()
```

### Pitfall 3: Using Weak Secret Key

**Problem**: Using default secret key in production.

**Solution**: Set environment variable:
```bash
export JWT_SECRET_KEY="$(openssl rand -hex 32)"
```

Or in `.env`:
```
JWT_SECRET_KEY=your-super-secret-random-key-here-at-least-32-bytes
```

### Pitfall 4: Timezone Issues

**Problem**: Using local time instead of UTC.

**Solution**: Always use `datetime.utcnow()` (already implemented in the code).

### Pitfall 5: Not Handling Expired Tokens

**Problem**: Treating expired tokens same as invalid tokens.

**Solution**: Catch `TokenExpiredException` separately:
```python
try:
    user_id = verify_token(token, "access")
except TokenExpiredException:
    # Tell client to refresh the token
    return {"error": "token_expired", "message": "Please refresh your token"}
except TokenInvalidException:
    # Tell client to login again
    return {"error": "invalid_token", "message": "Please login again"}
```

### Pitfall 6: Logging Tokens

**Problem**: Logging full tokens exposes them.

**Solution**: Never log full tokens, only prefixes:
```python
# WRONG
logger.info(f"Token: {token}")

# CORRECT
logger.info(f"Token: {token[:20]}... (truncated)")
```

### Pitfall 7: Not Validating UUID Format

**Problem**: Assuming "sub" claim is always valid UUID.

**Solution**: Already handled in `verify_token()`:
```python
try:
    user_id = UUID(user_id_str)
except (ValueError, TypeError):
    raise TokenInvalidException(detail="Invalid user ID format")
```

---

## Integration Points

### With Password Hashing (Task 03.01)

```python
from src.core.security import hash_password, verify_password, create_access_token, create_refresh_token

# Registration
password_hash = hash_password(plain_password)
user = User(email=email, password_hash=password_hash)
# ... save user ...

# Login
if verify_password(plain_password, user.password_hash):
    access_token, _ = create_access_token(user.id)
    refresh_token, expires_at = create_refresh_token(user.id)
    # ... store refresh token in DB ...
    return {"access_token": access_token, "refresh_token": refresh_token}
```

### With FastAPI Endpoints (Future Task 03.03)

```python
from fastapi import Depends
from fastapi.security import HTTPAuthorizationCredentials
from src.core.security import security_scheme, extract_token_from_header, verify_token

@app.get("/api/v1/users/me")
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security_scheme)
):
    # Extract token
    token = extract_token_from_header(credentials)

    # Verify token and get user_id
    user_id = verify_token(token, "access")

    # Fetch user from database
    user = await user_repository.get(user_id)

    return user
```

### With RefreshToken Model (Task 02)

```python
from src.db.models import RefreshToken

# Store refresh token
async def store_refresh_token(user_id: UUID, token: str, expires_at: datetime):
    refresh_token = RefreshToken(
        user_id=user_id,
        token=token,
        expires_at=expires_at,
    )
    db.add(refresh_token)
    await db.commit()

# Validate refresh token
async def validate_refresh_token(token: str) -> UUID:
    # Step 1: Cryptographic validation
    user_id = verify_token(token, "refresh")

    # Step 2: Database validation (not revoked)
    db_token = await refresh_token_repository.get_by_token(token)
    if not db_token or db_token.expires_at < datetime.utcnow():
        raise TokenInvalidException(detail="Refresh token revoked or expired")

    return user_id
```

---

## Next Steps

### After Completing This Task

1. **Run all tests**:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/test_jwt_tokens.py -v
   ```

2. **Run verification script**:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python scripts/verify_jwt_tokens.py
   ```

3. **Update progress tracking**:
   - Mark Subtask 03.02 as COMPLETED in `.claude/01-MVP/backend/Backend-Tasks-Progress.md`

4. **Proceed to Subtask 03.03**: Implement authentication endpoints
   - `/api/v1/auth/register` - User registration
   - `/api/v1/auth/login` - User login (uses these JWT functions!)
   - `/api/v1/auth/refresh` - Token refresh (uses these JWT functions!)
   - `/api/v1/auth/logout` - Logout (revokes refresh token)

### Optional: Commit Changes

```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend

git add src/core/security.py tests/unit/test_jwt_tokens.py scripts/verify_jwt_tokens.py

git commit -m "feat(auth): Implement JWT token generation and validation

- Add create_access_token() with 30-minute expiry
- Add create_refresh_token() with 30-day expiry
- Add verify_token() with type validation
- Add extract_token_from_header() for FastAPI
- Implement token type validation (access vs refresh)
- Handle expired tokens (TokenExpiredException)
- Handle invalid tokens (TokenInvalidException)
- Add comprehensive unit tests (40+ tests, 100% coverage)
- Add JWT verification script

Related to: Task 03.02 (JWT Token Management)"
```

---

## Quick Reference

### Key Functions

```python
from src.core.security import (
    create_access_token,
    create_refresh_token,
    verify_token,
    extract_token_from_header,
)

# Generate access token (30 min expiry)
access_token, expires_at = create_access_token(user_id)

# Generate refresh token (30 day expiry)
refresh_token, expires_at = create_refresh_token(user_id)

# Verify access token
user_id = verify_token(access_token, "access")

# Verify refresh token
user_id = verify_token(refresh_token, "refresh")

# Extract from HTTP header (in FastAPI endpoint)
token = extract_token_from_header(credentials)
```

### Key Configuration

```python
from src.config import settings

settings.jwt_secret_key                  # Secret key for signing
settings.jwt_algorithm                   # "HS256"
settings.jwt_access_token_expire_minutes # 30 (minutes)
settings.jwt_refresh_token_expire_days   # 30 (days)
```

### Key Exceptions

```python
from src.core.exceptions import TokenExpiredException, TokenInvalidException

try:
    user_id = verify_token(token, "access")
except TokenExpiredException:
    # Token has expired (401)
    # Client should refresh the token
    pass
except TokenInvalidException:
    # Token is invalid (401)
    # Client should login again
    pass
```

---

**Implementation Complete!**

Once all validation checks pass, this subtask is ready to be marked as COMPLETED. JWT token management is now in place and ready to be integrated into the authentication endpoints.
