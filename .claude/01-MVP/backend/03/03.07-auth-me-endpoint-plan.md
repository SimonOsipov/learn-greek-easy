# Backend Task 03.07: /auth/me Endpoint (Get Current User) - Technical Implementation Plan

**Created**: 2025-11-29
**Status**: ✅ COMPLETED (2025-11-29)
**Actual Duration**: 45 minutes
**Type**: Architecture Documentation & Implementation Plan
**Priority**: Critical

**Completion Summary**:
- Created `src/core/dependencies.py` with `get_current_user`, `get_current_superuser`, `get_current_user_optional`
- Added `GET /api/v1/auth/me` endpoint to auth router
- Updated `src/core/__init__.py` with exports
- 21 unit tests written and passing (100% coverage)
- Verification script created: scripts/verify_auth_me.py
- QA Report: [../../qa/task-03.07-verification.md](../../qa/task-03.07-verification.md)
- Verdict: **READY FOR PRODUCTION**

---

## 1. Overview

### 1.1 Task Description
Implement a `/auth/me` endpoint that returns the currently authenticated user's profile information. This is a foundational endpoint that:
- Validates JWT access tokens
- Returns user profile with settings
- Serves as the basis for all protected endpoints

### 1.2 Objectives
- Create reusable authentication dependency (`get_current_user`)
- Implement `GET /api/v1/auth/me` endpoint
- Return user profile with embedded settings
- Handle authentication errors gracefully
- Provide foundation for protecting other endpoints

### 1.3 Dependencies
- ✅ Task 03.01: Password hashing (bcrypt)
- ✅ Task 03.02: JWT token management (`verify_token()`)
- ✅ Task 03.03: User registration endpoint
- ✅ Task 03.04: Login endpoint (generates tokens)
- ✅ Task 03.05: Token refresh endpoint
- ✅ Database models: User, UserSettings
- ✅ Pydantic schemas: UserProfileResponse, UserSettingsResponse
- ✅ Exceptions: UnauthorizedException, UserNotFoundException

---

## 2. Architecture & Data Flow

### 2.1 Authentication Flow

```mermaid
sequenceDiagram
    participant Client
    participant API as API Endpoint
    participant Dep as get_current_user
    participant Security as Security Module
    participant DB as Database

    Client->>API: GET /api/v1/auth/me
    Note over Client: Authorization: Bearer <access_token>

    API->>Dep: Depends(get_current_user)

    Dep->>Dep: Extract token from header

    alt No Token Provided
        Dep-->>API: UnauthorizedException
        API-->>Client: 401 Unauthorized
    end

    Dep->>Security: verify_token(token, "access")

    alt Token Invalid/Expired
        Security-->>Dep: TokenInvalidException
        Dep-->>API: UnauthorizedException
        API-->>Client: 401 Unauthorized
    end

    Security-->>Dep: user_id (UUID)

    Dep->>DB: SELECT User WHERE id=? WITH settings
    DB-->>Dep: User object or None

    alt User Not Found
        Dep-->>API: UserNotFoundException
        API-->>Client: 404 Not Found
    end

    alt User Inactive
        Dep-->>API: UnauthorizedException
        API-->>Client: 401 Unauthorized
    end

    Dep-->>API: User object
    API-->>Client: 200 OK with UserProfileResponse
```

### 2.2 Component Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    GET /api/v1/auth/me Flow                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐    ┌──────────────┐    ┌─────────────────┐    │
│  │   Client    │───▶│  API Router  │───▶│ get_current_user│    │
│  │  (Frontend) │    │  (FastAPI)   │    │   Dependency    │    │
│  └─────────────┘    └──────────────┘    └─────────────────┘    │
│        │                   │                     │              │
│        │                   │                     ▼              │
│        │                   │            ┌─────────────────┐    │
│        │                   │            │ Security Module │    │
│        │                   │            │ - verify_token  │    │
│        │                   │            │ - extract_token │    │
│        │                   │            └─────────────────┘    │
│        │                   │                     │              │
│        │                   ▼                     ▼              │
│        │           ┌──────────────────────────────────┐        │
│        │           │           PostgreSQL              │        │
│        │           │  - users table                    │        │
│        │           │  - user_settings table            │        │
│        │           └──────────────────────────────────┘        │
│        │                                                        │
│        ▼                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  UserProfileResponse                     │   │
│  │  {                                                       │   │
│  │    "id": "uuid",                                        │   │
│  │    "email": "user@example.com",                         │   │
│  │    "full_name": "John Doe",                             │   │
│  │    "is_active": true,                                   │   │
│  │    "is_superuser": false,                               │   │
│  │    "settings": {                                        │   │
│  │      "daily_goal": 20,                                  │   │
│  │      "email_notifications": true                        │   │
│  │    }                                                    │   │
│  │  }                                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 Dependency Injection Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│              FastAPI Dependency Injection Chain                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Request                                                         │
│     │                                                            │
│     ▼                                                            │
│  ┌─────────────────────────────────────┐                        │
│  │      HTTPBearer (security_scheme)    │                        │
│  │  - Extracts Authorization header     │                        │
│  │  - Returns HTTPAuthorizationCreds    │                        │
│  └─────────────────┬───────────────────┘                        │
│                    │                                             │
│                    ▼                                             │
│  ┌─────────────────────────────────────┐                        │
│  │           get_db()                   │                        │
│  │  - Provides AsyncSession             │                        │
│  │  - Auto-commit on success            │                        │
│  └─────────────────┬───────────────────┘                        │
│                    │                                             │
│                    ▼                                             │
│  ┌─────────────────────────────────────┐                        │
│  │        get_current_user()            │ ◄── NEW DEPENDENCY    │
│  │  - Combines credentials + db         │                        │
│  │  - Verifies token                    │                        │
│  │  - Loads user from database          │                        │
│  │  - Validates user is active          │                        │
│  │  - Returns User model                │                        │
│  └─────────────────┬───────────────────┘                        │
│                    │                                             │
│                    ▼                                             │
│  ┌─────────────────────────────────────┐                        │
│  │     get_current_superuser()          │ ◄── NEW DEPENDENCY    │
│  │  - Depends on get_current_user       │                        │
│  │  - Validates is_superuser=True       │                        │
│  │  - For admin-only endpoints          │                        │
│  └─────────────────────────────────────┘                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Implementation Details

### 3.1 File Structure

```
src/
├── core/
│   ├── __init__.py
│   ├── dependencies.py          # NEW - Authentication dependencies
│   ├── exceptions.py            # EXISTS - Has UnauthorizedException
│   └── security.py              # EXISTS - Has verify_token()
├── api/
│   └── v1/
│       └── auth.py              # UPDATE - Add /me endpoint
└── schemas/
    └── user.py                  # EXISTS - Has UserProfileResponse
```

### 3.2 Authentication Dependencies

```python
# File: src/core/dependencies.py (NEW FILE)

"""
FastAPI dependencies for authentication and authorization.

This module provides reusable dependencies for authenticating users
and authorizing access to protected endpoints.

Usage:
    from src.core.dependencies import get_current_user, get_current_superuser

    @router.get("/protected")
    async def protected_endpoint(
        current_user: User = Depends(get_current_user)
    ):
        return {"user_id": current_user.id}

    @router.get("/admin-only")
    async def admin_endpoint(
        admin_user: User = Depends(get_current_superuser)
    ):
        return {"admin_id": admin_user.id}
"""

from typing import Optional
from uuid import UUID

from fastapi import Depends
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.core.exceptions import (
    ForbiddenException,
    TokenExpiredException,
    TokenInvalidException,
    UnauthorizedException,
    UserNotFoundException,
)
from src.core.security import verify_token
from src.db.dependencies import get_db
from src.db.models import User

# Security scheme for Swagger UI
# auto_error=False allows us to handle missing tokens ourselves
security_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security_scheme),
    db: AsyncSession = Depends(get_db),
) -> User:
    """
    Get the current authenticated user from JWT access token.

    This dependency:
    1. Extracts the Bearer token from Authorization header
    2. Verifies the JWT signature and expiration
    3. Loads the user from database with settings
    4. Validates the user exists and is active

    Args:
        credentials: Bearer token from Authorization header (auto-extracted)
        db: Database session (auto-injected)

    Returns:
        User: The authenticated user model with settings loaded

    Raises:
        UnauthorizedException: If token is missing, invalid, or expired
        UserNotFoundException: If user no longer exists in database

    Example:
        ```python
        @router.get("/profile")
        async def get_profile(
            user: User = Depends(get_current_user)
        ):
            return {"email": user.email}
        ```
    """
    # Step 1: Check if credentials provided
    if not credentials:
        raise UnauthorizedException(
            detail="Authentication required. Please provide a valid access token.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Step 2: Extract token string
    token = credentials.credentials

    # Step 3: Verify JWT and extract user_id
    try:
        user_id = verify_token(token, token_type="access")
    except TokenExpiredException:
        raise UnauthorizedException(
            detail="Access token has expired. Please refresh your token.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except TokenInvalidException as e:
        raise UnauthorizedException(
            detail=f"Invalid access token: {e.detail}",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Step 4: Load user from database with settings
    result = await db.execute(
        select(User)
        .where(User.id == user_id)
        .options(selectinload(User.settings))
    )
    user = result.scalar_one_or_none()

    # Step 5: Validate user exists
    if not user:
        raise UserNotFoundException(user_id=str(user_id))

    # Step 6: Validate user is active
    if not user.is_active:
        raise UnauthorizedException(
            detail="User account is deactivated.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user


async def get_current_superuser(
    current_user: User = Depends(get_current_user),
) -> User:
    """
    Get the current authenticated superuser.

    This dependency builds on get_current_user and adds superuser validation.
    Use this for admin-only endpoints.

    Args:
        current_user: User from get_current_user dependency

    Returns:
        User: The authenticated superuser model

    Raises:
        ForbiddenException: If user is not a superuser

    Example:
        ```python
        @router.delete("/admin/users/{user_id}")
        async def delete_user(
            user_id: UUID,
            admin: User = Depends(get_current_superuser)
        ):
            # Only superusers can reach this code
            ...
        ```
    """
    if not current_user.is_superuser:
        raise ForbiddenException(
            detail="Superuser privileges required for this action."
        )

    return current_user


async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security_scheme),
    db: AsyncSession = Depends(get_db),
) -> Optional[User]:
    """
    Optionally get the current user if a valid token is provided.

    Unlike get_current_user, this dependency does NOT raise an error
    if no token is provided. Useful for endpoints that behave differently
    for authenticated vs anonymous users.

    Args:
        credentials: Bearer token from Authorization header (optional)
        db: Database session

    Returns:
        User | None: The authenticated user, or None if not authenticated

    Example:
        ```python
        @router.get("/decks")
        async def list_decks(
            user: Optional[User] = Depends(get_current_user_optional)
        ):
            if user:
                # Return personalized deck list with progress
                return get_decks_with_progress(user.id)
            else:
                # Return public deck list
                return get_public_decks()
        ```
    """
    if not credentials:
        return None

    try:
        return await get_current_user(credentials, db)
    except (UnauthorizedException, UserNotFoundException):
        return None
```

### 3.3 API Endpoint Implementation

```python
# File: src/api/v1/auth.py (UPDATE - add to existing router)

# Add imports at top of file
from src.core.dependencies import get_current_user

# Add endpoint after existing endpoints

@router.get(
    "/me",
    response_model=UserProfileResponse,
    summary="Get current user profile",
    description="Returns the authenticated user's profile with settings. "
                "Requires a valid JWT access token in the Authorization header.",
    responses={
        200: {
            "description": "Successfully retrieved user profile",
            "content": {
                "application/json": {
                    "example": {
                        "id": "123e4567-e89b-12d3-a456-426614174000",
                        "email": "user@example.com",
                        "full_name": "John Doe",
                        "is_active": True,
                        "is_superuser": False,
                        "email_verified_at": None,
                        "created_at": "2025-11-29T10:00:00Z",
                        "updated_at": "2025-11-29T10:00:00Z",
                        "settings": {
                            "id": "456e7890-e12b-34d5-a678-901234567890",
                            "user_id": "123e4567-e89b-12d3-a456-426614174000",
                            "daily_goal": 20,
                            "email_notifications": True,
                            "created_at": "2025-11-29T10:00:00Z",
                            "updated_at": "2025-11-29T10:00:00Z"
                        }
                    }
                }
            }
        },
        401: {
            "description": "Authentication failed",
            "content": {
                "application/json": {
                    "examples": {
                        "no_token": {
                            "summary": "No token provided",
                            "value": {
                                "detail": "Authentication required. Please provide a valid access token."
                            }
                        },
                        "expired_token": {
                            "summary": "Token expired",
                            "value": {
                                "detail": "Access token has expired. Please refresh your token."
                            }
                        },
                        "invalid_token": {
                            "summary": "Invalid token",
                            "value": {
                                "detail": "Invalid access token: Invalid signature"
                            }
                        },
                        "inactive_user": {
                            "summary": "User deactivated",
                            "value": {
                                "detail": "User account is deactivated."
                            }
                        }
                    }
                }
            }
        },
        404: {
            "description": "User not found (deleted after token issued)",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "User with ID '123e4567-e89b-12d3-a456-426614174000' not found"
                    }
                }
            }
        }
    },
)
async def get_me(
    current_user: User = Depends(get_current_user),
) -> UserProfileResponse:
    """
    Get the current authenticated user's profile.

    This endpoint returns the user's profile information including their
    settings. It requires a valid JWT access token in the Authorization header.

    **Authentication:**
    - Include `Authorization: Bearer <access_token>` header
    - Token must be a valid, non-expired access token
    - User must be active (not deactivated)

    **Response:**
    Returns the user's profile with embedded settings including:
    - Basic info: id, email, full_name
    - Account status: is_active, is_superuser, email_verified_at
    - Timestamps: created_at, updated_at
    - Settings: daily_goal, email_notifications

    **Error Handling:**
    - 401 Unauthorized: Missing, invalid, or expired token
    - 404 Not Found: User was deleted after token was issued
    """
    return UserProfileResponse.model_validate(current_user)
```

### 3.4 Update Core Exports

```python
# File: src/core/__init__.py (UPDATE)

from src.core.dependencies import (
    get_current_user,
    get_current_superuser,
    get_current_user_optional,
)
from src.core.exceptions import (
    # ... existing exports
)
from src.core.security import (
    # ... existing exports
)

__all__ = [
    # Dependencies
    "get_current_user",
    "get_current_superuser",
    "get_current_user_optional",
    # ... existing exports
]
```

---

## 4. Security Implementation

### 4.1 Authentication Layers

| Layer | Component | Validation |
|-------|-----------|------------|
| 1. Header | HTTPBearer | Authorization header present |
| 2. Format | credentials.credentials | Bearer token extracted |
| 3. Signature | verify_token() | JWT signature valid (HS256) |
| 4. Expiration | verify_token() | Token not expired |
| 5. Type | verify_token() | Token type is "access" |
| 6. Database | SELECT User | User exists in database |
| 7. Status | user.is_active | User account is active |

### 4.2 Error Response Strategy

| Scenario | HTTP Code | Error Message | Security Rationale |
|----------|-----------|---------------|-------------------|
| No token | 401 | "Authentication required" | Clear instruction |
| Invalid format | 401 | "Invalid access token" | Don't reveal details |
| Expired token | 401 | "Access token has expired" | Prompt refresh |
| Wrong type | 401 | "Invalid token type" | Prevent refresh token misuse |
| User deleted | 404 | "User not found" | User no longer exists |
| User inactive | 401 | "Account deactivated" | Blocked account |

### 4.3 Token Security

```
┌─────────────────────────────────────────────────────────────────┐
│                     Access Token Security                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Access Token (30 min lifetime):                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ Header: {"alg": "HS256", "typ": "JWT"}                    │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │ Payload: {                                                 │  │
│  │   "sub": "user-uuid",     // User ID                      │  │
│  │   "type": "access",       // Token type (prevents misuse) │  │
│  │   "exp": 1735489200,      // Expiration timestamp         │  │
│  │   "iat": 1735487400       // Issued at timestamp          │  │
│  │ }                                                          │  │
│  ├───────────────────────────────────────────────────────────┤  │
│  │ Signature: HMACSHA256(header + payload, secret)           │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  Security Features:                                              │
│  ✓ Short lifetime (30 min) - limits damage from stolen tokens   │
│  ✓ Token type validation - prevents refresh token misuse        │
│  ✓ Stateless verification - no DB lookup for validation         │
│  ✓ HS256 signature - cryptographic integrity                    │
│  ✓ User lookup on use - catches deleted/deactivated users       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. Testing Strategy

### 5.1 Unit Tests

```python
# File: tests/unit/core/test_dependencies.py (NEW FILE)

"""Unit tests for authentication dependencies."""

import pytest
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch
from uuid import uuid4

from fastapi.security import HTTPAuthorizationCredentials

from src.core.dependencies import (
    get_current_user,
    get_current_superuser,
    get_current_user_optional,
)
from src.core.exceptions import (
    ForbiddenException,
    TokenExpiredException,
    TokenInvalidException,
    UnauthorizedException,
    UserNotFoundException,
)


class TestGetCurrentUser:
    """Tests for get_current_user dependency."""

    @pytest.fixture
    def mock_db(self):
        """Create mock database session."""
        db = AsyncMock()
        db.execute = AsyncMock()
        return db

    @pytest.fixture
    def valid_credentials(self):
        """Create valid credentials."""
        return HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials="valid.jwt.token"
        )

    @pytest.fixture
    def active_user(self):
        """Create an active user mock."""
        user = MagicMock()
        user.id = uuid4()
        user.email = "test@example.com"
        user.is_active = True
        user.is_superuser = False
        user.settings = MagicMock()
        return user

    async def test_success_returns_user(
        self, mock_db, valid_credentials, active_user
    ):
        """Test successful authentication returns user."""
        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.return_value = active_user.id
            mock_db.execute.return_value = MagicMock(
                scalar_one_or_none=lambda: active_user
            )

            result = await get_current_user(valid_credentials, mock_db)

            assert result == active_user
            mock_verify.assert_called_once_with(
                "valid.jwt.token", token_type="access"
            )

    async def test_no_credentials_raises_unauthorized(self, mock_db):
        """Test missing credentials raises UnauthorizedException."""
        with pytest.raises(UnauthorizedException) as exc_info:
            await get_current_user(None, mock_db)

        assert "Authentication required" in str(exc_info.value.detail)

    async def test_expired_token_raises_unauthorized(
        self, mock_db, valid_credentials
    ):
        """Test expired token raises UnauthorizedException."""
        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.side_effect = TokenExpiredException()

            with pytest.raises(UnauthorizedException) as exc_info:
                await get_current_user(valid_credentials, mock_db)

            assert "expired" in str(exc_info.value.detail).lower()

    async def test_invalid_token_raises_unauthorized(
        self, mock_db, valid_credentials
    ):
        """Test invalid token raises UnauthorizedException."""
        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.side_effect = TokenInvalidException(
                detail="Invalid signature"
            )

            with pytest.raises(UnauthorizedException) as exc_info:
                await get_current_user(valid_credentials, mock_db)

            assert "Invalid" in str(exc_info.value.detail)

    async def test_user_not_found_raises_not_found(
        self, mock_db, valid_credentials
    ):
        """Test deleted user raises UserNotFoundException."""
        user_id = uuid4()
        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.return_value = user_id
            mock_db.execute.return_value = MagicMock(
                scalar_one_or_none=lambda: None
            )

            with pytest.raises(UserNotFoundException):
                await get_current_user(valid_credentials, mock_db)

    async def test_inactive_user_raises_unauthorized(
        self, mock_db, valid_credentials, active_user
    ):
        """Test inactive user raises UnauthorizedException."""
        active_user.is_active = False

        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.return_value = active_user.id
            mock_db.execute.return_value = MagicMock(
                scalar_one_or_none=lambda: active_user
            )

            with pytest.raises(UnauthorizedException) as exc_info:
                await get_current_user(valid_credentials, mock_db)

            assert "deactivated" in str(exc_info.value.detail).lower()

    async def test_loads_user_with_settings(
        self, mock_db, valid_credentials, active_user
    ):
        """Test user is loaded with settings via selectinload."""
        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.return_value = active_user.id
            mock_db.execute.return_value = MagicMock(
                scalar_one_or_none=lambda: active_user
            )

            result = await get_current_user(valid_credentials, mock_db)

            # Verify execute was called (selectinload is part of query)
            mock_db.execute.assert_called_once()
            assert result.settings is not None


class TestGetCurrentSuperuser:
    """Tests for get_current_superuser dependency."""

    @pytest.fixture
    def superuser(self):
        """Create a superuser mock."""
        user = MagicMock()
        user.id = uuid4()
        user.is_superuser = True
        return user

    @pytest.fixture
    def regular_user(self):
        """Create a regular user mock."""
        user = MagicMock()
        user.id = uuid4()
        user.is_superuser = False
        return user

    async def test_superuser_returns_user(self, superuser):
        """Test superuser is returned successfully."""
        result = await get_current_superuser(superuser)
        assert result == superuser

    async def test_regular_user_raises_forbidden(self, regular_user):
        """Test regular user raises ForbiddenException."""
        with pytest.raises(ForbiddenException) as exc_info:
            await get_current_superuser(regular_user)

        assert "Superuser" in str(exc_info.value.detail)


class TestGetCurrentUserOptional:
    """Tests for get_current_user_optional dependency."""

    @pytest.fixture
    def mock_db(self):
        """Create mock database session."""
        db = AsyncMock()
        db.execute = AsyncMock()
        return db

    async def test_no_credentials_returns_none(self, mock_db):
        """Test missing credentials returns None (not error)."""
        result = await get_current_user_optional(None, mock_db)
        assert result is None

    async def test_valid_credentials_returns_user(self, mock_db):
        """Test valid credentials returns user."""
        user = MagicMock()
        user.id = uuid4()
        user.is_active = True

        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials="valid.token"
        )

        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.return_value = user.id
            mock_db.execute.return_value = MagicMock(
                scalar_one_or_none=lambda: user
            )

            result = await get_current_user_optional(credentials, mock_db)

            assert result == user

    async def test_invalid_token_returns_none(self, mock_db):
        """Test invalid token returns None (not error)."""
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials="invalid.token"
        )

        with patch('src.core.dependencies.verify_token') as mock_verify:
            mock_verify.side_effect = TokenInvalidException(detail="Invalid")

            result = await get_current_user_optional(credentials, mock_db)

            assert result is None
```

### 5.2 Integration Tests

```python
# File: tests/integration/api/test_auth_me.py (NEW FILE)

"""Integration tests for GET /api/v1/auth/me endpoint."""

import pytest
from httpx import AsyncClient


@pytest.mark.asyncio
class TestAuthMeEndpoint:
    """Integration tests for /auth/me endpoint."""

    async def test_me_success(
        self,
        client: AsyncClient,
        registered_user: dict,
    ):
        """Test successful profile retrieval."""
        # Login to get access token
        login_response = await client.post(
            "/api/v1/auth/login",
            json={
                "email": registered_user["email"],
                "password": registered_user["password"],
            }
        )
        assert login_response.status_code == 200
        access_token = login_response.json()["access_token"]

        # Get profile
        me_response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {access_token}"}
        )

        assert me_response.status_code == 200
        profile = me_response.json()

        # Verify response structure
        assert "id" in profile
        assert profile["email"] == registered_user["email"]
        assert "full_name" in profile
        assert "is_active" in profile
        assert profile["is_active"] is True
        assert "is_superuser" in profile
        assert "settings" in profile

        # Verify settings structure
        settings = profile["settings"]
        assert "daily_goal" in settings
        assert "email_notifications" in settings

    async def test_me_no_token(self, client: AsyncClient):
        """Test /me without token returns 401."""
        response = await client.get("/api/v1/auth/me")

        assert response.status_code == 401
        assert "Authentication required" in response.json()["detail"]

    async def test_me_invalid_token(self, client: AsyncClient):
        """Test /me with invalid token returns 401."""
        response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": "Bearer invalid.token.here"}
        )

        assert response.status_code == 401

    async def test_me_expired_token(
        self,
        client: AsyncClient,
        expired_access_token: str,
    ):
        """Test /me with expired token returns 401."""
        response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {expired_access_token}"}
        )

        assert response.status_code == 401
        assert "expired" in response.json()["detail"].lower()

    async def test_me_refresh_token_rejected(
        self,
        client: AsyncClient,
        registered_user: dict,
    ):
        """Test /me rejects refresh token (wrong type)."""
        # Login to get tokens
        login_response = await client.post(
            "/api/v1/auth/login",
            json={
                "email": registered_user["email"],
                "password": registered_user["password"],
            }
        )
        refresh_token = login_response.json()["refresh_token"]

        # Try to use refresh token for /me
        response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {refresh_token}"}
        )

        assert response.status_code == 401
        assert "type" in response.json()["detail"].lower()

    async def test_me_after_token_refresh(
        self,
        client: AsyncClient,
        registered_user: dict,
    ):
        """Test /me works with refreshed access token."""
        # Login
        login_response = await client.post(
            "/api/v1/auth/login",
            json={
                "email": registered_user["email"],
                "password": registered_user["password"],
            }
        )
        tokens = login_response.json()

        # Refresh tokens
        refresh_response = await client.post(
            "/api/v1/auth/refresh",
            json={"refresh_token": tokens["refresh_token"]}
        )
        new_access_token = refresh_response.json()["access_token"]

        # Use new access token for /me
        me_response = await client.get(
            "/api/v1/auth/me",
            headers={"Authorization": f"Bearer {new_access_token}"}
        )

        assert me_response.status_code == 200
        assert me_response.json()["email"] == registered_user["email"]
```

### 5.3 Test Coverage Goals

| Component | Target Coverage | Key Scenarios |
|-----------|----------------|---------------|
| get_current_user | 100% | All auth paths |
| get_current_superuser | 100% | Superuser validation |
| get_current_user_optional | 100% | Optional auth |
| /me endpoint | 95% | All HTTP codes |

---

## 6. API Documentation

### 6.1 Endpoint Specification

**Endpoint**: `GET /api/v1/auth/me`

**Request Headers**:
```
Authorization: Bearer <access_token>
```

**Success Response** (200 OK):
```json
{
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "email": "user@example.com",
    "full_name": "John Doe",
    "is_active": true,
    "is_superuser": false,
    "email_verified_at": null,
    "created_at": "2025-11-29T10:00:00Z",
    "updated_at": "2025-11-29T10:00:00Z",
    "settings": {
        "id": "456e7890-e12b-34d5-a678-901234567890",
        "user_id": "123e4567-e89b-12d3-a456-426614174000",
        "daily_goal": 20,
        "email_notifications": true,
        "created_at": "2025-11-29T10:00:00Z",
        "updated_at": "2025-11-29T10:00:00Z"
    }
}
```

**Error Response** (401 Unauthorized):
```json
{
    "detail": "Access token has expired. Please refresh your token."
}
```

**Error Response** (404 Not Found):
```json
{
    "detail": "User with ID '123e4567-e89b-12d3-a456-426614174000' not found"
}
```

### 6.2 cURL Examples

```bash
# Successful request
curl -X GET "http://localhost:8000/api/v1/auth/me" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Response: 200 OK with user profile

# No token
curl -X GET "http://localhost:8000/api/v1/auth/me"

# Response: 401 Unauthorized
# {"detail": "Authentication required. Please provide a valid access token."}

# Invalid token
curl -X GET "http://localhost:8000/api/v1/auth/me" \
  -H "Authorization: Bearer invalid.token"

# Response: 401 Unauthorized
# {"detail": "Invalid access token: Invalid signature"}
```

---

## 7. Frontend Integration Guide

### 7.1 TypeScript Interface

```typescript
interface UserSettings {
    id: string;
    user_id: string;
    daily_goal: number;
    email_notifications: boolean;
    created_at: string;
    updated_at: string;
}

interface UserProfile {
    id: string;
    email: string;
    full_name: string | null;
    is_active: boolean;
    is_superuser: boolean;
    email_verified_at: string | null;
    created_at: string;
    updated_at: string;
    settings: UserSettings;
}
```

### 7.2 React Hook Example

```typescript
// hooks/useCurrentUser.ts

import { useQuery } from '@tanstack/react-query';

const fetchCurrentUser = async (): Promise<UserProfile> => {
    const token = localStorage.getItem('access_token');

    if (!token) {
        throw new Error('NO_TOKEN');
    }

    const response = await fetch('/api/v1/auth/me', {
        headers: {
            'Authorization': `Bearer ${token}`,
        },
    });

    if (response.status === 401) {
        // Token expired or invalid - trigger refresh or logout
        throw new Error('UNAUTHORIZED');
    }

    if (!response.ok) {
        throw new Error('FETCH_FAILED');
    }

    return response.json();
};

export const useCurrentUser = () => {
    return useQuery({
        queryKey: ['currentUser'],
        queryFn: fetchCurrentUser,
        retry: (failureCount, error) => {
            // Don't retry auth errors
            if (error.message === 'UNAUTHORIZED' || error.message === 'NO_TOKEN') {
                return false;
            }
            return failureCount < 3;
        },
        staleTime: 5 * 60 * 1000, // 5 minutes
    });
};
```

### 7.3 Auth Context Integration

```typescript
// contexts/AuthContext.tsx

import { createContext, useContext, useEffect } from 'react';
import { useCurrentUser } from '../hooks/useCurrentUser';

interface AuthContextType {
    user: UserProfile | null;
    isLoading: boolean;
    isAuthenticated: boolean;
    refetch: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { data: user, isLoading, refetch, error } = useCurrentUser();

    // Handle auth errors
    useEffect(() => {
        if (error?.message === 'UNAUTHORIZED') {
            // Clear tokens and redirect to login
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
            window.location.href = '/login';
        }
    }, [error]);

    return (
        <AuthContext.Provider value={{
            user: user ?? null,
            isLoading,
            isAuthenticated: !!user,
            refetch,
        }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within AuthProvider');
    }
    return context;
};
```

---

## 8. Implementation Checklist

### 8.1 Prerequisites
- [x] Verify `verify_token()` exists in security module
- [x] Verify `UserProfileResponse` schema exists
- [x] Verify exceptions exist (UnauthorizedException, UserNotFoundException)
- [ ] Check if `src/core/dependencies.py` needs to be created

### 8.2 Dependencies Module
- [ ] Create `src/core/dependencies.py`
- [ ] Implement `get_current_user()` dependency
- [ ] Implement `get_current_superuser()` dependency
- [ ] Implement `get_current_user_optional()` dependency
- [ ] Export from `src/core/__init__.py`

### 8.3 API Endpoint
- [ ] Add `/me` endpoint to auth router
- [ ] Import `get_current_user` dependency
- [ ] Configure response model and OpenAPI docs
- [ ] Add proper error responses

### 8.4 Testing
- [ ] Write unit tests for dependencies (8+ test cases)
- [ ] Write integration tests for endpoint (6+ test cases)
- [ ] Achieve 95%+ test coverage
- [ ] Manual testing via Swagger UI

### 8.5 Verification
- [ ] Create verification script `scripts/verify_auth_me.py`
- [ ] Test via Swagger UI
- [ ] Document any edge cases

---

## 9. Acceptance Criteria

### 9.1 Functional Requirements
- [ ] `GET /api/v1/auth/me` endpoint functional
- [ ] Returns user profile with settings
- [ ] Requires Bearer token in Authorization header
- [ ] Validates token signature and expiration
- [ ] Validates token type is "access"
- [ ] Loads user from database with settings
- [ ] Returns 200 OK on success
- [ ] Returns 401 Unauthorized on invalid/missing token
- [ ] Returns 404 Not Found if user deleted

### 9.2 Security Requirements
- [ ] Rejects requests without Authorization header
- [ ] Rejects expired access tokens
- [ ] Rejects refresh tokens (wrong type)
- [ ] Rejects tokens with invalid signatures
- [ ] Rejects inactive users
- [ ] Does not leak sensitive information in errors

### 9.3 Reusability Requirements
- [ ] `get_current_user` can be used in other endpoints
- [ ] `get_current_superuser` works for admin endpoints
- [ ] `get_current_user_optional` works for mixed endpoints
- [ ] Dependencies properly exported for import

### 9.4 Testing Requirements
- [ ] Unit tests for all dependencies
- [ ] Integration tests for API endpoint
- [ ] Test coverage ≥95%
- [ ] All edge cases covered

---

## 10. Verification Script

```python
# File: scripts/verify_auth_me.py

"""
Verification script for Task 03.07: /auth/me Endpoint

Run with:
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run python scripts/verify_auth_me.py
"""

import asyncio
import httpx
from datetime import datetime

BASE_URL = "http://localhost:8000/api/v1/auth"


async def verify_auth_me_endpoint():
    """Verify /auth/me endpoint functionality."""

    async with httpx.AsyncClient() as client:
        print("=" * 60)
        print("Task 03.07: /auth/me Endpoint Verification")
        print("=" * 60)

        # Step 1: Register a test user
        print("\n[1/7] Registering test user...")
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        test_email = f"me_test_{timestamp}@example.com"
        test_password = "TestPass123!"
        test_name = "Auth Me Test User"

        register_response = await client.post(
            f"{BASE_URL}/register",
            json={
                "email": test_email,
                "password": test_password,
                "full_name": test_name,
            }
        )

        if register_response.status_code != 201:
            print(f"   FAILED: Registration failed - {register_response.text}")
            return False

        tokens = register_response.json()
        access_token = tokens["access_token"]
        refresh_token = tokens["refresh_token"]
        print(f"   SUCCESS: Registered user {test_email}")

        # Step 2: Test successful /me request
        print("\n[2/7] Testing GET /me with valid token...")
        me_response = await client.get(
            f"{BASE_URL}/me",
            headers={"Authorization": f"Bearer {access_token}"}
        )

        if me_response.status_code != 200:
            print(f"   FAILED: Expected 200, got {me_response.status_code}")
            print(f"   Response: {me_response.text}")
            return False

        profile = me_response.json()

        # Verify response structure
        required_fields = ["id", "email", "full_name", "is_active", "settings"]
        for field in required_fields:
            if field not in profile:
                print(f"   FAILED: Missing field '{field}' in response")
                return False

        if profile["email"] != test_email:
            print(f"   FAILED: Email mismatch")
            return False

        if profile["full_name"] != test_name:
            print(f"   FAILED: Name mismatch")
            return False

        if "daily_goal" not in profile["settings"]:
            print(f"   FAILED: Settings missing daily_goal")
            return False

        print("   SUCCESS: Profile retrieved with correct data")

        # Step 3: Test /me without token
        print("\n[3/7] Testing GET /me without token...")
        no_token_response = await client.get(f"{BASE_URL}/me")

        if no_token_response.status_code != 401:
            print(f"   FAILED: Expected 401, got {no_token_response.status_code}")
            return False

        print("   SUCCESS: Correctly rejected (401 Unauthorized)")

        # Step 4: Test /me with invalid token
        print("\n[4/7] Testing GET /me with invalid token...")
        invalid_response = await client.get(
            f"{BASE_URL}/me",
            headers={"Authorization": "Bearer invalid.token.here"}
        )

        if invalid_response.status_code != 401:
            print(f"   FAILED: Expected 401, got {invalid_response.status_code}")
            return False

        print("   SUCCESS: Correctly rejected invalid token")

        # Step 5: Test /me with refresh token (should fail)
        print("\n[5/7] Testing GET /me with refresh token (wrong type)...")
        refresh_as_access = await client.get(
            f"{BASE_URL}/me",
            headers={"Authorization": f"Bearer {refresh_token}"}
        )

        if refresh_as_access.status_code != 401:
            print(f"   FAILED: Expected 401, got {refresh_as_access.status_code}")
            return False

        if "type" not in refresh_as_access.json().get("detail", "").lower():
            print("   WARNING: Error message doesn't mention token type")

        print("   SUCCESS: Correctly rejected refresh token")

        # Step 6: Test /me after token refresh
        print("\n[6/7] Testing GET /me after token refresh...")
        refresh_response = await client.post(
            f"{BASE_URL}/refresh",
            json={"refresh_token": refresh_token}
        )

        if refresh_response.status_code != 200:
            print(f"   FAILED: Token refresh failed - {refresh_response.text}")
            return False

        new_access_token = refresh_response.json()["access_token"]

        me_after_refresh = await client.get(
            f"{BASE_URL}/me",
            headers={"Authorization": f"Bearer {new_access_token}"}
        )

        if me_after_refresh.status_code != 200:
            print(f"   FAILED: Expected 200, got {me_after_refresh.status_code}")
            return False

        print("   SUCCESS: /me works with refreshed token")

        # Step 7: Test /me returns consistent data
        print("\n[7/7] Verifying profile data consistency...")
        profile2 = me_after_refresh.json()

        if profile["id"] != profile2["id"]:
            print("   FAILED: User ID changed after refresh")
            return False

        if profile["email"] != profile2["email"]:
            print("   FAILED: Email changed after refresh")
            return False

        print("   SUCCESS: Profile data is consistent")

        # Summary
        print("\n" + "=" * 60)
        print("VERIFICATION RESULT: ALL CHECKS PASSED")
        print("=" * 60)
        print("\nTask 03.07 /auth/me Endpoint is READY FOR PRODUCTION")

        return True


if __name__ == "__main__":
    result = asyncio.run(verify_auth_me_endpoint())
    exit(0 if result else 1)
```

---

## 11. Related Documentation

- [03-authentication-system-plan.md](./03-authentication-system-plan.md) - Main authentication plan
- [03.01-password-hashing-detailed-plan.md](./03.01-password-hashing-detailed-plan.md) - Password hashing
- [03.02-jwt-token-management-plan.md](./03.02-jwt-token-management-plan.md) - JWT token management
- [03.03-user-registration-endpoint-plan.md](./03.03-user-registration-endpoint-plan.md) - Registration endpoint
- [03.04-login-endpoint-plan.md](./03.04-login-endpoint-plan.md) - Login endpoint
- [03.05-token-refresh-endpoint-plan.md](./03.05-token-refresh-endpoint-plan.md) - Token refresh endpoint

---

**Document Version**: 1.0
**Created**: 2025-11-29
**Author**: Architecture Team
**Status**: Ready for Implementation
