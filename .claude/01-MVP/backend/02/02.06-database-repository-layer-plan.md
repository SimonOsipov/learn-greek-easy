# Backend Task 02.06: Database Repository Layer - Technical Architecture Plan

**Status**: âœ… COMPLETED (2025-11-24)
**Actual Duration**: 90 minutes
**Priority**: High
**Dependencies**: Tasks 02.01-02.05 (COMPLETED âœ…)

## Implementation Results

**Completion Date**: 2025-11-24

**Files Created**:
- âœ… `src/repositories/base.py` (237 lines) - Generic BaseRepository with CRUD operations
- âœ… `src/repositories/user.py` (245 lines) - UserRepository, RefreshTokenRepository, UserSettingsRepository
- âœ… `src/repositories/deck.py` (128 lines) - DeckRepository with filtering and search
- âœ… `src/repositories/card.py` (89 lines) - CardRepository with bulk operations
- âœ… `src/repositories/progress.py` (276 lines) - UserDeckProgressRepository, CardStatisticsRepository (SM-2 support)
- âœ… `src/repositories/review.py` (155 lines) - ReviewRepository with analytics
- âœ… `src/repositories/__init__.py` (32 lines) - Clean exports for all repositories
- âœ… `tests/unit/repositories/test_repositories.py` (763 lines) - 50+ comprehensive test cases
- âœ… `tests/unit/repositories/conftest.py` (180 lines) - Repository test fixtures
- âœ… `scripts/verify_repositories.py` (175 lines) - Verification script

**Test Results**:
- âœ… 50+ unit tests covering all repository methods
- âœ… 7 repository classes implemented (BaseRepository + 6 specialized)
- âœ… 37 repository methods with full type hints
- âœ… Async/await throughout with SQLAlchemy 2.0
- âœ… N+1 query prevention with eager loading
- âœ… SM-2 algorithm support (get_due_cards, update_sm2_data)

**Key Features Implemented**:
- ðŸŽ¯ Generic CRUD operations (create, get, update, delete, list, count, filter_by, exists)
- ðŸŽ¯ User authentication queries (get_by_email, create_with_settings, verify_email)
- ðŸŽ¯ Token management (cleanup_expired, revoke_token)
- ðŸŽ¯ Deck filtering and full-text search
- ðŸŽ¯ Card bulk operations and ordering
- ðŸŽ¯ Progress tracking with get_or_create pattern
- ðŸŽ¯ SM-2 spaced repetition queries
- ðŸŽ¯ Review analytics (streak calculation, average quality)

**Total Code**: 2,280 lines (1,162 repository + 943 tests + 175 verification)

---

## Overview

This task implements a comprehensive repository layer (Data Access Layer) for database operations in the Learn Greek Easy backend. The repository pattern abstracts database queries into reusable, testable methods, providing a clean interface between business logic and data persistence.

**Context**:
- SQLAlchemy 2.0 async models fully implemented (8 models)
- Pydantic schemas ready for validation (35+ schemas)
- Database session management configured with dependency injection
- Alembic migrations operational
- No repository layer exists yet - endpoints will need clean data access methods

**Why This Task Is Critical**:
1. **Separation of Concerns**: Business logic in API routes should not contain raw SQL queries
2. **Reusability**: Common queries (get by ID, list with filters) used across multiple endpoints
3. **Testability**: Repositories can be mocked for unit testing business logic
4. **Consistency**: Standardized error handling and query patterns
5. **Performance**: Centralized query optimization and eager loading strategies
6. **Maintainability**: Database logic changes in one place, not scattered across endpoints

---

## Architecture Design

### Repository Pattern Structure

```
src/repositories/
â”œâ”€â”€ __init__.py              # Export all repositories
â”œâ”€â”€ base.py                  # Generic base repository with CRUD operations
â”œâ”€â”€ user.py                  # User + UserSettings + RefreshToken repositories
â”œâ”€â”€ deck.py                  # Deck repository with filtering
â”œâ”€â”€ card.py                  # Card repository with deck relationships
â”œâ”€â”€ progress.py              # UserDeckProgress + CardStatistics repositories
â””â”€â”€ review.py                # Review repository with analytics queries
```

### Design Principles

1. **Generic Base Repository**: CRUD operations (Create, Read, Update, Delete) shared across all entities
2. **Type Safety**: Full type hints with Python 3.14 and SQLAlchemy 2.0 Mapped types
3. **Async/Await**: All database operations use async patterns
4. **Eager Loading**: Relationships loaded efficiently to prevent N+1 queries
5. **Error Handling**: Consistent exception handling for not found, constraint violations
6. **Transaction Management**: Repository methods don't commit - let the caller decide
7. **Query Filters**: Reusable filter methods for common query patterns
8. **Pagination**: Built-in support for offset/limit pagination

---

## Technical Specifications

### 1. Generic Base Repository

**File**: `src/repositories/base.py`

**Purpose**: Provide generic CRUD operations that all repositories inherit.

**Key Methods**:
```python
class BaseRepository[T]:
    async def get(id: UUID) -> T | None
    async def get_or_404(id: UUID) -> T
    async def list(skip: int, limit: int) -> list[T]
    async def count() -> int
    async def create(obj_in: BaseModel | dict) -> T
    async def update(db_obj: T, obj_in: BaseModel | dict) -> T
    async def delete(db_obj: T) -> None
    async def filter_by(**filters) -> list[T]
    async def exists(**filters) -> bool
```

**Implementation Details**:

```python
"""Base repository with generic CRUD operations."""

from typing import Any, Generic, Type, TypeVar
from uuid import UUID

from pydantic import BaseModel
from sqlalchemy import Select, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.exceptions import NotFoundException

# Type variable for SQLAlchemy models
ModelType = TypeVar("ModelType")


class BaseRepository(Generic[ModelType]):
    """Generic base repository with common CRUD operations.

    This repository provides standard database operations that all
    specific repositories can inherit. It uses SQLAlchemy 2.0 async
    patterns and type hints for type safety.

    Type Parameters:
        ModelType: The SQLAlchemy model class this repository manages.

    Example:
        class UserRepository(BaseRepository[User]):
            def __init__(self, db: AsyncSession):
                super().__init__(User, db)
    """

    def __init__(self, model: Type[ModelType], db: AsyncSession):
        """Initialize repository with model class and database session.

        Args:
            model: SQLAlchemy model class (e.g., User, Deck, Card)
            db: Async database session from dependency injection
        """
        self.model = model
        self.db = db

    async def get(self, id: UUID) -> ModelType | None:
        """Get a single record by primary key.

        Args:
            id: UUID primary key

        Returns:
            Model instance or None if not found

        Example:
            user = await user_repo.get(user_id)
            if user is None:
                raise HTTPException(status_code=404)
        """
        return await self.db.get(self.model, id)

    async def get_or_404(self, id: UUID) -> ModelType:
        """Get a single record by primary key or raise 404.

        Args:
            id: UUID primary key

        Returns:
            Model instance

        Raises:
            NotFoundException: If record not found

        Example:
            user = await user_repo.get_or_404(user_id)
            # Guaranteed to have user here
        """
        obj = await self.get(id)
        if obj is None:
            raise NotFoundException(
                f"{self.model.__name__} with id {id} not found"
            )
        return obj

    async def list(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
    ) -> list[ModelType]:
        """List records with pagination.

        Args:
            skip: Number of records to skip (offset)
            limit: Maximum number of records to return

        Returns:
            List of model instances

        Example:
            decks = await deck_repo.list(skip=0, limit=20)
        """
        query = select(self.model).offset(skip).limit(limit)
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def count(self) -> int:
        """Count total records in table.

        Returns:
            Total record count

        Example:
            total = await deck_repo.count()
        """
        query = select(func.count()).select_from(self.model)
        result = await self.db.execute(query)
        return result.scalar_one()

    async def create(self, obj_in: BaseModel | dict[str, Any]) -> ModelType:
        """Create a new record.

        Args:
            obj_in: Pydantic schema or dict with field values

        Returns:
            Created model instance (not yet committed)

        Note:
            This method does NOT commit the transaction.
            Caller must call db.commit() and db.refresh() after.

        Example:
            user = await user_repo.create(UserCreate(...))
            await db.commit()
            await db.refresh(user)
        """
        if isinstance(obj_in, dict):
            create_data = obj_in
        else:
            create_data = obj_in.model_dump(exclude_unset=True)

        db_obj = self.model(**create_data)
        self.db.add(db_obj)
        await self.db.flush()  # Flush to get ID without committing
        return db_obj

    async def update(
        self,
        db_obj: ModelType,
        obj_in: BaseModel | dict[str, Any],
    ) -> ModelType:
        """Update an existing record.

        Args:
            db_obj: Existing database object to update
            obj_in: Pydantic schema or dict with updated values

        Returns:
            Updated model instance (not yet committed)

        Note:
            Only updates fields present in obj_in (partial updates).
            Does NOT commit the transaction.

        Example:
            user = await user_repo.get_or_404(user_id)
            updated_user = await user_repo.update(user, UserUpdate(...))
            await db.commit()
            await db.refresh(updated_user)
        """
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            setattr(db_obj, field, value)

        self.db.add(db_obj)
        await self.db.flush()
        return db_obj

    async def delete(self, db_obj: ModelType) -> None:
        """Delete a record.

        Args:
            db_obj: Database object to delete

        Note:
            Does NOT commit the transaction.
            Caller must call db.commit() after.

        Example:
            user = await user_repo.get_or_404(user_id)
            await user_repo.delete(user)
            await db.commit()
        """
        await self.db.delete(db_obj)
        await self.db.flush()

    async def filter_by(self, **filters: Any) -> list[ModelType]:
        """Filter records by arbitrary field values.

        Args:
            **filters: Field name = value pairs

        Returns:
            List of matching model instances

        Example:
            active_users = await user_repo.filter_by(is_active=True)
            a1_decks = await deck_repo.filter_by(level=DeckLevel.A1)
        """
        query = select(self.model)
        for field, value in filters.items():
            query = query.where(getattr(self.model, field) == value)

        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def exists(self, **filters: Any) -> bool:
        """Check if any record matches filters.

        Args:
            **filters: Field name = value pairs

        Returns:
            True if at least one matching record exists

        Example:
            email_taken = await user_repo.exists(email="test@example.com")
        """
        query = select(func.count()).select_from(self.model)
        for field, value in filters.items():
            query = query.where(getattr(self.model, field) == value)

        result = await self.db.execute(query)
        count = result.scalar_one()
        return count > 0
```

**Design Decisions**:
- **No Auto-Commit**: Repositories flush but don't commit, giving callers transaction control
- **Generic Type**: Uses TypeVar to maintain type safety across all operations
- **Pydantic Integration**: Accepts Pydantic schemas directly using `model_dump()`
- **Error Handling**: `get_or_404` raises custom exception for clean error handling

---

### 2. User Repository

**File**: `src/repositories/user.py`

**Purpose**: User-specific queries including authentication, settings, and refresh tokens.

**Key Methods**:
```python
class UserRepository(BaseRepository[User]):
    async def get_by_email(email: str) -> User | None
    async def get_with_settings(user_id: UUID) -> User | None
    async def create_with_settings(user_in: UserCreate) -> User
    async def verify_email(user_id: UUID) -> User
    async def deactivate(user_id: UUID) -> User

class RefreshTokenRepository(BaseRepository[RefreshToken]):
    async def get_by_token(token: str) -> RefreshToken | None
    async def delete_expired() -> int
    async def delete_user_tokens(user_id: UUID) -> int
    async def cleanup() -> int
```

**Implementation Details**:

```python
"""User, UserSettings, and RefreshToken repositories."""

from datetime import datetime, timedelta
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.db.models import RefreshToken, User, UserSettings
from src.repositories.base import BaseRepository
from src.schemas.user import UserCreate


class UserRepository(BaseRepository[User]):
    """Repository for User model with authentication queries."""

    def __init__(self, db: AsyncSession):
        super().__init__(User, db)

    async def get_by_email(self, email: str) -> User | None:
        """Get user by email address.

        Args:
            email: User's email address

        Returns:
            User instance or None if not found

        Use Case:
            Login, registration email uniqueness check
        """
        query = select(User).where(User.email == email)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def get_by_google_id(self, google_id: str) -> User | None:
        """Get user by Google OAuth ID.

        Args:
            google_id: Google OAuth user ID

        Returns:
            User instance or None if not found

        Use Case:
            Google OAuth login/signup
        """
        query = select(User).where(User.google_id == google_id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def get_with_settings(self, user_id: UUID) -> User | None:
        """Get user with settings eagerly loaded.

        Args:
            user_id: User's UUID

        Returns:
            User instance with settings relationship loaded

        Use Case:
            User profile endpoint, settings page
        """
        query = (
            select(User)
            .where(User.id == user_id)
            .options(selectinload(User.settings))
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def create_with_settings(
        self,
        user_in: UserCreate,
        password_hash: str,
    ) -> User:
        """Create user with default settings in one transaction.

        Args:
            user_in: User creation schema
            password_hash: Hashed password from security module

        Returns:
            Created user with settings (not yet committed)

        Use Case:
            User registration
        """
        # Create user
        db_user = User(
            email=user_in.email,
            password_hash=password_hash,
            full_name=user_in.full_name,
        )
        self.db.add(db_user)
        await self.db.flush()

        # Create default settings
        db_settings = UserSettings(
            user_id=db_user.id,
            daily_goal=20,
            email_notifications=True,
        )
        self.db.add(db_settings)
        await self.db.flush()

        return db_user

    async def verify_email(self, user_id: UUID) -> User:
        """Mark user's email as verified.

        Args:
            user_id: User's UUID

        Returns:
            Updated user (not yet committed)

        Use Case:
            Email verification flow
        """
        user = await self.get_or_404(user_id)
        user.email_verified_at = datetime.utcnow()
        self.db.add(user)
        await self.db.flush()
        return user

    async def deactivate(self, user_id: UUID) -> User:
        """Deactivate user account.

        Args:
            user_id: User's UUID

        Returns:
            Updated user (not yet committed)

        Use Case:
            Account deletion (soft delete)
        """
        user = await self.get_or_404(user_id)
        user.is_active = False
        self.db.add(user)
        await self.db.flush()
        return user


class RefreshTokenRepository(BaseRepository[RefreshToken]):
    """Repository for RefreshToken model with cleanup operations."""

    def __init__(self, db: AsyncSession):
        super().__init__(RefreshToken, db)

    async def get_by_token(self, token: str) -> RefreshToken | None:
        """Get refresh token by token string.

        Args:
            token: JWT refresh token string

        Returns:
            RefreshToken instance or None if not found

        Use Case:
            Token refresh endpoint
        """
        query = (
            select(RefreshToken)
            .where(RefreshToken.token == token)
            .options(selectinload(RefreshToken.user))
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def delete_expired(self) -> int:
        """Delete all expired refresh tokens.

        Returns:
            Number of deleted tokens

        Use Case:
            Scheduled cleanup job
        """
        query = delete(RefreshToken).where(
            RefreshToken.expires_at < datetime.utcnow()
        )
        result = await self.db.execute(query)
        await self.db.flush()
        return result.rowcount

    async def delete_user_tokens(self, user_id: UUID) -> int:
        """Delete all refresh tokens for a specific user.

        Args:
            user_id: User's UUID

        Returns:
            Number of deleted tokens

        Use Case:
            Logout all devices, password change
        """
        query = delete(RefreshToken).where(RefreshToken.user_id == user_id)
        result = await self.db.execute(query)
        await self.db.flush()
        return result.rowcount

    async def cleanup(self, days_old: int = 30) -> int:
        """Delete old expired tokens (expired > N days ago).

        Args:
            days_old: Only delete tokens expired this many days ago

        Returns:
            Number of deleted tokens

        Use Case:
            Database maintenance
        """
        cutoff = datetime.utcnow() - timedelta(days=days_old)
        query = delete(RefreshToken).where(RefreshToken.expires_at < cutoff)
        result = await self.db.execute(query)
        await self.db.flush()
        return result.rowcount


class UserSettingsRepository(BaseRepository[UserSettings]):
    """Repository for UserSettings model."""

    def __init__(self, db: AsyncSession):
        super().__init__(UserSettings, db)

    async def get_by_user_id(self, user_id: UUID) -> UserSettings | None:
        """Get settings for a specific user.

        Args:
            user_id: User's UUID

        Returns:
            UserSettings instance or None if not found

        Use Case:
            Settings page, daily goal checks
        """
        query = select(UserSettings).where(UserSettings.user_id == user_id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
```

---

### 3. Deck Repository

**File**: `src/repositories/deck.py`

**Purpose**: Deck queries with filtering, active deck management.

**Key Methods**:
```python
class DeckRepository(BaseRepository[Deck]):
    async def list_active(skip: int, limit: int, level: DeckLevel | None) -> list[Deck]
    async def get_with_cards(deck_id: UUID) -> Deck | None
    async def count_cards(deck_id: UUID) -> int
    async def search(query: str, skip: int, limit: int) -> list[Deck]
```

**Implementation Details**:

```python
"""Deck repository with filtering and card relationships."""

from uuid import UUID

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.db.models import Card, Deck, DeckLevel
from src.repositories.base import BaseRepository


class DeckRepository(BaseRepository[Deck]):
    """Repository for Deck model with filtering and search."""

    def __init__(self, db: AsyncSession):
        super().__init__(Deck, db)

    async def list_active(
        self,
        *,
        skip: int = 0,
        limit: int = 100,
        level: DeckLevel | None = None,
    ) -> list[Deck]:
        """List active decks with optional level filter.

        Args:
            skip: Pagination offset
            limit: Max results
            level: Optional CEFR level filter (A1, A2, B1, B2, C1, C2)

        Returns:
            List of active decks

        Use Case:
            Browse decks page
        """
        query = select(Deck).where(Deck.is_active == True)

        if level is not None:
            query = query.where(Deck.level == level)

        query = query.offset(skip).limit(limit).order_by(Deck.created_at.desc())

        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def get_with_cards(self, deck_id: UUID) -> Deck | None:
        """Get deck with all cards eagerly loaded.

        Args:
            deck_id: Deck UUID

        Returns:
            Deck with cards relationship loaded

        Use Case:
            Deck detail page, study session initialization

        Performance:
            Uses selectinload to prevent N+1 queries
        """
        query = (
            select(Deck)
            .where(Deck.id == deck_id)
            .options(selectinload(Deck.cards))
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def count_cards(self, deck_id: UUID) -> int:
        """Count total cards in a deck.

        Args:
            deck_id: Deck UUID

        Returns:
            Number of cards in deck

        Use Case:
            Deck metadata, progress calculations
        """
        query = (
            select(func.count())
            .select_from(Card)
            .where(Card.deck_id == deck_id)
        )
        result = await self.db.execute(query)
        return result.scalar_one()

    async def search(
        self,
        query_text: str,
        *,
        skip: int = 0,
        limit: int = 20,
    ) -> list[Deck]:
        """Search decks by name or description.

        Args:
            query_text: Search query string
            skip: Pagination offset
            limit: Max results

        Returns:
            List of matching decks

        Use Case:
            Search functionality

        Note:
            Uses case-insensitive ILIKE search (PostgreSQL)
        """
        search_pattern = f"%{query_text}%"
        query = (
            select(Deck)
            .where(
                (Deck.name.ilike(search_pattern))
                | (Deck.description.ilike(search_pattern))
            )
            .where(Deck.is_active == True)
            .offset(skip)
            .limit(limit)
        )

        result = await self.db.execute(query)
        return list(result.scalars().all())
```

---

### 4. Card Repository

**File**: `src/repositories/card.py`

**Purpose**: Card queries with deck filtering and ordering.

**Implementation Details**:

```python
"""Card repository with deck relationships."""

from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import Card, CardDifficulty
from src.repositories.base import BaseRepository


class CardRepository(BaseRepository[Card]):
    """Repository for Card model with deck filtering."""

    def __init__(self, db: AsyncSession):
        super().__init__(Card, db)

    async def get_by_deck(
        self,
        deck_id: UUID,
        *,
        skip: int = 0,
        limit: int = 100,
    ) -> list[Card]:
        """Get all cards for a specific deck.

        Args:
            deck_id: Deck UUID
            skip: Pagination offset
            limit: Max results

        Returns:
            List of cards ordered by order_index

        Use Case:
            Study session, deck review
        """
        query = (
            select(Card)
            .where(Card.deck_id == deck_id)
            .order_by(Card.order_index)
            .offset(skip)
            .limit(limit)
        )
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def get_by_difficulty(
        self,
        deck_id: UUID,
        difficulty: CardDifficulty,
    ) -> list[Card]:
        """Get cards filtered by difficulty level.

        Args:
            deck_id: Deck UUID
            difficulty: Card difficulty (easy, medium, hard)

        Returns:
            List of cards with specified difficulty

        Use Case:
            Progressive learning (start with easy cards)
        """
        query = (
            select(Card)
            .where(Card.deck_id == deck_id)
            .where(Card.difficulty == difficulty)
            .order_by(Card.order_index)
        )
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def bulk_create(self, cards_data: list[dict]) -> list[Card]:
        """Create multiple cards in one transaction.

        Args:
            cards_data: List of card dictionaries

        Returns:
            List of created cards (not yet committed)

        Use Case:
            Deck import, bulk card creation
        """
        cards = [Card(**card_data) for card_data in cards_data]
        self.db.add_all(cards)
        await self.db.flush()
        return cards
```

---

### 5. Progress Repository

**File**: `src/repositories/progress.py`

**Purpose**: User progress tracking, SM-2 algorithm queries, due cards calculation.

**Key Methods**:
```python
class UserDeckProgressRepository(BaseRepository[UserDeckProgress]):
    async def get_or_create(user_id: UUID, deck_id: UUID) -> UserDeckProgress
    async def get_user_progress(user_id: UUID) -> list[UserDeckProgress]
    async def update_progress_metrics(progress_id: UUID) -> UserDeckProgress

class CardStatisticsRepository(BaseRepository[CardStatistics]):
    async def get_or_create(user_id: UUID, card_id: UUID) -> CardStatistics
    async def get_due_cards(user_id: UUID, deck_id: UUID) -> list[CardStatistics]
    async def get_by_status(user_id: UUID, status: CardStatus) -> list[CardStatistics]
    async def update_sm2_data(stats_id: UUID, sm2_data: dict) -> CardStatistics
```

**Implementation Details**:

```python
"""Progress tracking repositories for SM-2 algorithm."""

from datetime import date, datetime
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.db.models import (
    CardStatistics,
    CardStatus,
    UserDeckProgress,
)
from src.repositories.base import BaseRepository


class UserDeckProgressRepository(BaseRepository[UserDeckProgress]):
    """Repository for UserDeckProgress model."""

    def __init__(self, db: AsyncSession):
        super().__init__(UserDeckProgress, db)

    async def get_or_create(
        self,
        user_id: UUID,
        deck_id: UUID,
    ) -> UserDeckProgress:
        """Get existing progress or create new one.

        Args:
            user_id: User UUID
            deck_id: Deck UUID

        Returns:
            UserDeckProgress instance (not yet committed if new)

        Use Case:
            Starting a new deck, tracking progress
        """
        query = (
            select(UserDeckProgress)
            .where(UserDeckProgress.user_id == user_id)
            .where(UserDeckProgress.deck_id == deck_id)
        )
        result = await self.db.execute(query)
        progress = result.scalar_one_or_none()

        if progress is None:
            progress = UserDeckProgress(
                user_id=user_id,
                deck_id=deck_id,
                cards_studied=0,
                cards_mastered=0,
            )
            self.db.add(progress)
            await self.db.flush()

        return progress

    async def get_user_progress(
        self,
        user_id: UUID,
        *,
        skip: int = 0,
        limit: int = 100,
    ) -> list[UserDeckProgress]:
        """Get all deck progress for a user.

        Args:
            user_id: User UUID
            skip: Pagination offset
            limit: Max results

        Returns:
            List of user's deck progress with deck info loaded

        Use Case:
            Dashboard, progress overview
        """
        query = (
            select(UserDeckProgress)
            .where(UserDeckProgress.user_id == user_id)
            .options(selectinload(UserDeckProgress.deck))
            .order_by(UserDeckProgress.last_studied_at.desc().nullslast())
            .offset(skip)
            .limit(limit)
        )
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def update_progress_metrics(
        self,
        progress_id: UUID,
        cards_studied_delta: int = 0,
        cards_mastered_delta: int = 0,
    ) -> UserDeckProgress:
        """Update progress metrics.

        Args:
            progress_id: UserDeckProgress UUID
            cards_studied_delta: Change in cards_studied count
            cards_mastered_delta: Change in cards_mastered count

        Returns:
            Updated progress (not yet committed)

        Use Case:
            After completing a review
        """
        progress = await self.get_or_404(progress_id)
        progress.cards_studied += cards_studied_delta
        progress.cards_mastered += cards_mastered_delta
        progress.last_studied_at = datetime.utcnow()

        self.db.add(progress)
        await self.db.flush()
        return progress


class CardStatisticsRepository(BaseRepository[CardStatistics]):
    """Repository for CardStatistics model (SM-2 algorithm)."""

    def __init__(self, db: AsyncSession):
        super().__init__(CardStatistics, db)

    async def get_or_create(
        self,
        user_id: UUID,
        card_id: UUID,
    ) -> CardStatistics:
        """Get existing statistics or create new one.

        Args:
            user_id: User UUID
            card_id: Card UUID

        Returns:
            CardStatistics instance (not yet committed if new)

        Use Case:
            First time reviewing a card
        """
        query = (
            select(CardStatistics)
            .where(CardStatistics.user_id == user_id)
            .where(CardStatistics.card_id == card_id)
        )
        result = await self.db.execute(query)
        stats = result.scalar_one_or_none()

        if stats is None:
            stats = CardStatistics(
                user_id=user_id,
                card_id=card_id,
                easiness_factor=2.5,
                interval=0,
                repetitions=0,
                next_review_date=date.today(),
                status=CardStatus.NEW,
            )
            self.db.add(stats)
            await self.db.flush()

        return stats

    async def get_due_cards(
        self,
        user_id: UUID,
        deck_id: UUID | None = None,
        *,
        limit: int = 20,
    ) -> list[CardStatistics]:
        """Get cards due for review today.

        Args:
            user_id: User UUID
            deck_id: Optional deck filter
            limit: Max cards to return

        Returns:
            List of card statistics with card and deck info loaded

        Use Case:
            Study session - get cards to review

        Performance:
            Uses next_review_date index, eager loads relationships
        """
        query = (
            select(CardStatistics)
            .where(CardStatistics.user_id == user_id)
            .where(CardStatistics.next_review_date <= date.today())
            .options(
                selectinload(CardStatistics.card).selectinload(Card.deck)
            )
            .order_by(CardStatistics.next_review_date)
            .limit(limit)
        )

        if deck_id is not None:
            # Join with Card to filter by deck_id
            query = query.join(Card).where(Card.deck_id == deck_id)

        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def get_by_status(
        self,
        user_id: UUID,
        status: CardStatus,
        *,
        skip: int = 0,
        limit: int = 100,
    ) -> list[CardStatistics]:
        """Get cards filtered by status.

        Args:
            user_id: User UUID
            status: Card status (new, learning, review, mastered)
            skip: Pagination offset
            limit: Max results

        Returns:
            List of card statistics with specified status

        Use Case:
            Show new cards, show mastered cards
        """
        query = (
            select(CardStatistics)
            .where(CardStatistics.user_id == user_id)
            .where(CardStatistics.status == status)
            .options(selectinload(CardStatistics.card))
            .offset(skip)
            .limit(limit)
        )
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def update_sm2_data(
        self,
        stats_id: UUID,
        easiness_factor: float,
        interval: int,
        repetitions: int,
        next_review_date: date,
        status: CardStatus,
    ) -> CardStatistics:
        """Update SM-2 algorithm data after review.

        Args:
            stats_id: CardStatistics UUID
            easiness_factor: New EF value (1.3-2.5+)
            interval: New interval in days
            repetitions: New repetition count
            next_review_date: Next scheduled review date
            status: New card status

        Returns:
            Updated statistics (not yet committed)

        Use Case:
            After processing a review with SM-2 algorithm
        """
        stats = await self.get_or_404(stats_id)
        stats.easiness_factor = easiness_factor
        stats.interval = interval
        stats.repetitions = repetitions
        stats.next_review_date = next_review_date
        stats.status = status

        self.db.add(stats)
        await self.db.flush()
        return stats
```

---

### 6. Review Repository

**File**: `src/repositories/review.py`

**Purpose**: Review history, analytics queries, performance tracking.

**Implementation Details**:

```python
"""Review repository for history and analytics."""

from datetime import date, datetime, timedelta
from uuid import UUID

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import Review
from src.repositories.base import BaseRepository


class ReviewRepository(BaseRepository[Review]):
    """Repository for Review model with analytics queries."""

    def __init__(self, db: AsyncSession):
        super().__init__(Review, db)

    async def get_user_reviews(
        self,
        user_id: UUID,
        *,
        start_date: date | None = None,
        end_date: date | None = None,
        skip: int = 0,
        limit: int = 100,
    ) -> list[Review]:
        """Get user's review history with optional date filter.

        Args:
            user_id: User UUID
            start_date: Optional start date filter
            end_date: Optional end date filter
            skip: Pagination offset
            limit: Max results

        Returns:
            List of reviews ordered by most recent

        Use Case:
            Review history page, analytics dashboard
        """
        query = (
            select(Review)
            .where(Review.user_id == user_id)
            .order_by(Review.reviewed_at.desc())
        )

        if start_date is not None:
            query = query.where(Review.reviewed_at >= start_date)

        if end_date is not None:
            # Include entire end_date
            end_datetime = datetime.combine(
                end_date,
                datetime.max.time()
            )
            query = query.where(Review.reviewed_at <= end_datetime)

        query = query.offset(skip).limit(limit)
        result = await self.db.execute(query)
        return list(result.scalars().all())

    async def count_reviews_today(self, user_id: UUID) -> int:
        """Count reviews completed today.

        Args:
            user_id: User UUID

        Returns:
            Number of reviews today

        Use Case:
            Daily goal tracking
        """
        today_start = datetime.combine(date.today(), datetime.min.time())
        query = (
            select(func.count())
            .select_from(Review)
            .where(Review.user_id == user_id)
            .where(Review.reviewed_at >= today_start)
        )
        result = await self.db.execute(query)
        return result.scalar_one()

    async def get_streak(self, user_id: UUID) -> int:
        """Calculate current study streak (consecutive days).

        Args:
            user_id: User UUID

        Returns:
            Number of consecutive days with at least one review

        Use Case:
            Gamification, dashboard statistics

        Note:
            This is a simplified version. Production might use
            a more efficient materialized view approach.
        """
        # Get unique dates with reviews in past 30 days
        thirty_days_ago = date.today() - timedelta(days=30)
        query = (
            select(func.date(Review.reviewed_at).label("review_date"))
            .where(Review.user_id == user_id)
            .where(Review.reviewed_at >= thirty_days_ago)
            .group_by(func.date(Review.reviewed_at))
            .order_by(func.date(Review.reviewed_at).desc())
        )
        result = await self.db.execute(query)
        review_dates = [row[0] for row in result.all()]

        if not review_dates:
            return 0

        # Count consecutive days
        streak = 0
        current_date = date.today()

        for review_date in review_dates:
            if review_date == current_date:
                streak += 1
                current_date -= timedelta(days=1)
            else:
                break

        return streak

    async def get_average_quality(
        self,
        user_id: UUID,
        days: int = 7,
    ) -> float:
        """Calculate average review quality rating.

        Args:
            user_id: User UUID
            days: Number of days to include in calculation

        Returns:
            Average quality rating (0.0-5.0)

        Use Case:
            Performance analytics
        """
        cutoff = datetime.now() - timedelta(days=days)
        query = (
            select(func.avg(Review.quality))
            .where(Review.user_id == user_id)
            .where(Review.reviewed_at >= cutoff)
        )
        result = await self.db.execute(query)
        avg = result.scalar_one_or_none()
        return float(avg) if avg is not None else 0.0
```

---

## Exception Handling

**File**: `src/core/exceptions.py`

Create custom exceptions for repository operations:

```python
"""Custom exceptions for application logic."""


class AppException(Exception):
    """Base exception for application errors."""

    def __init__(self, message: str):
        self.message = message
        super().__init__(self.message)


class NotFoundException(AppException):
    """Exception raised when a resource is not found."""

    def __init__(self, message: str = "Resource not found"):
        super().__init__(message)


class AlreadyExistsException(AppException):
    """Exception raised when trying to create a duplicate resource."""

    def __init__(self, message: str = "Resource already exists"):
        super().__init__(message)


class ValidationException(AppException):
    """Exception raised when validation fails."""

    def __init__(self, message: str = "Validation failed"):
        super().__init__(message)
```

---

## Repository Factory Pattern

**File**: `src/repositories/__init__.py`

Export all repositories with a factory function:

```python
"""Repository layer for database operations."""

from src.repositories.base import BaseRepository
from src.repositories.card import CardRepository
from src.repositories.deck import DeckRepository
from src.repositories.progress import (
    CardStatisticsRepository,
    UserDeckProgressRepository,
)
from src.repositories.review import ReviewRepository
from src.repositories.user import (
    RefreshTokenRepository,
    UserRepository,
    UserSettingsRepository,
)

__all__ = [
    # Base
    "BaseRepository",
    # User
    "UserRepository",
    "UserSettingsRepository",
    "RefreshTokenRepository",
    # Content
    "DeckRepository",
    "CardRepository",
    # Progress
    "UserDeckProgressRepository",
    "CardStatisticsRepository",
    # Review
    "ReviewRepository",
]
```

---

## Usage Examples

### Example 1: User Registration Endpoint

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.security import hash_password
from src.db.dependencies import get_db
from src.repositories.user import UserRepository
from src.schemas.user import UserCreate, UserResponse

router = APIRouter()


@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_in: UserCreate,
    db: AsyncSession = Depends(get_db),
):
    """Register a new user."""
    # Initialize repository
    user_repo = UserRepository(db)

    # Check if email already exists
    existing_user = await user_repo.get_by_email(user_in.email)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )

    # Hash password
    password_hash = hash_password(user_in.password)

    # Create user with settings
    user = await user_repo.create_with_settings(user_in, password_hash)

    # Commit transaction
    await db.commit()
    await db.refresh(user)

    return user
```

### Example 2: Get Due Cards for Study Session

```python
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from src.db.dependencies import get_db, get_current_user
from src.db.models import User
from src.repositories.progress import CardStatisticsRepository
from src.schemas.card import CardStudyResponse

router = APIRouter()


@router.get("/study/due-cards/{deck_id}", response_model=list[CardStudyResponse])
async def get_due_cards(
    deck_id: UUID,
    limit: int = 20,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Get cards due for review in a specific deck."""
    stats_repo = CardStatisticsRepository(db)

    # Get due cards with eager loading
    due_stats = await stats_repo.get_due_cards(
        user_id=current_user.id,
        deck_id=deck_id,
        limit=limit,
    )

    # Extract cards from statistics
    cards = [stat.card for stat in due_stats]

    return cards
```

### Example 3: Update Progress After Review

```python
from datetime import date
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.dependencies import get_db, get_current_user
from src.db.models import CardStatus, User
from src.repositories.progress import (
    CardStatisticsRepository,
    UserDeckProgressRepository,
)
from src.repositories.review import ReviewRepository
from src.schemas.review import ReviewResponse, ReviewSubmit
from src.services.sm2 import calculate_sm2  # TODO: implement in Task 04

router = APIRouter()


@router.post("/reviews", response_model=ReviewResponse)
async def submit_review(
    review_in: ReviewSubmit,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Submit a card review and update statistics."""
    stats_repo = CardStatisticsRepository(db)
    review_repo = ReviewRepository(db)
    progress_repo = UserDeckProgressRepository(db)

    # Get or create card statistics
    stats = await stats_repo.get_or_create(
        user_id=current_user.id,
        card_id=review_in.card_id,
    )

    # Calculate new SM-2 values
    sm2_result = calculate_sm2(
        quality=review_in.quality,
        easiness_factor=stats.easiness_factor,
        interval=stats.interval,
        repetitions=stats.repetitions,
    )

    # Update card statistics
    stats = await stats_repo.update_sm2_data(
        stats_id=stats.id,
        easiness_factor=sm2_result.easiness_factor,
        interval=sm2_result.interval,
        repetitions=sm2_result.repetitions,
        next_review_date=sm2_result.next_review_date,
        status=sm2_result.status,
    )

    # Create review record
    review = await review_repo.create({
        "user_id": current_user.id,
        "card_id": review_in.card_id,
        "quality": review_in.quality,
        "time_taken": review_in.time_taken,
    })

    # Update deck progress
    # TODO: Get deck_id from card
    # progress = await progress_repo.get_or_create(...)
    # await progress_repo.update_progress_metrics(...)

    # Commit transaction
    await db.commit()

    return ReviewResponse(
        success=True,
        card_id=review_in.card_id,
        new_status=stats.status.value,
        next_review_date=stats.next_review_date,
        easiness_factor=stats.easiness_factor,
        interval=stats.interval,
    )
```

---

## Testing Strategy

### Unit Tests

Create `tests/unit/repositories/` directory:

```
tests/unit/repositories/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py              # Shared fixtures
â”œâ”€â”€ test_base_repository.py
â”œâ”€â”€ test_user_repository.py
â”œâ”€â”€ test_deck_repository.py
â”œâ”€â”€ test_card_repository.py
â”œâ”€â”€ test_progress_repository.py
â””â”€â”€ test_review_repository.py
```

### Test Example: User Repository

```python
"""Unit tests for UserRepository."""

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import User
from src.repositories.user import UserRepository
from src.schemas.user import UserCreate


@pytest.mark.asyncio
async def test_create_user_with_settings(db_session: AsyncSession):
    """Test creating user with default settings."""
    repo = UserRepository(db_session)

    user_in = UserCreate(
        email="test@example.com",
        password="Password123",
        full_name="Test User",
    )

    user = await repo.create_with_settings(user_in, "hashed_password")
    await db_session.commit()

    assert user.email == "test@example.com"
    assert user.full_name == "Test User"
    assert user.settings is not None
    assert user.settings.daily_goal == 20


@pytest.mark.asyncio
async def test_get_by_email(db_session: AsyncSession):
    """Test getting user by email."""
    repo = UserRepository(db_session)

    # Create user
    user_in = UserCreate(
        email="findme@example.com",
        password="Password123",
        full_name="Find Me",
    )
    await repo.create_with_settings(user_in, "hashed")
    await db_session.commit()

    # Find user by email
    found_user = await repo.get_by_email("findme@example.com")

    assert found_user is not None
    assert found_user.email == "findme@example.com"


@pytest.mark.asyncio
async def test_get_by_email_not_found(db_session: AsyncSession):
    """Test getting non-existent user returns None."""
    repo = UserRepository(db_session)

    user = await repo.get_by_email("notfound@example.com")

    assert user is None
```

### Integration Tests

```python
"""Integration tests for repository + database."""

import pytest
from datetime import date
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.models import CardStatus, DeckLevel
from src.repositories.deck import DeckRepository
from src.repositories.card import CardRepository
from src.repositories.progress import CardStatisticsRepository


@pytest.mark.asyncio
async def test_get_due_cards_integration(
    db_session: AsyncSession,
    sample_user,
    sample_deck,
    sample_cards,
):
    """Test getting due cards with full integration."""
    stats_repo = CardStatisticsRepository(db_session)

    # Create statistics for 3 cards (2 due, 1 not due)
    for card in sample_cards[:2]:
        await stats_repo.create({
            "user_id": sample_user.id,
            "card_id": card.id,
            "next_review_date": date.today(),
            "status": CardStatus.LEARNING,
        })

    # Create future card
    await stats_repo.create({
        "user_id": sample_user.id,
        "card_id": sample_cards[2].id,
        "next_review_date": date.today() + timedelta(days=5),
        "status": CardStatus.REVIEW,
    })

    await db_session.commit()

    # Get due cards
    due_stats = await stats_repo.get_due_cards(
        user_id=sample_user.id,
        deck_id=sample_deck.id,
        limit=10,
    )

    assert len(due_stats) == 2
    assert all(stat.next_review_date <= date.today() for stat in due_stats)
```

---

## Performance Considerations

### 1. N+1 Query Prevention

**Problem**: Loading relationships in loops causes N+1 queries.

**Solution**: Use `selectinload()` in repositories:

```python
# BAD: N+1 queries
users = await user_repo.list()
for user in users:
    print(user.settings.daily_goal)  # Triggers N queries

# GOOD: Single query with eager loading
query = select(User).options(selectinload(User.settings))
```

### 2. Index Usage

**Critical Indexes** (already in models):
- `User.email` (unique index for login)
- `CardStatistics.next_review_date` (for due cards query)
- `Review.reviewed_at` (for analytics queries)
- `RefreshToken.expires_at` (for cleanup queries)

### 3. Bulk Operations

Use `bulk_create` for multiple records:

```python
# GOOD: Bulk insert
cards = await card_repo.bulk_create(cards_data)

# BAD: Individual inserts in loop
for card_data in cards_data:
    await card_repo.create(card_data)
```

---

## Security Considerations

### 1. Authorization in Repositories

**Principle**: Repositories should NOT handle authorization. That's the API layer's job.

```python
# BAD: Authorization in repository
async def get_deck(self, deck_id: UUID, user: User) -> Deck:
    if not user.is_premium:
        raise PermissionError("Premium only")
    return await self.get(deck_id)

# GOOD: Authorization in endpoint
@router.get("/decks/{deck_id}")
async def get_deck(
    deck_id: UUID,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    deck = await deck_repo.get_or_404(deck_id)
    if deck.is_premium and not user.is_premium:
        raise HTTPException(status_code=403)
    return deck
```

### 2. SQL Injection Prevention

**Solution**: Always use SQLAlchemy query builders, never string concatenation:

```python
# SAFE: Parameterized query
query = select(User).where(User.email == email)

# NEVER DO THIS: SQL injection vulnerability
query = f"SELECT * FROM users WHERE email = '{email}'"
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] BaseRepository implemented with all CRUD operations
- [ ] UserRepository with authentication queries (get_by_email, get_by_google_id)
- [ ] UserRepository.create_with_settings creates user + settings atomically
- [ ] RefreshTokenRepository with token lookup and cleanup methods
- [ ] DeckRepository with filtering (list_active, search)
- [ ] CardRepository with deck filtering (get_by_deck, get_by_difficulty)
- [ ] UserDeckProgressRepository with get_or_create pattern
- [ ] CardStatisticsRepository with get_due_cards (SM-2 queries)
- [ ] ReviewRepository with analytics queries (streak, average quality)
- [ ] All repositories use async/await patterns
- [ ] All repositories return proper types (not Any)

### Code Quality

- [ ] All methods have docstrings with Args, Returns, Use Case
- [ ] Type hints complete for all parameters and return values
- [ ] Consistent error handling (NotFoundException, etc.)
- [ ] No hardcoded values (use function parameters)
- [ ] Relationships eagerly loaded where appropriate (selectinload)
- [ ] Queries use indexes effectively

### Testing

- [ ] Unit tests for BaseRepository (CRUD operations)
- [ ] Unit tests for UserRepository (email lookup, create_with_settings)
- [ ] Unit tests for get_or_create patterns
- [ ] Integration test for get_due_cards query
- [ ] Test coverage > 80% for repository layer
- [ ] Mock database session in unit tests

### Performance

- [ ] No N+1 queries (use selectinload for relationships)
- [ ] Pagination implemented where needed
- [ ] Bulk operations available for multi-record inserts
- [ ] Query filters use indexed columns

### Documentation

- [ ] README section explaining repository pattern
- [ ] Usage examples for each repository
- [ ] Integration examples with FastAPI endpoints
- [ ] Performance best practices documented

---

## Execution Steps

### Step 1: Create Base Repository (20 minutes)

1. Create `src/repositories/base.py`
2. Implement generic CRUD methods:
   - `get()`, `get_or_404()`
   - `list()`, `count()`
   - `create()`, `update()`, `delete()`
   - `filter_by()`, `exists()`
3. Add comprehensive docstrings
4. Add type hints with Generic[ModelType]

### Step 2: Create Custom Exception Classes (5 minutes)

1. Create `src/core/exceptions.py`
2. Implement:
   - `NotFoundException`
   - `AlreadyExistsException`
   - `ValidationException`

### Step 3: Create User Repository (20 minutes)

1. Create `src/repositories/user.py`
2. Implement UserRepository:
   - `get_by_email()`
   - `get_by_google_id()`
   - `get_with_settings()`
   - `create_with_settings()`
   - `verify_email()`
3. Implement RefreshTokenRepository:
   - `get_by_token()`
   - `delete_expired()`
   - `delete_user_tokens()`
4. Implement UserSettingsRepository:
   - `get_by_user_id()`

### Step 4: Create Deck Repository (15 minutes)

1. Create `src/repositories/deck.py`
2. Implement DeckRepository:
   - `list_active()`
   - `get_with_cards()`
   - `count_cards()`
   - `search()`

### Step 5: Create Card Repository (15 minutes)

1. Create `src/repositories/card.py`
2. Implement CardRepository:
   - `get_by_deck()`
   - `get_by_difficulty()`
   - `bulk_create()`

### Step 6: Create Progress Repository (20 minutes)

1. Create `src/repositories/progress.py`
2. Implement UserDeckProgressRepository:
   - `get_or_create()`
   - `get_user_progress()`
   - `update_progress_metrics()`
3. Implement CardStatisticsRepository:
   - `get_or_create()`
   - `get_due_cards()` (critical for SM-2)
   - `get_by_status()`
   - `update_sm2_data()`

### Step 7: Create Review Repository (15 minutes)

1. Create `src/repositories/review.py`
2. Implement ReviewRepository:
   - `get_user_reviews()`
   - `count_reviews_today()`
   - `get_streak()`
   - `get_average_quality()`

### Step 8: Create Repository Exports (5 minutes)

1. Update `src/repositories/__init__.py`
2. Export all repositories
3. Create __all__ list

### Step 9: Write Unit Tests (30 minutes)

1. Create test structure in `tests/unit/repositories/`
2. Write tests for BaseRepository CRUD operations
3. Write tests for UserRepository queries
4. Write tests for get_or_create patterns
5. Write tests for due cards query
6. Achieve >80% code coverage

### Step 10: Integration Testing (20 minutes)

1. Create `tests/integration/test_repositories.py`
2. Test full workflow: create user â†’ create deck â†’ create cards â†’ get due cards
3. Test transaction rollback behavior
4. Test eager loading (no N+1 queries)

---

## Dependencies

**Already Installed**:
- Python 3.14
- SQLAlchemy 2.0 (async)
- Pydantic 2.9+
- pytest + pytest-asyncio

**No New Dependencies Required**

---

## Common Issues & Solutions

### Issue 1: Type hints not working with Generic[T]

**Solution**: Use `TypeVar` correctly:

```python
from typing import TypeVar, Generic

ModelType = TypeVar("ModelType")

class BaseRepository(Generic[ModelType]):
    def __init__(self, model: Type[ModelType], db: AsyncSession):
        self.model = model
```

### Issue 2: "Object is already attached to session" error

**Solution**: Don't add objects multiple times:

```python
# Use add() once, flush() to get ID without committing
self.db.add(db_obj)
await self.db.flush()
return db_obj
```

### Issue 3: N+1 queries with relationships

**Solution**: Always use `selectinload()`:

```python
from sqlalchemy.orm import selectinload

query = select(User).options(selectinload(User.settings))
```

### Issue 4: get_or_create race condition

**Solution**: Use unique constraints and handle IntegrityError:

```python
try:
    obj = await self.create(obj_in)
    await self.db.flush()
except IntegrityError:
    await self.db.rollback()
    obj = await self.get_by_unique_field(value)
```

---

## Next Steps (Task 03)

After completing the repository layer:

1. **Task 03: Authentication System**
   - Use UserRepository for login/registration
   - Use RefreshTokenRepository for JWT refresh
   - Implement password hashing and verification
   - Create authentication middleware

2. **Task 04: SM-2 Algorithm Service**
   - Use CardStatisticsRepository.get_due_cards()
   - Use CardStatisticsRepository.update_sm2_data()
   - Implement SM-2 calculation logic
   - Create review submission service

3. **Task 05: API Endpoints**
   - User registration: POST /api/auth/register
   - Deck listing: GET /api/decks
   - Study session: GET /api/study/due-cards/{deck_id}
   - Review submission: POST /api/reviews

---

## References

- [Repository Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/repository.html)
- [SQLAlchemy 2.0 Async ORM](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [SQLAlchemy Eager Loading](https://docs.sqlalchemy.org/en/20/orm/queryguide/relationships.html#selectin-eager-loading)
- [Python Type Hints with Generics](https://docs.python.org/3/library/typing.html#generics)

---

**Document Version**: 1.0
**Created**: 2025-11-24
**Author**: Architect Agent
**Estimated Duration**: 90-120 minutes
**Status**: ðŸ“‹ READY FOR IMPLEMENTATION

---

## Summary

This repository layer provides:

1. **Clean Abstraction**: Business logic doesn't touch SQL queries directly
2. **Reusability**: Common queries used across multiple endpoints
3. **Type Safety**: Full type hints for IDE support and error prevention
4. **Testability**: Easy to mock repositories for unit testing
5. **Performance**: Eager loading prevents N+1 queries
6. **Maintainability**: Database logic centralized in one place

**Critical for MVP**: This layer is essential before building API endpoints. All database operations in endpoints should go through repositories, not raw SQLAlchemy queries.

**Ready for Execution**: This plan contains everything needed to implement a production-quality repository layer. All code examples are complete and follow SQLAlchemy 2.0 async best practices.
