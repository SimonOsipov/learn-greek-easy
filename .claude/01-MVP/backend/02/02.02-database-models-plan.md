# Backend Task 02.02: Define Database Models

**Status**: ✅ COMPLETED (2025-11-20)
**Estimated Time**: 2.5-3 hours
**Actual Time**: ~2 hours
**Parent Task**: [02-database-design.md](./02-database-design.md)

---

## Overview

Implement all SQLAlchemy 2.0 async models for the Learn Greek Easy application, including User management, Content (Decks/Cards), and Progress tracking with SM-2 spaced repetition algorithm support.

---

## Prerequisites

✅ **All prerequisites verified before implementation:**

1. ✅ Task 02.01 completed (Database connection & session management)
2. ✅ PostgreSQL 16 Docker container running
3. ✅ Base classes available (`Base`, `TimestampMixin`, `SoftDeleteMixin`)
4. ✅ SQLAlchemy 2.0 + asyncpg installed
5. ✅ FastAPI integrated with database lifecycle

---

## Implementation Plan

### Step 1: Define PostgreSQL Enums (10 minutes)

Create Python enums that will map to PostgreSQL enum types:

**Enums to implement:**
- `DeckLevel`: CEFR language levels (A1, A2, B1, B2, C1, C2)
- `CardDifficulty`: Card difficulty levels (easy, medium, hard)
- `CardStatus`: SM-2 learning status (new, learning, review, mastered)
- `ReviewRating`: SM-2 quality rating (0-5)

**Code example:**
```python
import enum

class DeckLevel(str, enum.Enum):
    """CEFR language proficiency levels."""
    A1 = "A1"
    A2 = "A2"
    B1 = "B1"
    B2 = "B2"
    C1 = "C1"
    C2 = "C2"

class CardStatus(str, enum.Enum):
    """Learning status for SM-2 algorithm."""
    NEW = "new"
    LEARNING = "learning"
    REVIEW = "review"
    MASTERED = "mastered"
```

### Step 2: Implement User Models (30 minutes)

**Models:**
1. `User` - Core user account with authentication
2. `UserSettings` - User preferences
3. `RefreshToken` - JWT refresh token management

**Key features:**
- UUID primary keys with `server_default=func.uuid_generate_v4()`
- Support for both email/password and Google OAuth
- One-to-one relationship: User ↔ UserSettings
- One-to-many: User → RefreshTokens
- Indexes on email, google_id, token, expires_at

**User model structure:**
```python
class User(Base, TimestampMixin):
    __tablename__ = "users"

    id: Mapped[UUID] = mapped_column(primary_key=True, server_default=func.uuid_generate_v4())
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password_hash: Mapped[str | None] = mapped_column(String(255), nullable=True)
    full_name: Mapped[str | None] = mapped_column(String(255))
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False)
    email_verified_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    google_id: Mapped[str | None] = mapped_column(String(255), unique=True, index=True)

    # Relationships with lazy="selectin" for async
    settings: Mapped["UserSettings"] = relationship(back_populates="user", lazy="selectin")
```

### Step 3: Implement Content Models (35 minutes)

**Models:**
1. `Deck` - Greek vocabulary decks
2. `Card` - Individual flashcards

**Key features:**
- Deck levels using `DeckLevel` enum
- Card difficulty using `CardDifficulty` enum
- Foreign key: Card.deck_id → Deck.id
- Indexes on deck.level, deck.is_active, card.difficulty
- Cascade delete: Delete deck → delete all cards

**Deck model structure:**
```python
class Deck(Base, TimestampMixin):
    __tablename__ = "decks"

    id: Mapped[UUID] = mapped_column(primary_key=True, server_default=func.uuid_generate_v4())
    name: Mapped[str] = mapped_column(String(255), index=True)
    description: Mapped[str | None] = mapped_column(Text)
    level: Mapped[DeckLevel] = mapped_column(nullable=False, index=True)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)

    cards: Mapped[List["Card"]] = relationship(
        back_populates="deck",
        lazy="selectin",
        cascade="all, delete-orphan"
    )
```

**Card model structure:**
```python
class Card(Base, TimestampMixin):
    __tablename__ = "cards"

    id: Mapped[UUID] = mapped_column(primary_key=True, server_default=func.uuid_generate_v4())
    deck_id: Mapped[UUID] = mapped_column(ForeignKey("decks.id", ondelete="CASCADE"), index=True)
    front_text: Mapped[str] = mapped_column(Text)  # Greek
    back_text: Mapped[str] = mapped_column(Text)  # English
    example_sentence: Mapped[str | None] = mapped_column(Text)
    pronunciation: Mapped[str | None] = mapped_column(String(255))
    difficulty: Mapped[CardDifficulty] = mapped_column(default=CardDifficulty.MEDIUM, index=True)
    order_index: Mapped[int] = mapped_column(Integer, default=0)
```

### Step 4: Implement Progress Tracking Models (40 minutes)

**Models:**
1. `UserDeckProgress` - Per-deck progress
2. `CardStatistics` - SM-2 algorithm data
3. `Review` - Review history

**Key features:**
- Unique constraints: (user_id, deck_id), (user_id, card_id)
- SM-2 fields: easiness_factor, interval, repetitions, next_review_date
- Strategic indexes for "get due cards" queries
- Review history for analytics

**CardStatistics model (SM-2 algorithm):**
```python
class CardStatistics(Base, TimestampMixin):
    __tablename__ = "card_statistics"
    __table_args__ = (UniqueConstraint("user_id", "card_id", name="uq_user_card"),)

    id: Mapped[UUID] = mapped_column(primary_key=True, server_default=func.uuid_generate_v4())
    user_id: Mapped[UUID] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), index=True)
    card_id: Mapped[UUID] = mapped_column(ForeignKey("cards.id", ondelete="CASCADE"), index=True)

    # SM-2 Algorithm fields
    easiness_factor: Mapped[float] = mapped_column(Float, default=2.5)
    interval: Mapped[int] = mapped_column(Integer, default=0)  # Days
    repetitions: Mapped[int] = mapped_column(Integer, default=0)
    next_review_date: Mapped[date] = mapped_column(Date, index=True, server_default=func.current_date())
    status: Mapped[CardStatus] = mapped_column(default=CardStatus.NEW, index=True)
```

### Step 5: Update Package Exports (10 minutes)

Update `src/db/__init__.py` to export all models and enums:

```python
from src.db.models import (
    # Enums
    DeckLevel,
    CardDifficulty,
    CardStatus,
    ReviewRating,
    # Models
    User,
    UserSettings,
    RefreshToken,
    Deck,
    Card,
    UserDeckProgress,
    CardStatistics,
    Review,
)
```

### Step 6: Testing & Verification (30 minutes)

**Verification steps:**
1. ✅ Create test script to verify model imports
2. ✅ Test enum values
3. ✅ Test model structure (columns, types)
4. ✅ Test relationships
5. ✅ Test unique constraints
6. ✅ Verify backend server starts with models loaded
7. ✅ Test database connection with models

---

## Completion Summary

### ✅ Implementation Completed (2025-11-20)

**Files Created:**
1. **src/db/models.py** (498 lines)
   - 8 SQLAlchemy models with comprehensive relationships
   - 4 enums for type safety
   - Complete documentation and type hints
   - All relationships use `lazy="selectin"` for async compatibility

2. **scripts/test_models.py** (188 lines)
   - Comprehensive model verification suite
   - Tests for imports, enums, structure, relationships, constraints

**Files Modified:**
3. **src/db/__init__.py**
   - Added exports for all 8 models and 4 enums
   - Clean package interface with organized sections

### Models Implemented

**User Management (3 models):**
- ✅ `User` - Authentication with email/password and Google OAuth
  - 10 columns including email, password_hash, google_id
  - 5 relationships (settings, refresh_tokens, deck_progress, card_statistics, reviews)

- ✅ `UserSettings` - User preferences (daily_goal, email_notifications)
  - One-to-one relationship with User

- ✅ `RefreshToken` - JWT refresh token management
  - Token expiration tracking
  - Indexed on token and expires_at

**Content (2 models):**
- ✅ `Deck` - Greek vocabulary decks
  - 7 columns with DeckLevel enum (A1-C2)
  - 2 relationships (cards, user_progress)

- ✅ `Card` - Individual flashcards
  - 10 columns with Greek/English content
  - CardDifficulty enum
  - 3 relationships (deck, statistics, reviews)

**Progress Tracking (3 models):**
- ✅ `UserDeckProgress` - Per-deck progress tracking
  - Unique constraint on (user_id, deck_id)
  - Tracks cards_studied and cards_mastered

- ✅ `CardStatistics` - SM-2 spaced repetition algorithm
  - 10 columns including SM-2 fields (easiness_factor, interval, repetitions)
  - Unique constraint on (user_id, card_id)
  - Indexed next_review_date for efficient due card queries
  - CardStatus enum (new, learning, review, mastered)

- ✅ `Review` - Review history for analytics
  - ReviewRating enum (0-5 quality ratings)
  - Tracks quality, time_taken, reviewed_at

**Enums (4 types):**
- ✅ `DeckLevel` - CEFR levels (A1, A2, B1, B2, C1, C2)
- ✅ `CardDifficulty` - easy, medium, hard
- ✅ `CardStatus` - new, learning, review, mastered
- ✅ `ReviewRating` - 0 (blackout) to 5 (perfect)

### Verification Results

All tests passed successfully:

```
✓ All models imported successfully
✓ DeckLevel has all CEFR levels
✓ CardDifficulty has all difficulty levels
✓ CardStatus has all SM-2 statuses
✓ ReviewRating has all quality ratings (0-5)
✓ User model has 10 columns
✓ Deck model has 7 columns
✓ Card model has 10 columns
✓ CardStatistics model has 10 columns (including SM-2 fields)
✓ User has 5 relationships
✓ Deck has 2 relationships
✓ Card has 3 relationships
✓ UserDeckProgress has unique constraint (user_id, deck_id)
✓ CardStatistics has unique constraint (user_id, card_id)

Models verified: 8
Enums verified: 4
```

### Backend Server Status

- ✅ Server running on http://localhost:8000
- ✅ Database connection successful
- ✅ PostgreSQL 16 Docker container operational
- ✅ All models loading without errors
- ✅ Health endpoint responding: `{"status":"healthy","version":"0.1.0","environment":"development"}`

### Key Technical Decisions

1. **UUID Primary Keys**: All models use UUID with server-side generation (`func.uuid_generate_v4()`)
2. **Async Relationships**: All relationships use `lazy="selectin"` for async query compatibility
3. **Indexes**: Strategic indexes on frequently queried fields (email, next_review_date, level, status)
4. **Cascade Deletes**: Proper CASCADE behaviors (delete user → delete all related data)
5. **Type Safety**: Full type hints with `Mapped[]` and proper nullable handling
6. **SM-2 Algorithm**: Complete support with easiness_factor, interval, repetitions, next_review_date
7. **Enums**: Python enums (str/int based) that will map to PostgreSQL enums in migrations

---

## Success Criteria

✅ **All criteria met:**

1. ✅ All 8 models defined with proper SQLAlchemy 2.0 syntax
2. ✅ All 4 enums defined with correct values
3. ✅ UUID primary keys with server-side generation
4. ✅ TimestampMixin applied to all models
5. ✅ Proper relationships with `lazy="selectin"`
6. ✅ Unique constraints on (user_id, deck_id) and (user_id, card_id)
7. ✅ Indexes on frequently queried fields
8. ✅ CASCADE delete behaviors configured
9. ✅ Models import without errors
10. ✅ Backend server starts successfully
11. ✅ Database connection works with models loaded
12. ✅ Test suite passes all verifications

---

## Next Steps

The next subtask is **02.03: Configure PostgreSQL Enums** which will:
- Create PostgreSQL enum types using Alembic migrations
- Map Python enums to PostgreSQL enums
- Ensure type safety at the database level

**Estimated time for 02.03**: 20-30 minutes
