# 01.05 Implement Enhanced Health Endpoints - Detailed Execution Plan

**Project**: Learn Greek Easy - DevOps
**Task**: Implement Enhanced Health Endpoints with Kubernetes-Compatible Probes
**Parent**: [01-docker-architecture.md](./01-docker-architecture.md)
**Created**: 2025-12-02
**Status**: ✅ COMPLETED (2025-12-02)

---

## Table of Contents

1. [Objective](#objective)
2. [Prerequisites](#prerequisites)
3. [Technical Specifications](#technical-specifications)
4. [Implementation Steps](#implementation-steps)
5. [File Contents](#file-contents)
6. [Validation](#validation)
7. [Troubleshooting](#troubleshooting)
8. [Next Steps](#next-steps)
9. [Execution Checklist](#execution-checklist)

---

## Objective

Implement a comprehensive health check system for the FastAPI backend that provides:

1. **Enhanced Health Endpoint** (`/health`): Detailed status for all dependencies (database, Redis, application)
2. **Liveness Probe** (`/health/live`): Simple check if the application is running (Kubernetes liveness probe)
3. **Readiness Probe** (`/health/ready`): Check if the application is ready to accept traffic (Kubernetes readiness probe)
4. **Configurable Timeouts**: Health check timeouts configurable via environment variables
5. **Proper HTTP Status Codes**: 200 for healthy, 503 for unhealthy
6. **Structured JSON Responses**: Detailed component-level status information

---

## Prerequisites

### Completed Dependencies

| Task | Status | Artifacts |
|------|--------|-----------|
| 01.01 Backend Dockerfile | COMPLETED | `Dockerfile`, `Dockerfile.dev`, `docker-entrypoint.sh` |
| 01.02 Docker Compose Backend | COMPLETED | Updated `docker-compose.yml`, `docker-compose.dev.yml` |
| 01.03 Production Docker Compose | COMPLETED | `docker-compose.yml` (production) |
| 01.04 Redis Service | COMPLETED | Redis service added to both compose files |

### Verified Project Structure

```
learn-greek-easy-backend/
├── src/
│   ├── __init__.py
│   ├── main.py              # Current health endpoint location (to be updated)
│   ├── config.py            # Settings class (needs health check timeout settings)
│   ├── api/
│   │   ├── __init__.py
│   │   └── v1/
│   │       ├── __init__.py
│   │       └── auth.py      # Reference for endpoint patterns
│   ├── core/
│   │   ├── __init__.py
│   │   ├── exceptions.py    # Custom exceptions
│   │   ├── dependencies.py  # Dependency injection patterns
│   │   └── ...
│   ├── db/
│   │   ├── __init__.py
│   │   ├── session.py       # Database session management
│   │   └── ...
│   └── schemas/             # Pydantic schemas (will add health schemas)
├── docker-compose.yml       # Uses /health for backend healthcheck
└── docker-compose.dev.yml   # Uses /health for backend healthcheck
```

### Current Health Endpoint (from main.py)

```python
@app.get("/health")
async def health_check() -> dict:
    """Health check endpoint."""
    return {
        "status": "healthy",
        "version": settings.app_version,
        "environment": settings.app_env,
    }
```

This basic endpoint needs to be enhanced with dependency checks.

### Docker Compose Health Check Configuration (Current)

Both `docker-compose.yml` and `docker-compose.dev.yml` use:
```yaml
healthcheck:
  test: ["CMD", "curl", "--fail", "--silent", "http://localhost:8000/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s
```

The enhanced `/health` endpoint must remain backward-compatible with this configuration.

---

## Technical Specifications

### Endpoint Design

| Endpoint | Purpose | Success Code | Failure Code | Kubernetes Use |
|----------|---------|--------------|--------------|----------------|
| `GET /health` | Comprehensive health with all component details | 200 | 503 | General monitoring |
| `GET /health/live` | Is the process alive? | 200 | 503 | `livenessProbe` |
| `GET /health/ready` | Is the app ready to serve requests? | 200 | 503 | `readinessProbe` |

### Health Check Components

| Component | Check Method | Timeout Default | Critical |
|-----------|-------------|-----------------|----------|
| PostgreSQL | Execute `SELECT 1` | 5 seconds | Yes |
| Redis | Execute `PING` | 3 seconds | No (degraded mode) |
| Application | Memory/uptime stats | N/A | Yes |

### Response Schemas

#### HealthResponse (GET /health)

```json
{
  "status": "healthy" | "unhealthy" | "degraded",
  "version": "0.1.0",
  "environment": "development",
  "timestamp": "2024-12-02T10:30:00Z",
  "uptime_seconds": 3600,
  "checks": {
    "database": {
      "status": "healthy" | "unhealthy",
      "latency_ms": 5.2,
      "message": "Connection successful" | "Error message"
    },
    "redis": {
      "status": "healthy" | "unhealthy",
      "latency_ms": 1.1,
      "message": "PONG received" | "Error message"
    },
    "memory": {
      "status": "healthy" | "warning",
      "used_mb": 128.5,
      "percent": 45.2,
      "message": "Memory usage normal" | "High memory usage"
    }
  }
}
```

#### LivenessResponse (GET /health/live)

```json
{
  "status": "alive",
  "timestamp": "2024-12-02T10:30:00Z"
}
```

#### ReadinessResponse (GET /health/ready)

```json
{
  "status": "ready" | "not_ready",
  "timestamp": "2024-12-02T10:30:00Z",
  "checks": {
    "database": true,
    "redis": true
  }
}
```

### Configuration Settings

New settings to add to `src/config.py`:

| Setting | Environment Variable | Default | Description |
|---------|---------------------|---------|-------------|
| `health_check_db_timeout` | `HEALTH_CHECK_DB_TIMEOUT` | 5 | Database check timeout (seconds) |
| `health_check_redis_timeout` | `HEALTH_CHECK_REDIS_TIMEOUT` | 3 | Redis check timeout (seconds) |
| `health_check_memory_warning_percent` | `HEALTH_CHECK_MEMORY_WARNING_PERCENT` | 80 | Memory warning threshold (%) |

### Health Check Logic

```
┌─────────────────────────────────────────────────────────────────┐
│                    Health Check Flow                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  GET /health                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Check DB     │  │ Check Redis  │  │ Check Memory │          │
│  │ (parallel)   │  │ (parallel)   │  │ (parallel)   │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                  │                  │                  │
│         └──────────────────┼──────────────────┘                  │
│                            │                                     │
│                   ┌────────▼────────┐                           │
│                   │ Aggregate Results│                           │
│                   └────────┬────────┘                           │
│                            │                                     │
│            ┌───────────────┼───────────────┐                    │
│            │               │               │                    │
│            ▼               ▼               ▼                    │
│     ┌──────────┐    ┌──────────┐    ┌──────────┐              │
│     │ All OK   │    │ Non-crit │    │ Critical │              │
│     │ 200      │    │ Failed   │    │ Failed   │              │
│     │ healthy  │    │ 200      │    │ 503      │              │
│     │          │    │ degraded │    │ unhealthy│              │
│     └──────────┘    └──────────┘    └──────────┘              │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  GET /health/live                                                │
│  ┌──────────────────────┐                                       │
│  │ Return immediately   │ → 200 OK                              │
│  │ (process is running) │                                       │
│  └──────────────────────┘                                       │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  GET /health/ready                                               │
│  ┌──────────────┐  ┌──────────────┐                            │
│  │ Check DB     │  │ Check Redis  │                            │
│  │ (parallel)   │  │ (parallel)   │                            │
│  └──────┬───────┘  └──────┬───────┘                            │
│         │                  │                                     │
│         └────────┬─────────┘                                     │
│                  │                                               │
│         ┌────────▼────────┐                                     │
│         │ Both OK?        │                                     │
│         └────────┬────────┘                                     │
│                  │                                               │
│         ┌────────┴────────┐                                     │
│         │                 │                                     │
│         ▼                 ▼                                     │
│     ┌──────┐         ┌──────┐                                  │
│     │ Yes  │         │ No   │                                  │
│     │ 200  │         │ 503  │                                  │
│     │ready │         │not_  │                                  │
│     │      │         │ready │                                  │
│     └──────┘         └──────┘                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Redis Connection Management

Since the current `main.py` has TODOs for Redis initialization:
```python
# TODO (Task 11): Initialize Redis connection
# await init_redis()
```

This task will also implement basic Redis connection management:
- Create `src/core/redis.py` for Redis client management
- Add Redis initialization to lifespan
- Provide async Redis client for health checks

---

## Implementation Steps

### Step 1: Add Health Check Settings to config.py

Add new health check configuration options to the `Settings` class in `src/config.py`.

### Step 2: Create Health Check Schemas

Create `src/schemas/health.py` with Pydantic models for health check responses.

### Step 3: Create Redis Client Manager

Create `src/core/redis.py` with:
- Redis connection initialization
- Connection pool management
- Health check method
- Graceful shutdown

### Step 4: Create Health Check Service

Create `src/services/health_service.py` with:
- Database health check function
- Redis health check function
- Memory/uptime stats function
- Aggregation logic

### Step 5: Create Health Check Router

Create `src/api/health.py` (root-level, not in v1) with:
- `/health` - Comprehensive health check
- `/health/live` - Liveness probe
- `/health/ready` - Readiness probe

### Step 6: Update main.py

- Remove old `/health` endpoint
- Include new health router
- Add Redis initialization to lifespan
- Add Redis cleanup to shutdown

### Step 7: Test All Endpoints

Verify all endpoints work correctly with various scenarios.

---

## File Contents

### src/config.py (Additions Only)

Add the following to the existing `Settings` class:

```python
    # =========================================================================
    # Health Checks
    # =========================================================================
    health_check_db_timeout: int = Field(
        default=5,
        description="Database health check timeout in seconds",
    )
    health_check_redis_timeout: int = Field(
        default=3,
        description="Redis health check timeout in seconds",
    )
    health_check_memory_warning_percent: int = Field(
        default=80,
        description="Memory usage warning threshold percentage",
    )
```

### src/schemas/health.py (New File)

```python
"""Health check response schemas."""

from datetime import datetime
from enum import Enum
from typing import Dict, Optional

from pydantic import BaseModel, Field


class HealthStatus(str, Enum):
    """Health status values."""

    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    DEGRADED = "degraded"


class ComponentStatus(str, Enum):
    """Individual component status values."""

    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    WARNING = "warning"


class ComponentHealth(BaseModel):
    """Health status of a single component."""

    status: ComponentStatus
    latency_ms: Optional[float] = Field(
        default=None,
        description="Response time in milliseconds",
    )
    message: str = Field(description="Human-readable status message")


class MemoryHealth(BaseModel):
    """Memory health information."""

    status: ComponentStatus
    used_mb: float = Field(description="Memory used in megabytes")
    percent: float = Field(description="Memory usage percentage")
    message: str = Field(description="Human-readable status message")


class HealthChecks(BaseModel):
    """Collection of component health checks."""

    database: ComponentHealth
    redis: ComponentHealth
    memory: MemoryHealth


class HealthResponse(BaseModel):
    """Full health check response."""

    status: HealthStatus = Field(description="Overall health status")
    version: str = Field(description="Application version")
    environment: str = Field(description="Current environment")
    timestamp: datetime = Field(description="Health check timestamp")
    uptime_seconds: float = Field(description="Application uptime in seconds")
    checks: HealthChecks = Field(description="Individual component checks")

    model_config = {"json_schema_extra": {"example": {
        "status": "healthy",
        "version": "0.1.0",
        "environment": "development",
        "timestamp": "2024-12-02T10:30:00Z",
        "uptime_seconds": 3600,
        "checks": {
            "database": {
                "status": "healthy",
                "latency_ms": 5.2,
                "message": "Connection successful"
            },
            "redis": {
                "status": "healthy",
                "latency_ms": 1.1,
                "message": "PONG received"
            },
            "memory": {
                "status": "healthy",
                "used_mb": 128.5,
                "percent": 45.2,
                "message": "Memory usage normal"
            }
        }
    }}}


class LivenessResponse(BaseModel):
    """Liveness probe response."""

    status: str = Field(default="alive", description="Liveness status")
    timestamp: datetime = Field(description="Check timestamp")

    model_config = {"json_schema_extra": {"example": {
        "status": "alive",
        "timestamp": "2024-12-02T10:30:00Z"
    }}}


class ReadinessChecks(BaseModel):
    """Readiness check results."""

    database: bool = Field(description="Database ready")
    redis: bool = Field(description="Redis ready")


class ReadinessResponse(BaseModel):
    """Readiness probe response."""

    status: str = Field(description="Readiness status: ready or not_ready")
    timestamp: datetime = Field(description="Check timestamp")
    checks: ReadinessChecks = Field(description="Component readiness")

    model_config = {"json_schema_extra": {"example": {
        "status": "ready",
        "timestamp": "2024-12-02T10:30:00Z",
        "checks": {
            "database": True,
            "redis": True
        }
    }}}
```

### src/core/redis.py (New File)

```python
"""Redis client management with connection pooling."""

import asyncio
import logging
from typing import Optional

import redis.asyncio as redis
from redis.asyncio import ConnectionPool, Redis
from redis.exceptions import ConnectionError, TimeoutError

from src.config import settings

logger = logging.getLogger(__name__)

# Global Redis client instance
_redis_client: Optional[Redis] = None
_connection_pool: Optional[ConnectionPool] = None


async def init_redis() -> None:
    """
    Initialize Redis connection pool on application startup.

    Should be called in FastAPI lifespan startup event.
    """
    global _redis_client, _connection_pool

    if _redis_client is not None:
        logger.warning("Redis client already initialized")
        return

    logger.info("Initializing Redis connection...")

    try:
        # Create connection pool
        _connection_pool = ConnectionPool.from_url(
            settings.redis_url,
            max_connections=10,
            decode_responses=True,
            socket_timeout=settings.health_check_redis_timeout,
            socket_connect_timeout=settings.health_check_redis_timeout,
        )

        # Create client with pool
        _redis_client = Redis(connection_pool=_connection_pool)

        # Test connection
        await _redis_client.ping()
        logger.info("Redis connection successful")

    except Exception as e:
        logger.warning(f"Redis connection failed: {e}. Application will run in degraded mode.")
        _redis_client = None
        _connection_pool = None


async def close_redis() -> None:
    """
    Close Redis connection on application shutdown.

    Should be called in FastAPI lifespan shutdown event.
    """
    global _redis_client, _connection_pool

    if _redis_client is None:
        return

    logger.info("Closing Redis connection...")

    try:
        await _redis_client.aclose()
        if _connection_pool:
            await _connection_pool.disconnect()
    except Exception as e:
        logger.error(f"Error closing Redis connection: {e}")
    finally:
        _redis_client = None
        _connection_pool = None

    logger.info("Redis connection closed")


def get_redis() -> Optional[Redis]:
    """
    Get the global Redis client instance.

    Returns:
        Redis client or None if not initialized/available
    """
    return _redis_client


async def check_redis_health(timeout: Optional[float] = None) -> tuple[bool, float, str]:
    """
    Check Redis connection health.

    Args:
        timeout: Optional timeout override in seconds

    Returns:
        Tuple of (is_healthy, latency_ms, message)
    """
    if _redis_client is None:
        return False, 0.0, "Redis client not initialized"

    check_timeout = timeout or settings.health_check_redis_timeout

    try:
        start_time = asyncio.get_event_loop().time()

        # Use asyncio.wait_for for timeout control
        await asyncio.wait_for(
            _redis_client.ping(),
            timeout=check_timeout,
        )

        latency_ms = (asyncio.get_event_loop().time() - start_time) * 1000

        return True, latency_ms, "PONG received"

    except asyncio.TimeoutError:
        return False, 0.0, f"Connection timeout after {check_timeout}s"

    except ConnectionError as e:
        return False, 0.0, f"Connection error: {str(e)}"

    except TimeoutError as e:
        return False, 0.0, f"Timeout error: {str(e)}"

    except Exception as e:
        return False, 0.0, f"Unexpected error: {str(e)}"
```

### src/services/health_service.py (New File)

```python
"""Health check service with component health verification."""

import asyncio
import logging
import os
import time
from datetime import datetime, timezone
from typing import Optional

import psutil
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import settings
from src.core.redis import check_redis_health
from src.db.session import get_session_factory
from src.schemas.health import (
    ComponentHealth,
    ComponentStatus,
    HealthChecks,
    HealthResponse,
    HealthStatus,
    LivenessResponse,
    MemoryHealth,
    ReadinessChecks,
    ReadinessResponse,
)

logger = logging.getLogger(__name__)

# Track application start time
_start_time: float = time.time()


def get_uptime_seconds() -> float:
    """Get application uptime in seconds."""
    return time.time() - _start_time


async def check_database_health(timeout: Optional[float] = None) -> ComponentHealth:
    """
    Check PostgreSQL database connectivity.

    Args:
        timeout: Optional timeout override in seconds

    Returns:
        ComponentHealth with database status
    """
    check_timeout = timeout or settings.health_check_db_timeout

    try:
        factory = get_session_factory()
    except RuntimeError:
        return ComponentHealth(
            status=ComponentStatus.UNHEALTHY,
            latency_ms=None,
            message="Database not initialized",
        )

    try:
        start_time = asyncio.get_event_loop().time()

        async with factory() as session:
            # Execute simple query with timeout
            result = await asyncio.wait_for(
                session.execute(text("SELECT 1")),
                timeout=check_timeout,
            )
            result.scalar()

        latency_ms = (asyncio.get_event_loop().time() - start_time) * 1000

        return ComponentHealth(
            status=ComponentStatus.HEALTHY,
            latency_ms=round(latency_ms, 2),
            message="Connection successful",
        )

    except asyncio.TimeoutError:
        return ComponentHealth(
            status=ComponentStatus.UNHEALTHY,
            latency_ms=None,
            message=f"Connection timeout after {check_timeout}s",
        )

    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        return ComponentHealth(
            status=ComponentStatus.UNHEALTHY,
            latency_ms=None,
            message=f"Connection error: {str(e)}",
        )


async def check_redis_health_component(timeout: Optional[float] = None) -> ComponentHealth:
    """
    Check Redis connectivity.

    Args:
        timeout: Optional timeout override in seconds

    Returns:
        ComponentHealth with Redis status
    """
    is_healthy, latency_ms, message = await check_redis_health(timeout)

    return ComponentHealth(
        status=ComponentStatus.HEALTHY if is_healthy else ComponentStatus.UNHEALTHY,
        latency_ms=round(latency_ms, 2) if latency_ms > 0 else None,
        message=message,
    )


def check_memory_health() -> MemoryHealth:
    """
    Check application memory usage.

    Returns:
        MemoryHealth with memory statistics
    """
    try:
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        memory_percent = process.memory_percent()

        used_mb = memory_info.rss / (1024 * 1024)

        if memory_percent >= settings.health_check_memory_warning_percent:
            status = ComponentStatus.WARNING
            message = f"High memory usage: {memory_percent:.1f}%"
        else:
            status = ComponentStatus.HEALTHY
            message = "Memory usage normal"

        return MemoryHealth(
            status=status,
            used_mb=round(used_mb, 2),
            percent=round(memory_percent, 2),
            message=message,
        )

    except Exception as e:
        logger.error(f"Memory health check failed: {e}")
        return MemoryHealth(
            status=ComponentStatus.WARNING,
            used_mb=0.0,
            percent=0.0,
            message=f"Unable to check memory: {str(e)}",
        )


async def get_health_status() -> tuple[HealthResponse, int]:
    """
    Perform comprehensive health check of all components.

    Returns:
        Tuple of (HealthResponse, HTTP status code)
    """
    # Run all checks in parallel
    db_check, redis_check = await asyncio.gather(
        check_database_health(),
        check_redis_health_component(),
        return_exceptions=True,
    )

    # Handle exceptions from gather
    if isinstance(db_check, Exception):
        logger.error(f"Database health check exception: {db_check}")
        db_check = ComponentHealth(
            status=ComponentStatus.UNHEALTHY,
            latency_ms=None,
            message=f"Check failed: {str(db_check)}",
        )

    if isinstance(redis_check, Exception):
        logger.error(f"Redis health check exception: {redis_check}")
        redis_check = ComponentHealth(
            status=ComponentStatus.UNHEALTHY,
            latency_ms=None,
            message=f"Check failed: {str(redis_check)}",
        )

    # Get memory status (synchronous)
    memory_check = check_memory_health()

    # Determine overall status
    # Database is critical - if unhealthy, system is unhealthy
    # Redis is non-critical - if unhealthy, system is degraded
    # Memory warning doesn't affect overall status

    if db_check.status == ComponentStatus.UNHEALTHY:
        overall_status = HealthStatus.UNHEALTHY
        http_status = 503
    elif redis_check.status == ComponentStatus.UNHEALTHY:
        overall_status = HealthStatus.DEGRADED
        http_status = 200  # Degraded is still "okay" for basic health checks
    else:
        overall_status = HealthStatus.HEALTHY
        http_status = 200

    response = HealthResponse(
        status=overall_status,
        version=settings.app_version,
        environment=settings.app_env,
        timestamp=datetime.now(timezone.utc),
        uptime_seconds=round(get_uptime_seconds(), 2),
        checks=HealthChecks(
            database=db_check,
            redis=redis_check,
            memory=memory_check,
        ),
    )

    return response, http_status


async def get_liveness_status() -> LivenessResponse:
    """
    Get liveness probe status.

    This is a simple check that returns immediately if the process is running.
    No dependency checks are performed.

    Returns:
        LivenessResponse
    """
    return LivenessResponse(
        status="alive",
        timestamp=datetime.now(timezone.utc),
    )


async def get_readiness_status() -> tuple[ReadinessResponse, int]:
    """
    Get readiness probe status.

    Checks if the application is ready to accept traffic by verifying
    all critical dependencies are available.

    Returns:
        Tuple of (ReadinessResponse, HTTP status code)
    """
    # Check both database and Redis in parallel
    db_check, redis_check = await asyncio.gather(
        check_database_health(),
        check_redis_health_component(),
        return_exceptions=True,
    )

    # Determine readiness
    db_ready = (
        isinstance(db_check, ComponentHealth)
        and db_check.status == ComponentStatus.HEALTHY
    )
    redis_ready = (
        isinstance(redis_check, ComponentHealth)
        and redis_check.status == ComponentStatus.HEALTHY
    )

    # Both must be ready for the app to be ready
    is_ready = db_ready and redis_ready
    http_status = 200 if is_ready else 503

    response = ReadinessResponse(
        status="ready" if is_ready else "not_ready",
        timestamp=datetime.now(timezone.utc),
        checks=ReadinessChecks(
            database=db_ready,
            redis=redis_ready,
        ),
    )

    return response, http_status
```

### src/api/health.py (New File)

```python
"""Health check API endpoints.

This module provides health check endpoints for monitoring and
Kubernetes probes (liveness and readiness).
"""

import logging

from fastapi import APIRouter, Response, status

from src.schemas.health import HealthResponse, LivenessResponse, ReadinessResponse
from src.services.health_service import (
    get_health_status,
    get_liveness_status,
    get_readiness_status,
)

logger = logging.getLogger(__name__)

router = APIRouter(tags=["Health"])


@router.get(
    "/health",
    response_model=HealthResponse,
    summary="Comprehensive health check",
    responses={
        200: {
            "description": "Application is healthy or degraded",
            "content": {
                "application/json": {
                    "examples": {
                        "healthy": {
                            "summary": "All systems operational",
                            "value": {
                                "status": "healthy",
                                "version": "0.1.0",
                                "environment": "production",
                                "timestamp": "2024-12-02T10:30:00Z",
                                "uptime_seconds": 3600,
                                "checks": {
                                    "database": {
                                        "status": "healthy",
                                        "latency_ms": 5.2,
                                        "message": "Connection successful"
                                    },
                                    "redis": {
                                        "status": "healthy",
                                        "latency_ms": 1.1,
                                        "message": "PONG received"
                                    },
                                    "memory": {
                                        "status": "healthy",
                                        "used_mb": 128.5,
                                        "percent": 45.2,
                                        "message": "Memory usage normal"
                                    }
                                }
                            }
                        },
                        "degraded": {
                            "summary": "Non-critical service unavailable",
                            "value": {
                                "status": "degraded",
                                "version": "0.1.0",
                                "environment": "production",
                                "timestamp": "2024-12-02T10:30:00Z",
                                "uptime_seconds": 3600,
                                "checks": {
                                    "database": {
                                        "status": "healthy",
                                        "latency_ms": 5.2,
                                        "message": "Connection successful"
                                    },
                                    "redis": {
                                        "status": "unhealthy",
                                        "latency_ms": None,
                                        "message": "Connection timeout after 3s"
                                    },
                                    "memory": {
                                        "status": "healthy",
                                        "used_mb": 128.5,
                                        "percent": 45.2,
                                        "message": "Memory usage normal"
                                    }
                                }
                            }
                        }
                    }
                }
            },
        },
        503: {
            "description": "Critical service unavailable",
            "content": {
                "application/json": {
                    "example": {
                        "status": "unhealthy",
                        "version": "0.1.0",
                        "environment": "production",
                        "timestamp": "2024-12-02T10:30:00Z",
                        "uptime_seconds": 3600,
                        "checks": {
                            "database": {
                                "status": "unhealthy",
                                "latency_ms": None,
                                "message": "Connection error: Connection refused"
                            },
                            "redis": {
                                "status": "healthy",
                                "latency_ms": 1.1,
                                "message": "PONG received"
                            },
                            "memory": {
                                "status": "healthy",
                                "used_mb": 128.5,
                                "percent": 45.2,
                                "message": "Memory usage normal"
                            }
                        }
                    }
                }
            },
        },
    },
)
async def health_check(response: Response) -> HealthResponse:
    """Perform comprehensive health check of all application components.

    This endpoint checks:
    - **Database**: PostgreSQL connectivity via simple query
    - **Redis**: Cache connectivity via PING command
    - **Memory**: Application memory usage statistics

    Status meanings:
    - **healthy**: All components operational
    - **degraded**: Non-critical components unavailable (Redis)
    - **unhealthy**: Critical components unavailable (Database)

    Returns:
        HealthResponse with detailed component status
    """
    health_response, http_status = await get_health_status()
    response.status_code = http_status
    return health_response


@router.get(
    "/health/live",
    response_model=LivenessResponse,
    summary="Liveness probe",
    responses={
        200: {
            "description": "Application process is alive",
            "content": {
                "application/json": {
                    "example": {
                        "status": "alive",
                        "timestamp": "2024-12-02T10:30:00Z"
                    }
                }
            },
        },
    },
)
async def liveness_check() -> LivenessResponse:
    """Kubernetes liveness probe endpoint.

    Returns 200 if the application process is running. This check does NOT
    verify dependencies - it only confirms the FastAPI process is alive.

    Use this for Kubernetes livenessProbe to detect deadlocks or unresponsive
    processes that should be restarted.

    Returns:
        LivenessResponse with alive status
    """
    return await get_liveness_status()


@router.get(
    "/health/ready",
    response_model=ReadinessResponse,
    summary="Readiness probe",
    responses={
        200: {
            "description": "Application is ready to accept traffic",
            "content": {
                "application/json": {
                    "example": {
                        "status": "ready",
                        "timestamp": "2024-12-02T10:30:00Z",
                        "checks": {
                            "database": True,
                            "redis": True
                        }
                    }
                }
            },
        },
        503: {
            "description": "Application is not ready",
            "content": {
                "application/json": {
                    "example": {
                        "status": "not_ready",
                        "timestamp": "2024-12-02T10:30:00Z",
                        "checks": {
                            "database": False,
                            "redis": True
                        }
                    }
                }
            },
        },
    },
)
async def readiness_check(response: Response) -> ReadinessResponse:
    """Kubernetes readiness probe endpoint.

    Returns 200 if the application is ready to accept traffic, meaning all
    dependencies (database, Redis) are available.

    Use this for Kubernetes readinessProbe to prevent routing traffic to
    pods that aren't ready to handle requests.

    Returns:
        ReadinessResponse with ready/not_ready status
    """
    readiness_response, http_status = await get_readiness_status()
    response.status_code = http_status
    return readiness_response
```

### src/main.py (Updated)

Replace the existing health endpoint and add Redis initialization. Changes marked with comments:

```python
"""FastAPI application entry point."""

import logging
from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI, Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.responses import JSONResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

from src.api.v1 import auth_router
from src.api.health import router as health_router  # NEW: Import health router
from src.config import settings
from src.core.exceptions import BaseAPIException
from src.core.logging import setup_logging
from src.core.redis import close_redis, init_redis  # NEW: Import Redis functions
from src.db import close_db, init_db
from src.middleware.auth import AuthLoggingMiddleware

# Setup logging
setup_logging()
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan manager."""
    # Startup
    logger.info("Starting Learn Greek Easy API", extra={"version": settings.app_version})

    # Initialize database connection
    await init_db()

    # Initialize Redis connection (NEW)
    await init_redis()

    yield

    # Shutdown
    logger.info("Shutting down Learn Greek Easy API")

    # Close Redis connection (NEW)
    await close_redis()

    # Close database connection
    await close_db()


# Create FastAPI application
app = FastAPI(
    title=settings.app_name,
    description="Backend API for Greek language learning with spaced repetition",
    version=settings.app_version,
    docs_url="/docs" if settings.debug else None,
    redoc_url="/redoc" if settings.debug else None,
    openapi_url="/openapi.json" if settings.debug else None,
    lifespan=lifespan,
)

# ============================================================================
# Middleware
# ============================================================================

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=settings.cors_allow_credentials,
    allow_methods=settings.cors_allow_methods,
    allow_headers=settings.cors_allow_headers,
)

# Trusted host middleware (production only)
if settings.is_production:
    app.add_middleware(
        TrustedHostMiddleware,
        allowed_hosts=["learngreekeasy.com", "*.learngreekeasy.com"],
    )

# Auth logging middleware for security monitoring
app.add_middleware(AuthLoggingMiddleware)

# TODO (Task 4): Add additional custom middleware
# - Rate limiting
# - Error handling

# ============================================================================
# Exception Handlers
# ============================================================================


@app.exception_handler(BaseAPIException)
async def base_api_exception_handler(
    request: Request,
    exc: BaseAPIException,
) -> JSONResponse:
    """Handle custom API exceptions."""
    logger.error(
        f"API Exception: {exc.error_code}",
        extra={
            "error_code": exc.error_code,
            "detail": exc.detail,
            "path": request.url.path,
            "method": request.method,
        },
    )

    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "error": {
                "code": exc.error_code,
                "message": exc.detail,
                "extra": exc.extra,
            },
        },
        headers=exc.headers,
    )


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError,
) -> JSONResponse:
    """Handle Pydantic validation errors."""
    logger.warning(
        "Validation error",
        extra={
            "errors": exc.errors(),
            "path": request.url.path,
            "method": request.method,
        },
    )

    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "success": False,
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Request validation failed",
                "details": exc.errors(),
            },
        },
    )


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(
    request: Request,
    exc: StarletteHTTPException,
) -> JSONResponse:
    """Handle HTTP exceptions."""
    logger.error(
        f"HTTP {exc.status_code} error",
        extra={
            "detail": exc.detail,
            "path": request.url.path,
            "method": request.method,
        },
    )

    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "error": {
                "code": f"HTTP_{exc.status_code}",
                "message": exc.detail,
            },
        },
    )


@app.exception_handler(Exception)
async def generic_exception_handler(
    request: Request,
    exc: Exception,
) -> JSONResponse:
    """Handle unhandled exceptions."""
    logger.exception(
        "Unhandled exception",
        extra={
            "path": request.url.path,
            "method": request.method,
        },
    )

    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "success": False,
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": "An unexpected error occurred",
            },
        },
    )


# ============================================================================
# Routes
# ============================================================================


@app.get("/")
async def root() -> dict:
    """Root endpoint - API information."""
    return {
        "name": settings.app_name,
        "version": settings.app_version,
        "environment": settings.app_env,
        "docs": "/docs" if settings.debug else None,
        "health": "/health",
        "api": settings.api_v1_prefix,
    }


# REMOVED: Old /health endpoint - now handled by health router


@app.get(f"{settings.api_v1_prefix}/status")
async def api_status() -> dict:
    """API status endpoint with detailed information."""
    return {
        "api_version": "v1",
        "app_version": settings.app_version,
        "environment": settings.app_env,
        "features": {
            "google_oauth": settings.feature_google_oauth,
            "email_notifications": settings.feature_email_notifications,
            "rate_limiting": settings.feature_rate_limiting,
            "background_tasks": settings.feature_background_tasks,
        },
    }


# Debug endpoint (development only)
if settings.debug:

    @app.get("/debug/settings")
    async def debug_settings() -> dict:
        """Debug endpoint to view current settings."""
        return {
            "app": {
                "name": settings.app_name,
                "version": settings.app_version,
                "env": settings.app_env,
                "debug": settings.debug,
            },
            "cors": {
                "origins": settings.cors_origins,
                "credentials": settings.cors_allow_credentials,
            },
            "features": {
                "google_oauth": settings.feature_google_oauth,
                "email_notifications": settings.feature_email_notifications,
                "rate_limiting": settings.feature_rate_limiting,
                "background_tasks": settings.feature_background_tasks,
            },
        }


# Include health check routes (NEW)
app.include_router(health_router)

# Include authentication routes
app.include_router(auth_router)

# TODO (Task 5): Include deck routes
# app.include_router(deck_router, prefix=f"{settings.api_v1_prefix}/decks", tags=["decks"])

# TODO (Task 6): Include card routes
# app.include_router(card_router, prefix=f"{settings.api_v1_prefix}/cards", tags=["cards"])

# TODO (Task 7): Include review routes
# app.include_router(review_router, prefix=f"{settings.api_v1_prefix}/reviews", tags=["reviews"])

# TODO (Task 8): Include progress routes
# app.include_router(progress_router, prefix=f"{settings.api_v1_prefix}/progress", tags=["progress"])


# ============================================================================
# Main (for running with python src/main.py)
# ============================================================================

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "src.main:app",
        host=settings.host,
        port=settings.port,
        reload=settings.reload,
        log_level=settings.log_level.lower(),
    )
```

### pyproject.toml (Additions)

Add `psutil` dependency for memory monitoring:

```toml
# Add to [tool.poetry.dependencies] section
psutil = "^5.9.0"
```

---

## Validation

### Pre-Flight Checklist

- [ ] All prerequisite tasks (01.01-01.04) completed
- [ ] Docker Compose files have backend healthcheck using `/health`
- [ ] Backend starts successfully with current configuration
- [ ] PostgreSQL and Redis containers running and healthy

### Build Validation

```bash
# Navigate to backend directory
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend

# Install new dependency
/Users/samosipov/.local/bin/poetry add psutil

# Verify no import errors
/Users/samosipov/.local/bin/poetry run python -c "from src.main import app; print('Import successful')"
```

### Endpoint Validation

```bash
# Start all services
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose -f docker-compose.dev.yml up -d

# Wait for services to be healthy
sleep 45

# Test comprehensive health endpoint
curl -s http://localhost:8000/health | jq

# Expected output (healthy):
# {
#   "status": "healthy",
#   "version": "0.1.0",
#   "environment": "development",
#   "timestamp": "...",
#   "uptime_seconds": ...,
#   "checks": {
#     "database": { "status": "healthy", "latency_ms": ..., "message": "Connection successful" },
#     "redis": { "status": "healthy", "latency_ms": ..., "message": "PONG received" },
#     "memory": { "status": "healthy", "used_mb": ..., "percent": ..., "message": "Memory usage normal" }
#   }
# }

# Test liveness probe
curl -s http://localhost:8000/health/live | jq

# Expected output:
# {
#   "status": "alive",
#   "timestamp": "..."
# }

# Test readiness probe
curl -s http://localhost:8000/health/ready | jq

# Expected output (ready):
# {
#   "status": "ready",
#   "timestamp": "...",
#   "checks": { "database": true, "redis": true }
# }
```

### HTTP Status Code Validation

```bash
# Check status code for healthy response
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health
# Expected: 200

curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health/live
# Expected: 200

curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health/ready
# Expected: 200
```

### Failure Scenario Testing

```bash
# Test database failure (stop postgres)
docker stop learn-greek-postgres-dev

# Check health endpoint - should return 503
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health
# Expected: 503

curl -s http://localhost:8000/health | jq '.status'
# Expected: "unhealthy"

# Readiness should also fail
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health/ready
# Expected: 503

# Liveness should still succeed (process is alive)
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health/live
# Expected: 200

# Restart postgres
docker start learn-greek-postgres-dev

# Test Redis failure (stop redis)
docker stop learn-greek-redis-dev

# Check health endpoint - should return 200 with degraded status
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health
# Expected: 200 (degraded is still 200)

curl -s http://localhost:8000/health | jq '.status'
# Expected: "degraded"

# Restart redis
docker start learn-greek-redis-dev
```

### Docker Compose Integration Validation

```bash
# Verify Docker healthcheck still works with new endpoint
docker inspect learn-greek-backend-dev --format='{{.State.Health.Status}}'
# Expected: healthy

# View health check logs
docker inspect learn-greek-backend-dev --format='{{json .State.Health}}' | jq
```

### Unit Test Validation (Optional)

```bash
# Run backend tests
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/ -v -k "health" --tb=short
```

### Complete Validation Checklist

- [ ] `poetry add psutil` succeeds
- [ ] `python -c "from src.main import app"` succeeds
- [ ] `GET /health` returns 200 when all services healthy
- [ ] `GET /health` returns 503 when database unhealthy
- [ ] `GET /health` returns 200 with "degraded" when Redis unhealthy
- [ ] `GET /health/live` always returns 200
- [ ] `GET /health/ready` returns 200 when all services healthy
- [ ] `GET /health/ready` returns 503 when any service unhealthy
- [ ] Docker healthcheck passes with new endpoint
- [ ] All existing tests still pass
- [ ] Response schemas match documented format

---

## Troubleshooting

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| `ModuleNotFoundError: No module named 'psutil'` | Dependency not installed | Run `poetry add psutil` |
| Health check always returns unhealthy | Database/Redis not initialized | Check lifespan is calling init functions |
| Timeout errors in health checks | Services slow or unresponsive | Increase timeout settings in config |
| Redis health check fails but Redis is running | Wrong Redis URL | Verify `REDIS_URL` environment variable |
| Memory stats return 0 | psutil permission issue | Check process permissions |
| Docker healthcheck fails | Endpoint path changed | Verify `/health` still works (not just `/health/`) |

### Debug Commands

```bash
# Check application logs
docker logs learn-greek-backend-dev --tail=100

# Test database connectivity manually
docker exec -it learn-greek-backend-dev python -c "
from src.db.session import init_db, close_db, get_session_factory
import asyncio

async def test():
    await init_db()
    factory = get_session_factory()
    async with factory() as session:
        result = await session.execute('SELECT 1')
        print('DB OK:', result.scalar())
    await close_db()

asyncio.run(test())
"

# Test Redis connectivity manually
docker exec -it learn-greek-backend-dev python -c "
import asyncio
import redis.asyncio as redis

async def test():
    r = redis.from_url('redis://redis:6379/0')
    pong = await r.ping()
    print('Redis OK:', pong)
    await r.aclose()

asyncio.run(test())
"

# Check memory usage
docker exec -it learn-greek-backend-dev python -c "
import psutil
import os
process = psutil.Process(os.getpid())
print('Memory MB:', process.memory_info().rss / 1024 / 1024)
print('Memory %:', process.memory_percent())
"

# Verify endpoint registration
docker exec -it learn-greek-backend-dev python -c "
from src.main import app
for route in app.routes:
    if hasattr(route, 'path'):
        print(route.path, route.methods if hasattr(route, 'methods') else '')
"
```

### Recovery Procedures

**Scenario: Health endpoint returns 500 Internal Server Error**
```bash
# 1. Check application logs for the error
docker logs learn-greek-backend-dev --tail=50 | grep -i error

# 2. Restart the backend container
docker-compose -f docker-compose.dev.yml restart backend

# 3. If still failing, rebuild the container
docker-compose -f docker-compose.dev.yml up -d --build backend
```

**Scenario: Timeout errors in health checks**
```bash
# 1. Increase timeout settings in environment
docker-compose -f docker-compose.dev.yml down
# Add to backend environment in docker-compose.dev.yml:
# - HEALTH_CHECK_DB_TIMEOUT=10
# - HEALTH_CHECK_REDIS_TIMEOUT=5
docker-compose -f docker-compose.dev.yml up -d
```

---

## Files Modified/Created Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/config.py` | MODIFY | Add health check timeout settings |
| `src/schemas/health.py` | CREATE | Health check response schemas |
| `src/core/redis.py` | CREATE | Redis client management |
| `src/services/health_service.py` | CREATE | Health check logic |
| `src/api/health.py` | CREATE | Health check endpoints |
| `src/main.py` | MODIFY | Replace old health endpoint, add Redis init |
| `pyproject.toml` | MODIFY | Add psutil dependency |

---

## Next Steps

After completing task 01.05:

1. **Task 01.06**: Update `.env.example` with all environment variables (including new health check settings)
2. **Task 01.07**: Add Celery worker services (uses Redis as broker)
3. **Task 01.08**: Documentation update for CLAUDE.md and README
4. **Future**: Update Kubernetes deployment manifests to use `/health/live` and `/health/ready`

---

## Execution Checklist

### Phase 1: Dependencies

1. [ ] Add `psutil` dependency to `pyproject.toml`
2. [ ] Run `poetry lock` and `poetry install`

### Phase 2: Configuration

3. [ ] Add health check settings to `src/config.py`

### Phase 3: Schemas

4. [ ] Create `src/schemas/health.py` with all response models

### Phase 4: Core Services

5. [ ] Create `src/core/redis.py` with Redis client management
6. [ ] Create `src/services/health_service.py` with health check logic

### Phase 5: API Endpoints

7. [ ] Create `src/api/health.py` with health check router

### Phase 6: Integration

8. [ ] Update `src/main.py`:
   - [ ] Remove old `/health` endpoint
   - [ ] Import and include health router
   - [ ] Import Redis init/close functions
   - [ ] Add Redis init to lifespan startup
   - [ ] Add Redis close to lifespan shutdown

### Phase 7: Validation

9. [ ] Start development environment: `docker-compose -f docker-compose.dev.yml up -d`
10. [ ] Wait for services: `sleep 45`
11. [ ] Test `/health` endpoint returns detailed JSON
12. [ ] Test `/health/live` returns 200
13. [ ] Test `/health/ready` returns 200
14. [ ] Test failure scenarios (stop postgres, stop redis)
15. [ ] Verify Docker healthcheck still passes
16. [ ] Run existing tests to ensure no regressions

### Phase 8: Cleanup

17. [ ] Remove any TODO comments that are now resolved
18. [ ] Update task status to COMPLETED

---

**Ready for executor mode.**
