# 05.02 Session Storage Configuration - Detailed Execution Plan

**Project**: Learn Greek Easy - DevOps
**Task**: Migrate Refresh Token Storage from PostgreSQL to Redis
**Parent**: [05-redis-configuration.md](./05-redis-configuration.md)
**Created**: 2025-12-03
**Updated**: 2025-12-04
**Status**: COMPLETED

> **IMPLEMENTATION NOTE (2025-12-04)**: The PostgreSQL fallback was intentionally removed.
> Redis is now the ONLY storage for refresh token sessions. If Redis is unavailable,
> session operations fail (no silent fallback). Legacy tokens without jti are rejected.

---

## Table of Contents

1. [Objective](#objective)
2. [Problem Statement](#problem-statement)
3. [Prerequisites](#prerequisites)
4. [Technical Specifications](#technical-specifications)
5. [Implementation Steps](#implementation-steps)
6. [File Changes](#file-changes)
7. [Testing Requirements](#testing-requirements)
8. [Validation](#validation)
9. [Rollback Plan](#rollback-plan)
10. [Acceptance Criteria](#acceptance-criteria)
11. [Execution Checklist](#execution-checklist)

---

## Objective

Migrate refresh token storage from PostgreSQL (`refresh_tokens` table) to Redis for:

1. **Faster token validation**: Redis provides sub-millisecond lookups vs 5-10ms for PostgreSQL
2. **Automatic expiration**: Redis TTL handles token cleanup automatically
3. **Reduced database load**: Offload high-frequency session operations from PostgreSQL
4. **Simplified session management**: Native support for token revocation patterns

---

## Problem Statement

### Current Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Current Token Flow                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Login/Register                                                  │
│  ┌────────────────┐     ┌─────────────────────────┐            │
│  │ Generate JWT   │────▶│ INSERT INTO             │            │
│  │ refresh token  │     │ refresh_tokens          │            │
│  └────────────────┘     │ (PostgreSQL)            │            │
│                         └─────────────────────────┘            │
│                                                                  │
│  Token Refresh                                                   │
│  ┌────────────────┐     ┌─────────────────────────┐            │
│  │ Validate token │────▶│ SELECT FROM             │            │
│  │ + rotate       │     │ refresh_tokens          │            │
│  └────────────────┘     │ DELETE + INSERT         │            │
│                         └─────────────────────────┘            │
│                                                                  │
│  Issues:                                                         │
│  - 3 DB operations per token refresh                            │
│  - Manual cleanup of expired tokens required                    │
│  - DB connection overhead for high-frequency ops                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Target Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Target Token Flow                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Login/Register                                                  │
│  ┌────────────────┐     ┌─────────────────────────┐            │
│  │ Generate JWT   │────▶│ SETEX refresh:{user}:{id}│           │
│  │ refresh token  │     │ TTL: 30 days             │           │
│  │ (contains id)  │     │ (Redis)                  │           │
│  └────────────────┘     └─────────────────────────┘            │
│                                                                  │
│  Token Refresh                                                   │
│  ┌────────────────┐     ┌─────────────────────────┐            │
│  │ Validate token │────▶│ GET refresh:{user}:{id} │            │
│  │ + rotate       │     │ DEL + SETEX (atomic)    │            │
│  └────────────────┘     └─────────────────────────┘            │
│                                                                  │
│  Benefits:                                                       │
│  - Sub-millisecond operations                                   │
│  - Automatic TTL expiration (no cleanup jobs)                   │
│  - Atomic operations (MULTI/EXEC)                               │
│  - Reduced PostgreSQL load                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

### Completed Dependencies

| Task | Status | Artifacts |
|------|--------|-----------|
| 05.01 Redis Container Setup | COMPLETE | Docker containers configured |
| 05.04 Redis Connection Pooling | COMPLETE | `src/core/redis.py` |
| Health Endpoints | COMPLETE | Redis health check working |

### Verified Project Structure

```
learn-greek-easy-backend/
├── src/
│   ├── core/
│   │   ├── redis.py           # Redis client (EXISTS)
│   │   ├── security.py        # JWT functions (TO MODIFY)
│   │   └── session.py         # Session service (TO CREATE)
│   ├── db/
│   │   └── models.py          # RefreshToken model (KEEP for migration)
│   ├── services/
│   │   └── auth_service.py    # Auth service (TO MODIFY)
│   ├── repositories/
│   │   └── session.py         # Session repository (TO CREATE)
│   └── config.py              # Settings (TO MODIFY)
```

---

## Technical Specifications

### Redis Key Schema

```
# Individual refresh token
Key:   refresh:{user_id}:{token_id}
Value: JSON { "token": "jwt...", "created_at": "ISO8601", "ip": "..." }
TTL:   30 days (2592000 seconds)

# User's active sessions (for listing/revoking all)
Key:   user_sessions:{user_id}
Value: SET of token_ids
TTL:   30 days (refreshed on each token operation)

# Example:
refresh:550e8400-e29b-41d4-a716-446655440000:abc123 -> {"token": "eyJ...", "created_at": "2024-12-03T10:00:00Z"}
user_sessions:550e8400-e29b-41d4-a716-446655440000 -> {"abc123", "def456", "ghi789"}
```

### Token ID Generation

Instead of relying on PostgreSQL UUIDs, generate short unique IDs for token references:

```python
import secrets

def generate_token_id() -> str:
    """Generate a short unique token identifier (12 chars)."""
    return secrets.token_urlsafe(9)  # 12 characters, URL-safe
```

### JWT Token Structure Update

Add `jti` (JWT ID) claim to refresh tokens:

```python
# Current JWT payload
{
    "sub": "user_id",
    "type": "refresh",
    "exp": timestamp
}

# Updated JWT payload
{
    "sub": "user_id",
    "type": "refresh",
    "jti": "token_id",  # NEW: Unique token identifier
    "exp": timestamp
}
```

### Session Data Structure

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SessionData(BaseModel):
    """Data stored in Redis for each session."""
    token_id: str                    # Unique identifier (jti)
    user_id: str                     # User UUID
    token: str                       # Full JWT refresh token
    created_at: datetime             # When session was created
    last_refreshed_at: Optional[datetime] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
```

### Configuration Updates

```python
# src/config.py additions
class Settings(BaseSettings):
    # Session Storage
    session_storage_backend: str = Field(
        default="redis",
        description="Session storage backend: 'redis' or 'postgres'",
    )
    session_key_prefix: str = Field(
        default="refresh",
        description="Redis key prefix for session tokens",
    )
    session_ttl_days: int = Field(
        default=30,
        description="Session/refresh token TTL in days",
    )
```

---

## Implementation Steps

### Step 1: Create Session Repository

Create `src/repositories/session.py` to handle Redis session operations:

```python
"""Redis-based session repository for refresh token storage."""

import json
import logging
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID

from redis.asyncio import Redis

from src.config import settings
from src.core.redis import get_redis

logger = logging.getLogger(__name__)


class SessionRepository:
    """Repository for managing user sessions in Redis."""

    def __init__(self, redis: Optional[Redis] = None):
        """Initialize session repository.

        Args:
            redis: Optional Redis client. Uses global client if not provided.
        """
        self._redis = redis

    @property
    def redis(self) -> Optional[Redis]:
        """Get Redis client."""
        return self._redis or get_redis()

    def _session_key(self, user_id: str, token_id: str) -> str:
        """Generate Redis key for a session."""
        return f"{settings.session_key_prefix}:{user_id}:{token_id}"

    def _user_sessions_key(self, user_id: str) -> str:
        """Generate Redis key for user's session set."""
        return f"user_sessions:{user_id}"

    def _ttl_seconds(self) -> int:
        """Get session TTL in seconds."""
        return settings.session_ttl_days * 24 * 60 * 60

    async def create_session(
        self,
        user_id: UUID,
        token_id: str,
        token: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> bool:
        """Create a new session.

        Args:
            user_id: User's UUID
            token_id: Unique token identifier (jti)
            token: Full JWT refresh token
            ip_address: Client IP address
            user_agent: Client user agent

        Returns:
            True if session was created, False if Redis unavailable
        """
        if not self.redis:
            logger.warning("Redis unavailable, cannot create session")
            return False

        session_data = {
            "token_id": token_id,
            "user_id": str(user_id),
            "token": token,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "ip_address": ip_address,
            "user_agent": user_agent,
        }

        user_id_str = str(user_id)
        session_key = self._session_key(user_id_str, token_id)
        user_sessions_key = self._user_sessions_key(user_id_str)
        ttl = self._ttl_seconds()

        try:
            # Use pipeline for atomic operations
            async with self.redis.pipeline(transaction=True) as pipe:
                # Store session data with TTL
                pipe.setex(session_key, ttl, json.dumps(session_data))
                # Add token_id to user's session set
                pipe.sadd(user_sessions_key, token_id)
                # Refresh TTL on user sessions set
                pipe.expire(user_sessions_key, ttl)
                await pipe.execute()

            logger.debug(
                "Session created",
                extra={"user_id": user_id_str, "token_id": token_id},
            )
            return True

        except Exception as e:
            logger.error(f"Failed to create session: {e}")
            return False

    async def get_session(
        self, user_id: UUID, token_id: str
    ) -> Optional[dict]:
        """Get session data.

        Args:
            user_id: User's UUID
            token_id: Token identifier

        Returns:
            Session data dict or None if not found
        """
        if not self.redis:
            return None

        session_key = self._session_key(str(user_id), token_id)

        try:
            data = await self.redis.get(session_key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logger.error(f"Failed to get session: {e}")
            return None

    async def validate_session(
        self, user_id: UUID, token_id: str, token: str
    ) -> bool:
        """Validate a session exists and token matches.

        Args:
            user_id: User's UUID
            token_id: Token identifier
            token: Full JWT refresh token to validate

        Returns:
            True if session is valid, False otherwise
        """
        session = await self.get_session(user_id, token_id)
        if not session:
            return False
        return session.get("token") == token

    async def delete_session(self, user_id: UUID, token_id: str) -> bool:
        """Delete a specific session.

        Args:
            user_id: User's UUID
            token_id: Token identifier

        Returns:
            True if session was deleted, False otherwise
        """
        if not self.redis:
            return False

        user_id_str = str(user_id)
        session_key = self._session_key(user_id_str, token_id)
        user_sessions_key = self._user_sessions_key(user_id_str)

        try:
            async with self.redis.pipeline(transaction=True) as pipe:
                pipe.delete(session_key)
                pipe.srem(user_sessions_key, token_id)
                results = await pipe.execute()

            return results[0] > 0  # True if key was deleted

        except Exception as e:
            logger.error(f"Failed to delete session: {e}")
            return False

    async def rotate_session(
        self,
        user_id: UUID,
        old_token_id: str,
        new_token_id: str,
        new_token: str,
        ip_address: Optional[str] = None,
    ) -> bool:
        """Atomically rotate a session (delete old, create new).

        Args:
            user_id: User's UUID
            old_token_id: Current token identifier to revoke
            new_token_id: New token identifier
            new_token: New JWT refresh token
            ip_address: Client IP address

        Returns:
            True if rotation succeeded, False otherwise
        """
        if not self.redis:
            return False

        user_id_str = str(user_id)
        old_key = self._session_key(user_id_str, old_token_id)
        new_key = self._session_key(user_id_str, new_token_id)
        user_sessions_key = self._user_sessions_key(user_id_str)
        ttl = self._ttl_seconds()

        session_data = {
            "token_id": new_token_id,
            "user_id": user_id_str,
            "token": new_token,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "ip_address": ip_address,
        }

        try:
            async with self.redis.pipeline(transaction=True) as pipe:
                # Delete old session
                pipe.delete(old_key)
                pipe.srem(user_sessions_key, old_token_id)
                # Create new session
                pipe.setex(new_key, ttl, json.dumps(session_data))
                pipe.sadd(user_sessions_key, new_token_id)
                pipe.expire(user_sessions_key, ttl)
                await pipe.execute()

            logger.debug(
                "Session rotated",
                extra={
                    "user_id": user_id_str,
                    "old_token_id": old_token_id,
                    "new_token_id": new_token_id,
                },
            )
            return True

        except Exception as e:
            logger.error(f"Failed to rotate session: {e}")
            return False

    async def get_user_sessions(self, user_id: UUID) -> List[dict]:
        """Get all active sessions for a user.

        Args:
            user_id: User's UUID

        Returns:
            List of session metadata (without tokens for security)
        """
        if not self.redis:
            return []

        user_id_str = str(user_id)
        user_sessions_key = self._user_sessions_key(user_id_str)

        try:
            token_ids = await self.redis.smembers(user_sessions_key)
            sessions = []

            for token_id in token_ids:
                session = await self.get_session(UUID(user_id_str), token_id)
                if session:
                    # Return metadata only (no token for security)
                    sessions.append({
                        "id": session["token_id"],
                        "created_at": session["created_at"],
                        "ip_address": session.get("ip_address"),
                    })

            return sessions

        except Exception as e:
            logger.error(f"Failed to get user sessions: {e}")
            return []

    async def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoke all sessions for a user.

        Args:
            user_id: User's UUID

        Returns:
            Number of sessions revoked
        """
        if not self.redis:
            return 0

        user_id_str = str(user_id)
        user_sessions_key = self._user_sessions_key(user_id_str)

        try:
            # Get all token IDs
            token_ids = await self.redis.smembers(user_sessions_key)
            if not token_ids:
                return 0

            # Delete all session keys
            keys_to_delete = [
                self._session_key(user_id_str, tid) for tid in token_ids
            ]
            keys_to_delete.append(user_sessions_key)

            deleted = await self.redis.delete(*keys_to_delete)

            logger.info(
                "All user sessions revoked",
                extra={"user_id": user_id_str, "sessions_revoked": len(token_ids)},
            )

            return len(token_ids)

        except Exception as e:
            logger.error(f"Failed to revoke all sessions: {e}")
            return 0
```

### Step 2: Update Security Module

Modify `src/core/security.py` to include `jti` claim:

```python
import secrets
from datetime import datetime, timedelta
from typing import Tuple
from uuid import UUID

import jwt

from src.config import settings


def generate_token_id() -> str:
    """Generate a short unique token identifier (12 chars)."""
    return secrets.token_urlsafe(9)


def create_refresh_token(
    user_id: UUID,
    token_id: str | None = None,
) -> Tuple[str, datetime, str]:
    """Create a JWT refresh token with unique identifier.

    Args:
        user_id: User's UUID
        token_id: Optional token ID (generated if not provided)

    Returns:
        Tuple of (token string, expiry datetime, token_id)
    """
    if token_id is None:
        token_id = generate_token_id()

    expires = datetime.utcnow() + timedelta(days=settings.session_ttl_days)

    payload = {
        "sub": str(user_id),
        "type": "refresh",
        "jti": token_id,  # JWT ID claim
        "exp": expires,
        "iat": datetime.utcnow(),
    }

    token = jwt.encode(payload, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)

    return token, expires, token_id


def verify_refresh_token(token: str) -> Tuple[UUID, str]:
    """Verify a refresh token and extract user_id and token_id.

    Args:
        token: JWT refresh token string

    Returns:
        Tuple of (user_id UUID, token_id string)

    Raises:
        TokenExpiredException: If token has expired
        TokenInvalidException: If token is invalid
    """
    try:
        payload = jwt.decode(
            token,
            settings.jwt_secret_key,
            algorithms=[settings.jwt_algorithm],
        )

        if payload.get("type") != "refresh":
            raise TokenInvalidException("Not a refresh token")

        user_id = UUID(payload["sub"])
        token_id = payload.get("jti")

        if not token_id:
            raise TokenInvalidException("Token missing jti claim")

        return user_id, token_id

    except jwt.ExpiredSignatureError:
        raise TokenExpiredException("Refresh token has expired")
    except jwt.InvalidTokenError as e:
        raise TokenInvalidException(f"Invalid token: {e}")
```

### Step 3: Update Auth Service

Modify `src/services/auth_service.py` to use Redis for session storage:

```python
# Key changes to AuthService class

from src.repositories.session import SessionRepository

class AuthService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.session_repo = SessionRepository()

    async def register_user(
        self, user_data: UserCreate, client_ip: str | None = None
    ) -> Tuple[User, TokenResponse]:
        # ... existing user creation code ...

        # Generate tokens with token_id
        access_token, access_expires = create_access_token(user.id)
        refresh_token, refresh_expires, token_id = create_refresh_token(user.id)

        # Store session in Redis
        await self.session_repo.create_session(
            user_id=user.id,
            token_id=token_id,
            token=refresh_token,
            ip_address=client_ip,
        )

        # ... rest of method ...

    async def login_user(
        self, login_data: UserLogin, client_ip: str | None = None
    ) -> Tuple[User, TokenResponse]:
        # ... existing validation code ...

        # Generate tokens with token_id
        access_token, access_expires = create_access_token(user.id)
        refresh_token, refresh_expires, token_id = create_refresh_token(user.id)

        # Store session in Redis
        await self.session_repo.create_session(
            user_id=user.id,
            token_id=token_id,
            token=refresh_token,
            ip_address=client_ip,
        )

        # ... rest of method ...

    async def refresh_access_token(
        self, refresh_token: str, client_ip: str | None = None
    ) -> Tuple[str, str, User]:
        # Verify JWT and extract user_id, token_id
        user_id, token_id = verify_refresh_token(refresh_token)

        # Validate session exists in Redis
        if not await self.session_repo.validate_session(user_id, token_id, refresh_token):
            raise TokenInvalidException("Session not found or revoked")

        # Load user from database
        user = await self._get_user_by_id(user_id)
        if not user or not user.is_active:
            await self.session_repo.delete_session(user_id, token_id)
            raise TokenInvalidException("User not found or inactive")

        # Generate new tokens
        new_access_token, _ = create_access_token(user.id)
        new_refresh_token, _, new_token_id = create_refresh_token(user.id)

        # Rotate session (atomic delete old + create new)
        await self.session_repo.rotate_session(
            user_id=user.id,
            old_token_id=token_id,
            new_token_id=new_token_id,
            new_token=new_refresh_token,
            ip_address=client_ip,
        )

        return new_access_token, new_refresh_token, user

    async def logout_user(self, refresh_token: str) -> None:
        try:
            user_id, token_id = verify_refresh_token(refresh_token)
            await self.session_repo.delete_session(user_id, token_id)
        except Exception:
            pass  # Token might be invalid, but logout should succeed

    async def revoke_all_user_tokens(self, user_id: UUID) -> int:
        return await self.session_repo.revoke_all_user_sessions(user_id)

    async def get_user_sessions(self, user_id: UUID) -> List[dict]:
        return await self.session_repo.get_user_sessions(user_id)
```

### Step 4: No PostgreSQL Fallback (Design Decision)

> **REMOVED (2025-12-04)**: PostgreSQL fallback was intentionally removed from the implementation.
>
> **Rationale**:
> - Simpler codebase with single source of truth
> - Clearer failure modes (Redis down = session operations fail)
> - Forces users to re-login if Redis is unavailable (acceptable for MVP)
> - Reduces complexity in token rotation and session management
>
> **Impact**:
> - If Redis is unavailable, login/register will succeed but sessions won't be stored
> - Token refresh will fail if Redis is unavailable (users must re-login)
> - Legacy tokens (without jti) are rejected - users must re-login to get new tokens

### Step 5: Migration Script

Create a migration script to move existing sessions to Redis:

```python
# scripts/migrate_sessions_to_redis.py
"""Migrate existing refresh tokens from PostgreSQL to Redis."""

import asyncio
import logging
from datetime import datetime, timezone

from sqlalchemy import select

from src.core.redis import init_redis, close_redis
from src.db import init_db, close_db, get_session_factory
from src.db.models import RefreshToken
from src.repositories.session import SessionRepository

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def migrate_sessions():
    """Migrate all non-expired refresh tokens to Redis."""
    await init_db()
    await init_redis()

    session_repo = SessionRepository()
    factory = get_session_factory()

    migrated = 0
    skipped = 0
    failed = 0

    async with factory() as db:
        # Get all non-expired tokens
        now = datetime.now(timezone.utc)
        result = await db.execute(
            select(RefreshToken).where(RefreshToken.expires_at > now)
        )
        tokens = result.scalars().all()

        logger.info(f"Found {len(tokens)} active refresh tokens to migrate")

        for token in tokens:
            # Generate a token_id for legacy tokens (they don't have jti)
            token_id = f"legacy_{str(token.id)[:8]}"

            success = await session_repo.create_session(
                user_id=token.user_id,
                token_id=token_id,
                token=token.token,
            )

            if success:
                migrated += 1
            else:
                failed += 1

        logger.info(
            f"Migration complete: {migrated} migrated, {skipped} skipped, {failed} failed"
        )

    await close_redis()
    await close_db()


if __name__ == "__main__":
    asyncio.run(migrate_sessions())
```

---

## File Changes

### Files to Create

| File | Purpose |
|------|---------|
| `src/repositories/session.py` | Redis session repository |
| `scripts/migrate_sessions_to_redis.py` | Migration script |

### Files to Modify

| File | Changes |
|------|---------|
| `src/config.py` | Add session storage settings |
| `src/core/security.py` | Add `jti` claim to refresh tokens |
| `src/services/auth_service.py` | Use SessionRepository for token storage |
| `src/repositories/__init__.py` | Export SessionRepository |

### Files to Keep (No Changes)

| File | Reason |
|------|--------|
| `src/db/models.py` | Keep RefreshToken model for migration/fallback |
| `src/core/redis.py` | Already complete |

---

## Testing Requirements

### Unit Tests

```python
# tests/unit/test_session_repository.py
import pytest
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

from src.repositories.session import SessionRepository


class TestSessionRepository:
    @pytest.fixture
    def mock_redis(self):
        redis = AsyncMock()
        redis.pipeline.return_value.__aenter__.return_value = AsyncMock()
        return redis

    @pytest.fixture
    def repo(self, mock_redis):
        return SessionRepository(redis=mock_redis)

    async def test_create_session_success(self, repo, mock_redis):
        user_id = uuid4()
        token_id = "test123"
        token = "eyJ..."

        result = await repo.create_session(
            user_id=user_id,
            token_id=token_id,
            token=token,
        )

        assert result is True

    async def test_create_session_redis_unavailable(self):
        repo = SessionRepository(redis=None)
        result = await repo.create_session(
            user_id=uuid4(),
            token_id="test",
            token="token",
        )
        assert result is False

    async def test_validate_session_valid(self, repo):
        # ... test implementation

    async def test_rotate_session_atomic(self, repo, mock_redis):
        # Verify pipeline is used for atomicity
        # ... test implementation
```

### Integration Tests

```python
# tests/integration/test_redis_sessions.py
import pytest
from uuid import uuid4

from src.core.redis import init_redis, close_redis, get_redis
from src.repositories.session import SessionRepository


@pytest.mark.integration
class TestRedisSessionIntegration:
    @pytest.fixture(autouse=True)
    async def setup_redis(self):
        await init_redis()
        yield
        # Cleanup test keys
        redis = get_redis()
        if redis:
            keys = await redis.keys("refresh:*")
            keys += await redis.keys("user_sessions:*")
            if keys:
                await redis.delete(*keys)
        await close_redis()

    async def test_full_session_lifecycle(self):
        repo = SessionRepository()
        user_id = uuid4()

        # Create session
        token_id = "test_token_123"
        token = "eyJ.test.token"

        created = await repo.create_session(
            user_id=user_id,
            token_id=token_id,
            token=token,
            ip_address="127.0.0.1",
        )
        assert created is True

        # Validate session
        valid = await repo.validate_session(user_id, token_id, token)
        assert valid is True

        # List sessions
        sessions = await repo.get_user_sessions(user_id)
        assert len(sessions) == 1
        assert sessions[0]["id"] == token_id

        # Rotate session
        new_token_id = "new_token_456"
        new_token = "eyJ.new.token"
        rotated = await repo.rotate_session(
            user_id=user_id,
            old_token_id=token_id,
            new_token_id=new_token_id,
            new_token=new_token,
        )
        assert rotated is True

        # Old session should be invalid
        old_valid = await repo.validate_session(user_id, token_id, token)
        assert old_valid is False

        # New session should be valid
        new_valid = await repo.validate_session(user_id, new_token_id, new_token)
        assert new_valid is True

        # Delete session
        deleted = await repo.delete_session(user_id, new_token_id)
        assert deleted is True

        # Session should no longer exist
        final_valid = await repo.validate_session(user_id, new_token_id, new_token)
        assert final_valid is False
```

### Auth API Tests

```python
# tests/integration/test_auth_redis.py
@pytest.mark.integration
class TestAuthWithRedis:
    async def test_login_creates_redis_session(self, client, test_user):
        response = await client.post("/api/v1/auth/login", json={
            "email": test_user.email,
            "password": "testpassword",
        })

        assert response.status_code == 200

        # Verify session exists in Redis
        redis = get_redis()
        keys = await redis.keys(f"refresh:{test_user.id}:*")
        assert len(keys) == 1

    async def test_refresh_rotates_redis_session(self, client, auth_tokens):
        # First refresh
        response = await client.post("/api/v1/auth/refresh", json={
            "refresh_token": auth_tokens.refresh_token,
        })
        assert response.status_code == 200

        new_tokens = response.json()

        # Old token should be invalid
        response2 = await client.post("/api/v1/auth/refresh", json={
            "refresh_token": auth_tokens.refresh_token,
        })
        assert response2.status_code == 401

        # New token should work
        response3 = await client.post("/api/v1/auth/refresh", json={
            "refresh_token": new_tokens["refresh_token"],
        })
        assert response3.status_code == 200

    async def test_logout_revokes_redis_session(self, client, auth_tokens):
        response = await client.post("/api/v1/auth/logout", json={
            "refresh_token": auth_tokens.refresh_token,
        })
        assert response.status_code == 200

        # Token should be invalid now
        response2 = await client.post("/api/v1/auth/refresh", json={
            "refresh_token": auth_tokens.refresh_token,
        })
        assert response2.status_code == 401
```

---

## Validation

### Pre-Flight Checklist

- [ ] Redis container is running and healthy
- [ ] `src/core/redis.py` provides working connection pool
- [ ] Health endpoint shows Redis as healthy
- [ ] All existing auth tests pass

### Manual Validation Steps

```bash
# 1. Start services
cd /Users/samosipov/Downloads/learn-greek-easy && docker-compose -f docker-compose.dev.yml up -d

# 2. Run migration script (if migrating existing data)
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run python scripts/migrate_sessions_to_redis.py

# 3. Test login creates Redis session
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"testpassword"}'

# 4. Verify session in Redis
docker exec learn-greek-redis-dev redis-cli KEYS "refresh:*"

# 5. Test token refresh
curl -X POST http://localhost:8000/api/v1/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refresh_token":"<token-from-login>"}'

# 6. Verify old session deleted, new created
docker exec learn-greek-redis-dev redis-cli KEYS "refresh:*"

# 7. Test logout
curl -X POST http://localhost:8000/api/v1/auth/logout \
  -H "Content-Type: application/json" \
  -d '{"refresh_token":"<new-token>"}'

# 8. Verify session deleted
docker exec learn-greek-redis-dev redis-cli KEYS "refresh:*"

# 9. Run full test suite
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && \
/Users/samosipov/.local/bin/poetry run pytest tests/ -v -k "auth"
```

---

## Rollback Plan

If issues are discovered after deployment:

1. **Code Rollback**: Revert changes to `auth_service.py` to use PostgreSQL RefreshToken model
2. **Data Recovery**: All users will need to re-login as Redis sessions will be lost

> **Note**: Since PostgreSQL fallback was removed, the RefreshToken model is no longer used
> for session storage. It can be kept for potential future use or removed in a cleanup task.

---

## Acceptance Criteria

- [ ] New sessions are stored in Redis with proper TTL
- [ ] Token refresh performs atomic rotation in Redis
- [ ] Logout properly removes session from Redis
- [ ] "Revoke all sessions" clears all user tokens from Redis
- [ ] Session list endpoint returns sessions from Redis
- [ ] Application handles Redis unavailability gracefully (fallback or error)
- [ ] All existing auth tests pass
- [ ] New unit tests for SessionRepository pass
- [ ] New integration tests for Redis sessions pass
- [ ] Performance: Token refresh < 10ms (vs ~50ms with PostgreSQL)
- [ ] Migration script successfully moves existing sessions

---

## Execution Checklist

### Phase 1: Preparation

1. [ ] Read current auth_service.py implementation
2. [ ] Read current security.py implementation
3. [ ] Verify Redis connectivity and health

### Phase 2: Core Implementation

4. [ ] Add session configuration to `src/config.py`
5. [ ] Create `src/repositories/session.py`
6. [ ] Update `src/repositories/__init__.py` exports
7. [ ] Update `src/core/security.py` with `jti` support
8. [ ] Update `src/services/auth_service.py` to use SessionRepository

### Phase 3: Testing

9. [ ] Write unit tests for SessionRepository
10. [ ] Write integration tests for Redis sessions
11. [ ] Update existing auth tests if needed
12. [ ] Run full test suite

### Phase 4: Migration

13. [ ] Create migration script
14. [ ] Test migration in development
15. [ ] Document migration procedure

### Phase 5: Validation

16. [ ] Manual testing of all auth flows
17. [ ] Verify Redis keys are created correctly
18. [ ] Verify TTL is set correctly
19. [ ] Test Redis failure/recovery scenario

---

**Ready for executor mode.**
