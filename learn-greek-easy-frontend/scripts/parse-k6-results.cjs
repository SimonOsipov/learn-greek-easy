#!/usr/bin/env node
/**
 * K6 Performance Results Parser Script
 *
 * This script parses k6 JSON reports generated by auth and dashboard scenarios
 * and generates a markdown comment for PR reviews.
 *
 * Usage:
 *   node scripts/parse-k6-results.cjs
 *
 * Expected input:
 *   K6 JSON reports in K6_REPORTS_DIR (default: ./k6-data/)
 *   Files: auth-preview-*.json, dashboard-preview-*.json
 *
 * Environment variables:
 *   K6_REPORTS_DIR - Directory containing k6 JSON reports (default: ./k6-data)
 *   GITHUB_SERVER_URL - GitHub server URL (e.g., https://github.com)
 *   GITHUB_REPOSITORY - Repository name (e.g., owner/repo)
 *   GITHUB_RUN_ID - Workflow run ID for artifact link
 *
 * Output files:
 *   k6-comment.md - Markdown formatted PR comment
 *
 * Exit codes:
 *   0 - Always exits 0 (errors generate error markdown)
 */

const fs = require('fs');
const path = require('path');

// ============================================================================
// Configuration
// ============================================================================

const REPORTS_DIR = process.env.K6_REPORTS_DIR || path.join(process.cwd(), 'k6-data');
const OUTPUT_FILE = path.join(process.cwd(), 'k6-comment.md');

// Environment variables for artifact link
const GITHUB_SERVER_URL = process.env.GITHUB_SERVER_URL || 'https://github.com';
const GITHUB_REPOSITORY = process.env.GITHUB_REPOSITORY || '';
const GITHUB_RUN_ID = process.env.GITHUB_RUN_ID || '';

// Metric configuration for each scenario
const AUTH_METRICS = {
  auth_total_time: { label: 'Total Auth Flow', threshold: 8000 },
  auth_navigate_time: { label: 'Navigate to Login', threshold: 3000 },
  auth_fill_email_time: { label: 'Fill Email', threshold: 500 },
  auth_fill_password_time: { label: 'Fill Password', threshold: 500 },
  auth_submit_time: { label: 'Submit Form', threshold: 2000 },
  auth_redirect_time: { label: 'Redirect to Dashboard', threshold: 2000 },
};

const DASHBOARD_METRICS = {
  dashboard_flow_total_time: { label: 'Total Dashboard Flow', threshold: 15000 },
  dashboard_load_time: { label: 'Dashboard Load', threshold: 2000 },
  dashboard_stats_api_time: { label: 'Stats API', threshold: 3000 },
  deck_navigation_time: { label: 'Deck Navigation', threshold: 1000 },
  deck_load_time: { label: 'Deck Load', threshold: 2000 },
  session_start_time: { label: 'Session Start', threshold: 2000 },
  card_interaction_time: { label: 'Card Interaction', threshold: 1500 },
};

// ============================================================================
// Main Function
// ============================================================================

function main() {
  console.log('='.repeat(60));
  console.log('K6 PERFORMANCE RESULTS PARSER');
  console.log('='.repeat(60));
  console.log('');
  console.log(`Reports directory: ${REPORTS_DIR}`);

  try {
    // Check if reports directory exists
    if (!fs.existsSync(REPORTS_DIR)) {
      throw new Error(`Reports directory not found: ${REPORTS_DIR}`);
    }

    // Find and parse reports
    const authReport = findLatestReport('auth-preview-');
    const dashboardReport = findLatestReport('dashboard-preview-');

    if (!authReport && !dashboardReport) {
      throw new Error('No k6 report files found (expected auth-preview-*.json or dashboard-preview-*.json)');
    }

    // Parse reports
    const authData = authReport ? parseReport(authReport) : null;
    const dashboardData = dashboardReport ? parseReport(dashboardReport) : null;

    console.log('');
    if (authData) console.log(`Auth report parsed: ${authReport}`);
    if (dashboardData) console.log(`Dashboard report parsed: ${dashboardReport}`);

    // Generate markdown
    const markdown = generateMarkdown(authData, dashboardData);

    // Write output
    fs.writeFileSync(OUTPUT_FILE, markdown);
    console.log('');
    console.log(`Markdown comment written to: ${OUTPUT_FILE}`);
    console.log('');
    console.log('Parsing completed successfully!');
  } catch (error) {
    console.error(`Error: ${error.message}`);

    // Write error markdown (always exit 0)
    const errorMarkdown = generateErrorMarkdown(error.message);
    fs.writeFileSync(OUTPUT_FILE, errorMarkdown);
    console.log(`Error markdown written to: ${OUTPUT_FILE}`);
  }

  // Always exit 0 - let the CI job handle the comment posting
  process.exit(0);
}

// ============================================================================
// File Finding Functions
// ============================================================================

/**
 * Find the most recent report file matching a prefix.
 *
 * @param {string} prefix - The file prefix to search for (e.g., 'auth-preview-')
 * @returns {string|null} The full path to the most recent file, or null if not found
 */
function findLatestReport(prefix) {
  try {
    const files = fs.readdirSync(REPORTS_DIR);
    const matchingFiles = files
      .filter((f) => f.startsWith(prefix) && f.endsWith('.json'))
      .map((f) => ({
        name: f,
        path: path.join(REPORTS_DIR, f),
        mtime: fs.statSync(path.join(REPORTS_DIR, f)).mtime,
      }))
      .sort((a, b) => b.mtime - a.mtime); // Sort by modification time, newest first

    if (matchingFiles.length === 0) {
      console.log(`No files found matching prefix: ${prefix}`);
      return null;
    }

    console.log(`Found ${matchingFiles.length} file(s) matching ${prefix}, using: ${matchingFiles[0].name}`);
    return matchingFiles[0].path;
  } catch (err) {
    console.error(`Error finding reports: ${err.message}`);
    return null;
  }
}

// ============================================================================
// Parsing Functions
// ============================================================================

/**
 * Parse a k6 JSON report file.
 *
 * @param {string} filePath - Path to the JSON report file
 * @returns {Object|null} Parsed report data with metrics and thresholds
 */
function parseReport(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const data = JSON.parse(content);

    // Extract relevant data
    const metrics = data.metrics || {};
    const thresholds = data.metrics || {};

    // Get iterations and checks
    const iterations = metrics.iterations?.values?.count || 0;
    const checksRate = metrics.checks?.values?.rate || 1;
    const checksPasses = metrics.checks?.values?.passes || 0;
    const checksFails = metrics.checks?.values?.fails || 0;

    // Calculate error rate
    const totalChecks = checksPasses + checksFails;
    const errorRate = totalChecks > 0 ? (checksFails / totalChecks) * 100 : (1 - checksRate) * 100;

    // Extract threshold violations
    const violations = [];
    for (const [key, value] of Object.entries(thresholds)) {
      if (value.thresholds) {
        for (const [thresholdName, thresholdData] of Object.entries(value.thresholds)) {
          if (thresholdData.ok === false) {
            violations.push({
              metric: key,
              threshold: thresholdName,
              value: formatMetricValue(value.values, key),
            });
          }
        }
      }
    }

    return {
      iterations,
      errorRate,
      checksRate: checksRate * 100,
      metrics,
      violations,
    };
  } catch (err) {
    console.error(`Error parsing ${filePath}: ${err.message}`);
    return null;
  }
}

/**
 * Extract percentile values from a k6 metric.
 *
 * @param {Object} metric - The k6 metric object with values
 * @returns {Object} Percentile values (p50, p90, p95, p99)
 */
function extractPercentiles(metric) {
  if (!metric || !metric.values) {
    return { p50: null, p90: null, p95: null, p99: null, avg: null, min: null, max: null };
  }

  const values = metric.values;
  return {
    p50: values.med ?? values['p(50)'] ?? null,
    p90: values['p(90)'] ?? null,
    p95: values['p(95)'] ?? null,
    p99: values['p(99)'] ?? null,
    avg: values.avg ?? null,
    min: values.min ?? null,
    max: values.max ?? null,
  };
}

/**
 * Format a metric value for display.
 *
 * @param {Object} values - The metric values object
 * @param {string} metricName - The metric name
 * @returns {string} Formatted value string
 */
function formatMetricValue(values, metricName) {
  if (!values) return 'N/A';

  const p95 = values['p(95)'];
  if (p95 !== undefined) {
    return `p95: ${formatMs(p95)}`;
  }

  const rate = values.rate;
  if (rate !== undefined) {
    return `${(rate * 100).toFixed(1)}%`;
  }

  return 'N/A';
}

/**
 * Format milliseconds for display.
 *
 * @param {number|null} ms - Value in milliseconds
 * @returns {string} Formatted string (e.g., "1.5s" or "500ms")
 */
function formatMs(ms) {
  if (ms === null || ms === undefined) return 'N/A';

  if (ms >= 1000) {
    return `${(ms / 1000).toFixed(2)}s`;
  }
  return `${Math.round(ms)}ms`;
}

// ============================================================================
// Markdown Generation
// ============================================================================

/**
 * Generate the complete markdown comment.
 *
 * @param {Object|null} authData - Parsed auth scenario data
 * @param {Object|null} dashboardData - Parsed dashboard scenario data
 * @returns {string} Markdown content
 */
function generateMarkdown(authData, dashboardData) {
  let md = `## K6 Performance Report\n\n`;

  // Determine overall status
  const authStatus = authData ? getScenarioStatus(authData) : 'skipped';
  const dashboardStatus = dashboardData ? getScenarioStatus(dashboardData) : 'skipped';
  const overallStatus = getOverallStatus(authStatus, dashboardStatus);

  // Status badge
  if (overallStatus === 'pass') {
    md += `\u2705 **All performance thresholds passed!**\n\n`;
  } else if (overallStatus === 'warning') {
    md += `\u26A0\uFE0F **Performance tests completed with some metrics close to thresholds**\n\n`;
  } else if (overallStatus === 'fail') {
    md += `\u274C **Performance thresholds exceeded**\n\n`;
  }

  // Summary table
  md += `### Summary\n\n`;
  md += `| Scenario | Status | Iterations | Errors | p95 Total |\n`;
  md += `|----------|--------|------------|--------|----------|\n`;

  if (authData) {
    const authP95 = extractPercentiles(authData.metrics.auth_total_time);
    const statusIcon = getStatusIcon(authStatus);
    md += `| Auth Flow | ${statusIcon} | ${authData.iterations} | ${authData.errorRate.toFixed(1)}% | ${formatMs(authP95.p95)} |\n`;
  } else {
    md += `| Auth Flow | \u23ED\uFE0F Skipped | - | - | - |\n`;
  }

  if (dashboardData) {
    const dashP95 = extractPercentiles(dashboardData.metrics.dashboard_flow_total_time);
    const statusIcon = getStatusIcon(dashboardStatus);
    md += `| Dashboard Flow | ${statusIcon} | ${dashboardData.iterations} | ${dashboardData.errorRate.toFixed(1)}% | ${formatMs(dashP95.p95)} |\n`;
  } else {
    md += `| Dashboard Flow | \u23ED\uFE0F Skipped | - | - | - |\n`;
  }

  md += `\n`;

  // Auth Flow metrics section
  if (authData) {
    md += generateMetricsSection('Auth Flow Metrics', authData.metrics, AUTH_METRICS);
  }

  // Dashboard Flow metrics section
  if (dashboardData) {
    md += generateMetricsSection('Dashboard Flow Metrics', dashboardData.metrics, DASHBOARD_METRICS);
  }

  // Threshold violations section
  const allViolations = [
    ...(authData?.violations || []).map((v) => ({ ...v, scenario: 'Auth' })),
    ...(dashboardData?.violations || []).map((v) => ({ ...v, scenario: 'Dashboard' })),
  ];

  if (allViolations.length > 0) {
    md += `<details>\n`;
    md += `<summary><strong>\u274C Threshold Violations (${allViolations.length})</strong></summary>\n\n`;
    md += `| Scenario | Metric | Threshold | Actual Value |\n`;
    md += `|----------|--------|-----------|-------------|\n`;
    for (const violation of allViolations) {
      const metricLabel = getMetricLabel(violation.metric);
      md += `| ${violation.scenario} | ${metricLabel} | ${violation.threshold} | ${violation.value} |\n`;
    }
    md += `\n</details>\n\n`;
  }

  // Artifact link
  md += generateArtifactLink();

  // Footer
  md += generateFooter();

  return md;
}

/**
 * Generate a metrics section for a scenario.
 *
 * @param {string} title - Section title
 * @param {Object} metrics - The k6 metrics object
 * @param {Object} metricConfig - Configuration for which metrics to display
 * @returns {string} Markdown section
 */
function generateMetricsSection(title, metrics, metricConfig) {
  let md = `### ${title}\n\n`;
  md += `| Metric | p50 | p90 | p95 | p99 | Threshold | Status |\n`;
  md += `|--------|-----|-----|-----|-----|-----------|--------|\n`;

  for (const [metricName, config] of Object.entries(metricConfig)) {
    const metric = metrics[metricName];
    const percentiles = extractPercentiles(metric);

    // Determine status based on p95 vs threshold
    const p95Value = percentiles.p95;
    const threshold = config.threshold;
    const status = getMetricStatus(p95Value, threshold);
    const statusIcon = getStatusIcon(status);

    md += `| ${config.label} | ${formatMs(percentiles.p50)} | ${formatMs(percentiles.p90)} | ${formatMs(percentiles.p95)} | ${formatMs(percentiles.p99)} | <${formatMs(threshold)} | ${statusIcon} |\n`;
  }

  md += `\n`;
  return md;
}

/**
 * Get the status of a single metric.
 *
 * @param {number|null} value - The p95 value
 * @param {number} threshold - The threshold value
 * @returns {'pass'|'warning'|'fail'} Status
 */
function getMetricStatus(value, threshold) {
  if (value === null) return 'pass';
  if (value > threshold) return 'fail';
  if (value > threshold * 0.8) return 'warning'; // Within 20% of threshold
  return 'pass';
}

/**
 * Get the overall status for a scenario.
 *
 * @param {Object} data - Parsed scenario data
 * @returns {'pass'|'warning'|'fail'} Status
 */
function getScenarioStatus(data) {
  if (data.violations && data.violations.length > 0) {
    return 'fail';
  }
  if (data.errorRate > 5) {
    return 'warning';
  }
  return 'pass';
}

/**
 * Get the overall status across all scenarios.
 *
 * @param {string} authStatus - Auth scenario status
 * @param {string} dashboardStatus - Dashboard scenario status
 * @returns {'pass'|'warning'|'fail'|'skipped'} Overall status
 */
function getOverallStatus(authStatus, dashboardStatus) {
  if (authStatus === 'skipped' && dashboardStatus === 'skipped') {
    return 'skipped';
  }
  if (authStatus === 'fail' || dashboardStatus === 'fail') {
    return 'fail';
  }
  if (authStatus === 'warning' || dashboardStatus === 'warning') {
    return 'warning';
  }
  return 'pass';
}

/**
 * Get the status icon for display.
 *
 * @param {string} status - Status string
 * @returns {string} Unicode icon
 */
function getStatusIcon(status) {
  switch (status) {
    case 'pass':
      return '\u2705'; // green check
    case 'warning':
      return '\u26A0\uFE0F'; // warning
    case 'fail':
      return '\u274C'; // red x
    case 'skipped':
      return '\u23ED\uFE0F'; // skip
    default:
      return '\u2753'; // question mark
  }
}

/**
 * Get a human-readable label for a metric.
 *
 * @param {string} metricName - The k6 metric name
 * @returns {string} Human-readable label
 */
function getMetricLabel(metricName) {
  const allMetrics = { ...AUTH_METRICS, ...DASHBOARD_METRICS };
  return allMetrics[metricName]?.label || metricName;
}

/**
 * Generate the artifact link section.
 *
 * @returns {string} Markdown content
 */
function generateArtifactLink() {
  if (!GITHUB_REPOSITORY || !GITHUB_RUN_ID) {
    return '';
  }

  const artifactUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
  return `### Artifacts\n\n[View Full K6 Reports](${artifactUrl})\n\n`;
}

/**
 * Generate the footer section.
 *
 * @returns {string} Markdown content
 */
function generateFooter() {
  return `---\n*Generated by k6 performance testing*\n`;
}

/**
 * Generate error markdown when parsing fails.
 *
 * @param {string} errorMessage - The error message
 * @returns {string} Markdown content
 */
function generateErrorMarkdown(errorMessage) {
  let md = `## K6 Performance Report\n\n`;
  md += `\u26A0\uFE0F **K6 performance results are not available.**\n\n`;
  md += `**Error:** ${errorMessage}\n\n`;
  md += `Please check the workflow logs for more details.\n\n`;

  if (GITHUB_REPOSITORY && GITHUB_RUN_ID) {
    const logsUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
    md += `[View Workflow Logs](${logsUrl})\n\n`;
  }

  md += generateFooter();
  return md;
}

// ============================================================================
// Run
// ============================================================================

main();
