---
id: task-151
title: 07.03 Search Cards Endpoint
status: To Do
assignee: []
created_date: '2025-12-08 05:21'
labels:
  - backend
  - api
  - cards
  - task-07
dependencies: []
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
# 07.03 Search Cards Endpoint

## Overview
Implement the GET /api/v1/cards/search endpoint for searching cards by text content with optional deck filtering.

## Technical Specification

### Files to Modify

1. **Modify**: `src/api/v1/cards.py` - Add search_cards endpoint
2. **Modify**: `src/schemas/card.py` - Add CardSearchResponse schema
3. **Modify**: `src/repositories/card.py` - Add search and count_search methods

### New Schema: CardSearchResponse

Add to `src/schemas/card.py`:

```python
class CardSearchResponse(BaseModel):
    """Schema for card search results."""
    total: int
    page: int
    page_size: int
    query: str
    deck_id: UUID | None
    cards: list[CardResponse]
```

### New Repository Methods

Add to `src/repositories/card.py`:

```python
from sqlalchemy import or_

async def search(
    self,
    query_text: str,
    deck_id: UUID | None = None,
    *,
    skip: int = 0,
    limit: int = 50,
) -> list[Card]:
    """Search cards by text in front_text, back_text, example_sentence.

    Args:
        query_text: Search query (case-insensitive)
        deck_id: Optional deck filter
        skip: Pagination offset
        limit: Max results

    Returns:
        List of matching cards ordered by order_index
    """
    query = select(Card).where(
        or_(
            Card.front_text.ilike(f"%{query_text}%"),
            Card.back_text.ilike(f"%{query_text}%"),
            Card.example_sentence.ilike(f"%{query_text}%"),
        )
    )

    if deck_id:
        query = query.where(Card.deck_id == deck_id)

    query = query.order_by(Card.order_index).offset(skip).limit(limit)
    result = await self.db.execute(query)
    return list(result.scalars().all())

async def count_search(
    self,
    query_text: str,
    deck_id: UUID | None = None,
) -> int:
    """Count cards matching search query."""
    query = select(func.count()).select_from(Card).where(
        or_(
            Card.front_text.ilike(f"%{query_text}%"),
            Card.back_text.ilike(f"%{query_text}%"),
            Card.example_sentence.ilike(f"%{query_text}%"),
        )
    )

    if deck_id:
        query = query.where(Card.deck_id == deck_id)

    result = await self.db.execute(query)
    return result.scalar_one()
```

### Endpoint Implementation

Add to `src/api/v1/cards.py` (BEFORE the /{card_id} route):

```python
@router.get(
    "/search",
    response_model=CardSearchResponse,
    summary="Search cards",
    description="Search cards by Greek or English text with optional deck filtering.",
    responses={
        200: {
            "description": "Search results with pagination",
            "content": {
                "application/json": {
                    "example": {
                        "total": 5,
                        "page": 1,
                        "page_size": 20,
                        "query": "morning",
                        "deck_id": None,
                        "cards": [...]
                    }
                }
            },
        },
        404: {"description": "Deck not found (if deck_id provided)"},
        422: {"description": "Validation error"},
    },
)
async def search_cards(
    q: str = Query(
        ...,
        min_length=1,
        max_length=100,
        description="Search query (searches front_text, back_text, example_sentence)",
    ),
    deck_id: Optional[UUID] = Query(
        default=None, description="Optional: limit search to specific deck"
    ),
    page: int = Query(default=1, ge=1, description="Page number (starting from 1)"),
    page_size: int = Query(default=20, ge=1, le=50, description="Items per page (max 50)"),
    db: AsyncSession = Depends(get_db),
) -> CardSearchResponse:
    """Search cards by text content.

    Performs case-insensitive partial matching on card text fields.
    Optionally filter by deck to narrow results.
    """
    # Validate deck exists if provided
    if deck_id:
        deck_repo = DeckRepository(db)
        deck = await deck_repo.get(deck_id)
        if deck is None:
            raise DeckNotFoundException(deck_id=str(deck_id))

    card_repo = CardRepository(db)
    skip = (page - 1) * page_size

    cards = await card_repo.search(query_text=q, deck_id=deck_id, skip=skip, limit=page_size)
    total = await card_repo.count_search(query_text=q, deck_id=deck_id)

    return CardSearchResponse(
        total=total,
        page=page,
        page_size=page_size,
        query=q,
        deck_id=deck_id,
        cards=[CardResponse.model_validate(card) for card in cards],
    )
```

### API Contract

**Endpoint**: GET /api/v1/cards/search

**Query Parameters**:
| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| q | string | Yes | - | Search query (min 1 char) |
| deck_id | UUID | No | null | Optional deck filter |
| page | int | No | 1 | Page number |
| page_size | int | No | 20 | Items per page (max: 50) |

**Response** (200 OK):
```json
{
  "total": 5,
  "page": 1,
  "page_size": 20,
  "query": "morning",
  "deck_id": null,
  "cards": [...]
}
```

### Route Ordering

IMPORTANT: The /search route must be defined BEFORE the /{card_id} route in the router file, otherwise FastAPI will try to parse "search" as a UUID.

## Verification Steps

1. Test search with matching query returns results
2. Test search with non-matching query returns empty list
3. Test search with deck_id filter works
4. Test search with invalid deck_id returns 404
5. Test pagination works correctly
6. Test empty query returns 422
7. Verify search is case-insensitive
<!-- SECTION:DESCRIPTION:END -->
