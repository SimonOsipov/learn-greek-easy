---
id: task-149
title: 07.01 Create Card Router and List by Deck Endpoint
status: To Do
assignee: []
created_date: '2025-12-08 05:21'
updated_date: '2025-12-08 05:24'
labels:
  - backend
  - api
  - cards
  - task-07
dependencies: []
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
# 07.01 Create Card Router and List by Deck Endpoint

## Overview
Create the card router module and implement the GET /api/v1/cards endpoint for listing cards by deck with pagination and optional difficulty filtering.

## Technical Specification

### Files to Create/Modify

1. **Create**: `src/api/v1/cards.py` - New card router module
2. **Modify**: `src/api/v1/router.py` - Register card router
3. **Modify**: `src/schemas/card.py` - Add CardListResponse schema
4. **Modify**: `src/repositories/card.py` - Add count_by_deck method

### New Schema: CardListResponse

Add to `src/schemas/card.py`:

```python
class CardListResponse(BaseModel):
    """Schema for paginated card list by deck."""
    total: int
    page: int
    page_size: int
    deck_id: UUID
    cards: list[CardResponse]
```

### New Repository Method: count_by_deck

Add to `src/repositories/card.py`:

```python
async def count_by_deck(self, deck_id: UUID) -> int:
    """Count total cards in a deck."""
    query = select(func.count()).select_from(Card).where(Card.deck_id == deck_id)
    result = await self.db.execute(query)
    return result.scalar_one()
```

### Router Implementation

Create `src/api/v1/cards.py`:

```python
"""Card API endpoints."""

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.exceptions import DeckNotFoundException
from src.db.dependencies import get_db
from src.db.models import CardDifficulty
from src.repositories.card import CardRepository
from src.repositories.deck import DeckRepository
from src.schemas.card import CardListResponse, CardResponse

router = APIRouter(
    tags=["Cards"],
    responses={
        422: {"description": "Validation error"},
    },
)

@router.get(
    "",
    response_model=CardListResponse,
    summary="List cards by deck",
    description="Get paginated list of cards for a specific deck with optional difficulty filtering.",
    responses={
        200: {"description": "Paginated list of cards"},
        404: {"description": "Deck not found"},
    },
)
async def list_cards(
    deck_id: UUID = Query(..., description="Deck UUID (required)"),
    difficulty: Optional[CardDifficulty] = Query(
        default=None, description="Filter by difficulty (easy, medium, hard)"
    ),
    page: int = Query(default=1, ge=1, description="Page number (starting from 1)"),
    page_size: int = Query(default=50, ge=1, le=100, description="Items per page (max 100)"),
    db: AsyncSession = Depends(get_db),
) -> CardListResponse:
    """List cards for a specific deck."""
    # Validate deck exists
    deck_repo = DeckRepository(db)
    deck = await deck_repo.get(deck_id)
    if deck is None or not deck.is_active:
        raise DeckNotFoundException(deck_id=str(deck_id))

    card_repo = CardRepository(db)
    skip = (page - 1) * page_size

    # Get cards with optional difficulty filter
    if difficulty:
        cards = await card_repo.get_by_difficulty(deck_id, difficulty)
        # Apply pagination manually for difficulty filter
        cards = cards[skip:skip + page_size]
        total = len(await card_repo.get_by_difficulty(deck_id, difficulty))
    else:
        cards = await card_repo.get_by_deck(deck_id, skip=skip, limit=page_size)
        total = await card_repo.count_by_deck(deck_id)

    return CardListResponse(
        total=total,
        page=page,
        page_size=page_size,
        deck_id=deck_id,
        cards=[CardResponse.model_validate(card) for card in cards],
    )
```

### Register Router

Update `src/api/v1/router.py`:

```python
from src.api.v1.cards import router as card_router

v1_router.include_router(
    card_router,
    prefix="/cards",
    tags=["Cards"],
)
```

### API Contract

**Endpoint**: GET /api/v1/cards

**Query Parameters**:
| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| deck_id | UUID | Yes | - | Filter by deck |
| difficulty | CardDifficulty | No | null | Filter by difficulty |
| page | int | No | 1 | Page number (min: 1) |
| page_size | int | No | 50 | Items per page (max: 100) |

**Response** (200 OK):
```json
{
  "total": 150,
  "page": 1,
  "page_size": 50,
  "deck_id": "550e8400-...",
  "cards": [...]
}
```

**Error Responses**:
- 404: Deck not found
- 422: Validation error

## Verification Steps

1. Run existing tests to ensure no regressions
2. Test endpoint with valid deck_id returns cards
3. Test endpoint with invalid deck_id returns 404
4. Test pagination works correctly
5. Test difficulty filter works
6. Verify response schema matches specification
<!-- SECTION:DESCRIPTION:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
## Implementation Plan for 07.01 Create Card Router and List by Deck Endpoint

### Prerequisites
- [ ] Verify existing `CardRepository` methods in `src/repositories/card.py`
- [ ] Confirm `CardResponse` schema exists in `src/schemas/card.py`
- [ ] Ensure `CardDifficulty` enum is available in `src/db/models.py`
- [ ] Verify `DeckNotFoundException` exists in `src/core/exceptions.py`
- [ ] Confirm `get_db` dependency is available in `src/db/dependencies.py`

---

### Step 1: Add `count_by_deck` Method to CardRepository

**Goal**: Add a method to count total cards in a deck for pagination purposes.

**File to modify**: `learn-greek-easy-backend/src/repositories/card.py`

**Actions**:
1. Import `func` from SQLAlchemy if not already imported
2. Add the `count_by_deck` method to `CardRepository`:

```python
async def count_by_deck(self, deck_id: UUID) -> int:
    """Count total cards in a deck.

    Args:
        deck_id: Deck UUID

    Returns:
        Number of cards in the deck
    """
    query = select(func.count()).select_from(Card).where(Card.deck_id == deck_id)
    result = await self.db.execute(query)
    return result.scalar_one()
```

**Verification**:
- Run existing card repository tests: `poetry run pytest tests/unit/repositories/ -k card -v`
- Manually test method by adding a quick test case

---

### Step 2: Add `CardListResponse` Schema

**Goal**: Create the paginated response schema for listing cards by deck.

**File to modify**: `learn-greek-easy-backend/src/schemas/card.py`

**Actions**:
1. Add the `CardListResponse` schema after `CardStudyResultResponse`:

```python
class CardListResponse(BaseModel):
    """Schema for paginated card list by deck."""
    total: int
    page: int
    page_size: int
    deck_id: UUID
    cards: list[CardResponse]
```

**Verification**:
- Import check: `from src.schemas.card import CardListResponse`
- Schema instantiation test with sample data

---

### Step 3: Create Card Router Module

**Goal**: Create the new card router with the list cards endpoint.

**File to create**: `learn-greek-easy-backend/src/api/v1/cards.py`

**Actions**:
1. Create the file with standard imports
2. Define the router with tags and responses
3. Implement the `list_cards` endpoint with:
   - Query parameter `deck_id` (required, UUID)
   - Query parameter `difficulty` (optional, CardDifficulty enum)
   - Query parameter `page` (default=1, ge=1)
   - Query parameter `page_size` (default=50, ge=1, le=100)
4. Validate deck exists and is active before fetching cards
5. Apply pagination and optional difficulty filtering
6. Return `CardListResponse` with total count

**Implementation structure**:
```python
"""Card API endpoints."""

from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.exceptions import DeckNotFoundException
from src.db.dependencies import get_db
from src.db.models import CardDifficulty
from src.repositories.card import CardRepository
from src.repositories.deck import DeckRepository
from src.schemas.card import CardListResponse, CardResponse

router = APIRouter(
    tags=["Cards"],
    responses={
        422: {"description": "Validation error"},
    },
)

@router.get(
    "",
    response_model=CardListResponse,
    summary="List cards by deck",
    description="Get paginated list of cards for a specific deck with optional difficulty filtering.",
    responses={
        200: {"description": "Paginated list of cards"},
        404: {"description": "Deck not found"},
    },
)
async def list_cards(
    deck_id: UUID = Query(..., description="Deck UUID (required)"),
    difficulty: Optional[CardDifficulty] = Query(
        default=None, description="Filter by difficulty (easy, medium, hard)"
    ),
    page: int = Query(default=1, ge=1, description="Page number (starting from 1)"),
    page_size: int = Query(default=50, ge=1, le=100, description="Items per page (max 100)"),
    db: AsyncSession = Depends(get_db),
) -> CardListResponse:
    """List cards for a specific deck with pagination and optional difficulty filter."""
    # Validate deck exists and is active
    deck_repo = DeckRepository(db)
    deck = await deck_repo.get(deck_id)
    if deck is None or not deck.is_active:
        raise DeckNotFoundException(deck_id=str(deck_id))

    card_repo = CardRepository(db)
    skip = (page - 1) * page_size

    # Get cards with optional difficulty filter
    if difficulty:
        # Note: get_by_difficulty doesn't have pagination, apply manually
        all_cards = await card_repo.get_by_difficulty(deck_id, difficulty)
        total = len(all_cards)
        cards = all_cards[skip:skip + page_size]
    else:
        cards = await card_repo.get_by_deck(deck_id, skip=skip, limit=page_size)
        total = await card_repo.count_by_deck(deck_id)

    return CardListResponse(
        total=total,
        page=page,
        page_size=page_size,
        deck_id=deck_id,
        cards=[CardResponse.model_validate(card) for card in cards],
    )
```

**Verification**:
- File exists and has no syntax errors
- Imports resolve correctly

---

### Step 4: Register Card Router in v1 Router

**Goal**: Mount the card router at `/cards` prefix under `/api/v1`.

**File to modify**: `learn-greek-easy-backend/src/api/v1/router.py`

**Actions**:
1. Add import for card router:
   ```python
   from src.api.v1.cards import router as card_router
   ```
2. Include the card router after deck router:
   ```python
   # =============================================================================
   # Card Routes
   # =============================================================================
   v1_router.include_router(
       card_router,
       prefix="/cards",
       tags=["Cards"],
   )
   ```

**Verification**:
- Start the application: `poetry run uvicorn src.main:app --reload`
- Check `/docs` shows the new endpoint under "Cards" tag
- Verify endpoint path is `/api/v1/cards`

---

### Step 5: Manual API Testing

**Goal**: Verify the endpoint works correctly with various inputs.

**Actions**:
1. Start the application (if not already running)
2. Test with valid deck_id that has cards:
   ```bash
   curl "http://localhost:8000/api/v1/cards?deck_id=<valid-deck-id>"
   ```
3. Test with invalid deck_id (should return 404):
   ```bash
   curl "http://localhost:8000/api/v1/cards?deck_id=00000000-0000-0000-0000-000000000000"
   ```
4. Test pagination parameters:
   ```bash
   curl "http://localhost:8000/api/v1/cards?deck_id=<id>&page=2&page_size=10"
   ```
5. Test difficulty filter:
   ```bash
   curl "http://localhost:8000/api/v1/cards?deck_id=<id>&difficulty=easy"
   ```
6. Test validation errors (page=0, page_size=200, missing deck_id)

**Verification**:
- All test cases return expected responses
- Response structure matches `CardListResponse` schema
- Pagination works correctly (offset calculation)
- Difficulty filter returns only matching cards

---

### Step 6: Run Existing Tests

**Goal**: Ensure no regressions in existing functionality.

**Actions**:
1. Run all backend tests:
   ```bash
   cd learn-greek-easy-backend
   poetry run pytest -n auto
   ```
2. Address any failures before proceeding

**Verification**:
- All existing tests pass
- No import errors or circular dependencies

---

### Estimated Effort
- **Total steps**: 6
- **Complexity**: Low-Medium
- **Estimated time**: 1-2 hours
- **Risk areas**:
  - Pagination with difficulty filter (manual slicing vs. DB query)
  - Ensuring deck validation includes `is_active` check

### Notes for Implementation
1. The existing `get_by_difficulty` method does NOT have pagination parameters, so we apply slicing after fetching all results. This is acceptable for the MVP but could be optimized later by adding pagination to that method.
2. Follow the exact pattern from `src/api/v1/decks.py` for consistency.
3. The router uses `tags=["Cards"]` which will group endpoints in the OpenAPI docs.
4. The `deck_id` query parameter is REQUIRED (using `...` as default) to prevent listing all cards globally.

### Files Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/repositories/card.py` | Modify | Add `count_by_deck()` method |
| `src/schemas/card.py` | Modify | Add `CardListResponse` schema |
| `src/api/v1/cards.py` | Create | New card router with list endpoint |
| `src/api/v1/router.py` | Modify | Register card router |
<!-- SECTION:PLAN:END -->
