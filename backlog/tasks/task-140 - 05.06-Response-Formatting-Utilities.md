---
id: task-140
title: 05.06 Response Formatting Utilities
status: Done
assignee: []
created_date: '2025-12-07 09:33'
updated_date: '2025-12-07 10:39'
labels:
  - backend
  - utilities
  - api
  - task-05
  - pydantic
  - responses
dependencies: []
priority: medium
ordinal: 1000
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
# 05.06 Response Formatting Utilities

## Overview

Create standardized response formatting utilities to ensure consistent API response structures across all endpoints. This task complements the existing error handling middleware by providing success response wrappers and pagination support.

## Current State Analysis

### Existing Components
- **Error Handling Middleware** (`src/middleware/error_handler.py`): Already implements error format with `success: false`, `error.code`, `error.message`, `error.request_id`
- **Validation Utilities** (`src/utils/validation.py`): Has `validate_pagination(page, page_size)` returning `(offset, limit)`
- **Domain Schemas** (`src/schemas/`): Individual response models without wrapper

### Gap Analysis
- No generic success response wrapper (`SuccessResponse[T]`)
- No paginated response wrapper (`PaginatedResponse[T]`)
- No helper functions for creating standardized responses
- Inconsistent response structure between success and error cases

## Target Response Format

```json
// Success Response
{
  "success": true,
  "data": { ... }
}

// Paginated Response
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "page": 1,
    "page_size": 20,
    "total_items": 150,
    "total_pages": 8,
    "has_next": true,
    "has_previous": false
  }
}

// Error Response (already implemented in middleware)
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable message",
    "request_id": "abc12345"
  }
}
```

## Technical Specification

### File: `src/utils/responses.py` (NEW)

```python
"""Standard API response formatting utilities.

Provides consistent response wrappers for all API endpoints:
- SuccessResponse[T]: Wrap successful responses
- PaginatedResponse[T]: Wrap paginated list responses
- ErrorDetail: Error structure (matches middleware format)

Usage:
    from src.utils.responses import (
        SuccessResponse,
        PaginatedResponse,
        create_success_response,
        create_paginated_response,
    )

    # Single item
    return create_success_response(data=user)

    # Paginated list
    return create_paginated_response(
        data=users,
        page=1,
        page_size=20,
        total_items=150,
    )
"""
```

### Response Models

#### 1. PaginationMeta
```python
class PaginationMeta(BaseModel):
    """Pagination metadata for list responses."""
    page: int = Field(..., ge=1, description="Current page number (1-indexed)")
    page_size: int = Field(..., ge=1, le=100, description="Items per page")
    total_items: int = Field(..., ge=0, description="Total number of items")
    total_pages: int = Field(..., ge=0, description="Total number of pages")
    has_next: bool = Field(..., description="Whether more pages exist")
    has_previous: bool = Field(..., description="Whether previous pages exist")
```

#### 2. SuccessResponse[T] (Generic)
```python
T = TypeVar("T")

class SuccessResponse(BaseModel, Generic[T]):
    """Standard success response wrapper."""
    success: Literal[True] = True
    data: T
```

#### 3. PaginatedResponse[T] (Generic)
```python
class PaginatedResponse(BaseModel, Generic[T]):
    """Paginated list response wrapper."""
    success: Literal[True] = True
    data: List[T]
    pagination: PaginationMeta
```

#### 4. ErrorDetail (for documentation/typing)
```python
class ErrorDetail(BaseModel):
    """Error detail structure (matches middleware format)."""
    code: str
    message: str
    request_id: str
    debug: Optional[dict] = None  # Only in debug mode

class ErrorResponse(BaseModel):
    """Standard error response (for OpenAPI documentation)."""
    success: Literal[False] = False
    error: ErrorDetail
```

### Helper Functions

#### 1. create_success_response
```python
def create_success_response(data: T) -> dict:
    """Create a success response dictionary.

    Args:
        data: The response data (will be serialized by FastAPI)

    Returns:
        Dictionary with success=True and data field
    """
    return {"success": True, "data": data}
```

#### 2. create_paginated_response
```python
def create_paginated_response(
    data: List[T],
    page: int,
    page_size: int,
    total_items: int,
) -> dict:
    """Create a paginated response dictionary.

    Args:
        data: List of items for current page
        page: Current page number (1-indexed)
        page_size: Number of items per page
        total_items: Total count of all items

    Returns:
        Dictionary with success, data, and pagination fields
    """
    total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
    return {
        "success": True,
        "data": data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total_items": total_items,
            "total_pages": total_pages,
            "has_next": page < total_pages,
            "has_previous": page > 1,
        }
    }
```

#### 3. create_error_response (for manual use)
```python
def create_error_response(
    code: str,
    message: str,
    request_id: str = "unknown",
    debug: Optional[dict] = None,
) -> dict:
    """Create an error response dictionary.

    Note: Prefer using exceptions + middleware for error handling.
    This function is for edge cases requiring manual error responses.

    Args:
        code: Error code (e.g., "VALIDATION_ERROR")
        message: Human-readable error message
        request_id: Request correlation ID
        debug: Optional debug information (only included if provided)

    Returns:
        Dictionary matching error middleware format
    """
    error = {"code": code, "message": message, "request_id": request_id}
    if debug:
        error["debug"] = debug
    return {"success": False, "error": error}
```

## Integration Points

### Update `src/utils/__init__.py`
Export new utilities:
```python
from src.utils.responses import (
    SuccessResponse,
    PaginatedResponse,
    PaginationMeta,
    ErrorResponse,
    ErrorDetail,
    create_success_response,
    create_paginated_response,
    create_error_response,
)
```

### Update `src/utils/validation.py`
Add pagination metadata calculation:
```python
def calculate_pagination_meta(
    page: int,
    page_size: int,
    total_items: int,
) -> dict:
    """Calculate pagination metadata from query parameters."""
    total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
    return {
        "page": page,
        "page_size": page_size,
        "total_items": total_items,
        "total_pages": total_pages,
        "has_next": page < total_pages,
        "has_previous": page > 1,
    }
```

## Testing Requirements

### File: `tests/unit/test_responses.py` (NEW)

1. **SuccessResponse Tests**
   - Test wrapping dict data
   - Test wrapping Pydantic model
   - Test wrapping list
   - Test serialization

2. **PaginatedResponse Tests**
   - Test first page (has_previous=False)
   - Test last page (has_next=False)
   - Test middle page (both True)
   - Test empty results
   - Test single page
   - Test total_pages calculation

3. **Helper Function Tests**
   - Test create_success_response output format
   - Test create_paginated_response calculations
   - Test create_error_response format

4. **Edge Cases**
   - Zero total_items
   - page_size = 1
   - Large page numbers
   - Boundary conditions

## Dependencies

- **Requires**: Python 3.11+, Pydantic v2
- **No external dependencies**
- **Depends on**: Task 05.03 (Error Handling Middleware) - already completed

## Non-Goals (Out of Scope)

- Retrofitting existing endpoints to use wrappers (separate task)
- Modifying error middleware (already complete)
- OpenAPI/Swagger customization
- Response compression
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [x] #1 Create `src/utils/responses.py` with SuccessResponse, PaginatedResponse, PaginationMeta, ErrorResponse, ErrorDetail models
- [x] #2 Implement `create_success_response(data)` helper function
- [x] #3 Implement `create_paginated_response(data, page, page_size, total_items)` helper function
- [x] #4 Implement `create_error_response(code, message, request_id, debug)` helper function
- [x] #5 Add `calculate_pagination_meta()` to `src/utils/validation.py`
- [x] #6 Export all new utilities from `src/utils/__init__.py`
- [x] #7 Create comprehensive unit tests in `tests/unit/test_responses.py`
- [x] #8 All tests pass with `poetry run pytest tests/unit/test_responses.py -v`
- [x] #9 Generic types work correctly with type checkers (mypy)
- [x] #10 Response format matches architecture document specification
<!-- AC:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
## Implementation Plan for 05.06 Response Formatting Utilities

### Prerequisites

Before starting implementation, verify:
- [ ] Backend project compiles without errors: `cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.utils.validation import validate_pagination; print('OK')"`
- [ ] Existing tests pass: `/Users/samosipov/.local/bin/poetry run pytest tests/unit/utils/test_validation.py -v`
- [ ] Python 3.11+ and Pydantic v2 are available
- [ ] Understand existing patterns in `src/utils/validation.py` and `src/middleware/error_handler.py`

---

### Step 1: Create `src/utils/responses.py` with Core Models

**Goal**: Create the new responses module with all Pydantic models for standardized API responses.

**Actions**:
1. Create new file `src/utils/responses.py`
2. Add module docstring explaining the utilities (follow pattern from `validation.py`)
3. Import required types: `from typing import TypeVar, Generic, List, Literal, Optional` and `from pydantic import BaseModel, Field, ConfigDict`
4. Implement `PaginationMeta` model with fields:
   - `page: int = Field(..., ge=1, description="Current page number (1-indexed)")`
   - `page_size: int = Field(..., ge=1, le=100, description="Items per page")`
   - `total_items: int = Field(..., ge=0, description="Total number of items")`
   - `total_pages: int = Field(..., ge=0, description="Total number of pages")`
   - `has_next: bool = Field(..., description="Whether more pages exist")`
   - `has_previous: bool = Field(..., description="Whether previous pages exist")`
5. Create generic type variable: `T = TypeVar("T")`
6. Implement `SuccessResponse[T]` generic model:
   - `success: Literal[True] = True`
   - `data: T`
7. Implement `PaginatedResponse[T]` generic model:
   - `success: Literal[True] = True`
   - `data: List[T]`
   - `pagination: PaginationMeta`

**Files to create**:
- `src/utils/responses.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.utils.responses import PaginationMeta, SuccessResponse, PaginatedResponse; print('Models imported successfully')"
```

---

### Step 2: Add Error Models for OpenAPI Documentation

**Goal**: Add error-related models that match the error handling middleware format for OpenAPI documentation.

**Actions**:
1. In `src/utils/responses.py`, add `ErrorDetail` model:
   - `code: str`
   - `message: str`
   - `request_id: str`
   - `debug: Optional[dict] = None`  (only in debug mode)
2. Add `ErrorResponse` model:
   - `success: Literal[False] = False`
   - `error: ErrorDetail`
3. Ensure these models match the format in `src/middleware/error_handler.py` (lines 148-165)

**Files to modify**:
- `src/utils/responses.py`

**Verification**: Ensure ErrorResponse structure matches middleware output format.

---

### Step 3: Implement Helper Functions

**Goal**: Create helper functions for creating standardized responses.

**Actions**:
1. Implement `create_success_response(data: T) -> dict`:
   ```python
   def create_success_response(data: T) -> dict:
       """Create a success response dictionary."""
       return {"success": True, "data": data}
   ```

2. Implement `create_paginated_response(data, page, page_size, total_items) -> dict`:
   ```python
   def create_paginated_response(
       data: List[T],
       page: int,
       page_size: int,
       total_items: int,
   ) -> dict:
       """Create a paginated response dictionary."""
       total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
       return {
           "success": True,
           "data": data,
           "pagination": {
               "page": page,
               "page_size": page_size,
               "total_items": total_items,
               "total_pages": total_pages,
               "has_next": page < total_pages,
               "has_previous": page > 1,
           }
       }
   ```

3. Implement `create_error_response(code, message, request_id, debug) -> dict`:
   ```python
   def create_error_response(
       code: str,
       message: str,
       request_id: str = "unknown",
       debug: Optional[dict] = None,
   ) -> dict:
       """Create an error response dictionary."""
       error = {"code": code, "message": message, "request_id": request_id}
       if debug:
           error["debug"] = debug
       return {"success": False, "error": error}
   ```

**Files to modify**:
- `src/utils/responses.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.utils.responses import create_success_response, create_paginated_response, create_error_response; print(create_success_response({'id': 1})); print(create_paginated_response([1,2,3], 1, 10, 25))"
```

---

### Step 4: Add `calculate_pagination_meta` to `src/utils/validation.py`

**Goal**: Add a function to calculate pagination metadata from query parameters.

**Actions**:
1. Open `src/utils/validation.py`
2. Add the function after `validate_pagination()` (around line 110):
   ```python
   def calculate_pagination_meta(
       page: int,
       page_size: int,
       total_items: int,
   ) -> dict:
       """Calculate pagination metadata from query parameters.

       Args:
           page: Current page number (1-indexed).
           page_size: Number of items per page.
           total_items: Total count of all items.

       Returns:
           Dictionary with pagination metadata fields.

       Examples:
           >>> calculate_pagination_meta(page=1, page_size=20, total_items=150)
           {
               "page": 1,
               "page_size": 20,
               "total_items": 150,
               "total_pages": 8,
               "has_next": True,
               "has_previous": False,
           }
       """
       total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
       return {
           "page": page,
           "page_size": page_size,
           "total_items": total_items,
           "total_pages": total_pages,
           "has_next": page < total_pages,
           "has_previous": page > 1,
       }
   ```

**Files to modify**:
- `src/utils/validation.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.utils.validation import calculate_pagination_meta; print(calculate_pagination_meta(1, 20, 150))"
```

---

### Step 5: Update `src/utils/__init__.py` Exports

**Goal**: Export all new utilities from the utils package.

**Actions**:
1. Open `src/utils/__init__.py`
2. Add imports from `responses` module:
   ```python
   from src.utils.responses import (
       SuccessResponse,
       PaginatedResponse,
       PaginationMeta,
       ErrorResponse,
       ErrorDetail,
       create_success_response,
       create_paginated_response,
       create_error_response,
   )
   ```
3. Add `calculate_pagination_meta` to imports from `validation`:
   ```python
   from src.utils.validation import (
       EMAIL_REGEX,
       UUID_REGEX,
       sanitize_search_query,
       validate_pagination,
       calculate_pagination_meta,
   )
   ```
4. Update `__all__` list to include all new exports

**Files to modify**:
- `src/utils/__init__.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run python -c "from src.utils import SuccessResponse, PaginatedResponse, create_success_response, calculate_pagination_meta; print('All exports working')"
```

---

### Step 6: Create Unit Tests in `tests/unit/utils/test_responses.py`

**Goal**: Create comprehensive unit tests following the patterns in `test_validation.py`.

**Actions**:
1. Create new file `tests/unit/utils/test_responses.py`
2. Add module docstring describing test coverage
3. Create test classes following the pattern from `test_validation.py`:

**Test Classes to Implement**:

```python
class TestPaginationMeta:
    """Tests for PaginationMeta model."""
    # Test valid construction
    # Test field validation (ge, le constraints)
    # Test model serialization

class TestSuccessResponse:
    """Tests for SuccessResponse generic model."""
    # Test wrapping dict data
    # Test wrapping Pydantic model
    # Test wrapping list
    # Test success is always True
    # Test serialization with model_dump()

class TestPaginatedResponse:
    """Tests for PaginatedResponse generic model."""
    # Test wrapping list data
    # Test pagination field is PaginationMeta
    # Test success is always True
    # Test serialization

class TestErrorDetail:
    """Tests for ErrorDetail model."""
    # Test required fields
    # Test optional debug field

class TestErrorResponse:
    """Tests for ErrorResponse model."""
    # Test success is always False
    # Test error field is ErrorDetail

class TestCreateSuccessResponse:
    """Tests for create_success_response helper function."""
    # Test output format
    # Test with dict data
    # Test with list data
    # Test with None data
    # Test success field is True

class TestCreatePaginatedResponse:
    """Tests for create_paginated_response helper function."""
    # Test first page (has_previous=False)
    # Test last page (has_next=False)
    # Test middle page (both True)
    # Test empty results (total_items=0)
    # Test single page (total_items <= page_size)
    # Test total_pages calculation: (total + page_size - 1) // page_size
    # Test edge case: page_size = 1
    # Test edge case: large page numbers

class TestCreateErrorResponse:
    """Tests for create_error_response helper function."""
    # Test output format
    # Test required fields
    # Test optional debug field included when provided
    # Test debug field excluded when None
    # Test default request_id is "unknown"
```

**Files to create**:
- `tests/unit/utils/test_responses.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/utils/test_responses.py -v
```

---

### Step 7: Add Tests for `calculate_pagination_meta` to `test_validation.py`

**Goal**: Add unit tests for the new `calculate_pagination_meta` function.

**Actions**:
1. Open `tests/unit/utils/test_validation.py`
2. Add new test class `TestCalculatePaginationMeta`:
   ```python
   class TestCalculatePaginationMeta:
       """Tests for calculate_pagination_meta function."""

       def test_first_page_calculation(self):
           result = calculate_pagination_meta(page=1, page_size=20, total_items=150)
           assert result["page"] == 1
           assert result["page_size"] == 20
           assert result["total_items"] == 150
           assert result["total_pages"] == 8  # ceil(150/20)
           assert result["has_next"] is True
           assert result["has_previous"] is False

       def test_middle_page(self):
           result = calculate_pagination_meta(page=4, page_size=20, total_items=150)
           assert result["has_next"] is True
           assert result["has_previous"] is True

       def test_last_page(self):
           result = calculate_pagination_meta(page=8, page_size=20, total_items=150)
           assert result["has_next"] is False
           assert result["has_previous"] is True

       def test_empty_results(self):
           result = calculate_pagination_meta(page=1, page_size=20, total_items=0)
           assert result["total_pages"] == 0
           assert result["has_next"] is False
           assert result["has_previous"] is False

       def test_single_page(self):
           result = calculate_pagination_meta(page=1, page_size=20, total_items=15)
           assert result["total_pages"] == 1
           assert result["has_next"] is False
           assert result["has_previous"] is False

       def test_exact_page_boundary(self):
           result = calculate_pagination_meta(page=1, page_size=20, total_items=40)
           assert result["total_pages"] == 2
   ```
3. Add import: `from src.utils.validation import calculate_pagination_meta`

**Files to modify**:
- `tests/unit/utils/test_validation.py`

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/utils/test_validation.py::TestCalculatePaginationMeta -v
```

---

### Step 8: Run Type Checking with MyPy

**Goal**: Ensure generic types work correctly with type checkers.

**Actions**:
1. Run mypy on the new module:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run mypy src/utils/responses.py
   ```
2. Fix any type errors reported
3. Ensure Generic[T] types resolve correctly

**Verification**:
```bash
cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run mypy src/utils/responses.py --ignore-missing-imports
```

---

### Step 9: Final Verification

**Goal**: Ensure all acceptance criteria are met.

**Actions**:
1. Run all tests:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest tests/unit/utils/ -v
   ```
2. Run full test suite to ensure no regressions:
   ```bash
   cd /Users/samosipov/Downloads/learn-greek-easy/learn-greek-easy-backend && /Users/samosipov/.local/bin/poetry run pytest -n auto
   ```
3. Verify response format matches architecture document specification

**Acceptance Criteria Checklist**:
- [ ] `src/utils/responses.py` created with all models (AC #1)
- [ ] `create_success_response()` implemented (AC #2)
- [ ] `create_paginated_response()` implemented (AC #3)
- [ ] `create_error_response()` implemented (AC #4)
- [ ] `calculate_pagination_meta()` added to validation.py (AC #5)
- [ ] All exports in `src/utils/__init__.py` (AC #6)
- [ ] Unit tests in `tests/unit/utils/test_responses.py` (AC #7)
- [ ] All tests pass (AC #8)
- [ ] MyPy type checking passes (AC #9)
- [ ] Response format matches specification (AC #10)

---

### Estimated Effort

- **Total steps**: 9
- **Complexity**: Medium
- **Estimated time**: 2-3 hours
- **Dependencies**: None (Task 05.03 Error Handling Middleware already complete)

### Key File Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/utils/responses.py` | CREATE | Core response models and helper functions |
| `src/utils/validation.py` | MODIFY | Add `calculate_pagination_meta()` function |
| `src/utils/__init__.py` | MODIFY | Export new utilities |
| `tests/unit/utils/test_responses.py` | CREATE | Unit tests for responses module |
| `tests/unit/utils/test_validation.py` | MODIFY | Add tests for `calculate_pagination_meta()` |

### Code Style Notes

- Follow existing docstring patterns from `validation.py` (Google-style docstrings)
- Use type hints consistently (follow Pydantic v2 patterns from `src/schemas/user.py`)
- Use class-based tests with descriptive docstrings (follow `test_validation.py` pattern)
- Use `@pytest.mark.parametrize` for testing multiple inputs where appropriate
<!-- SECTION:PLAN:END -->

## Implementation Notes

<!-- SECTION:NOTES:BEGIN -->
## Implementation Notes (2025-12-07)

### Files Created
- `src/utils/responses.py` - Core response formatting utilities with models and helper functions
- `tests/unit/utils/test_responses.py` - Comprehensive unit tests (61 tests)

### Files Modified
- `src/utils/validation.py` - Added `calculate_pagination_meta()` function
- `src/utils/__init__.py` - Updated exports to include all new utilities
- `tests/unit/utils/test_validation.py` - Added tests for `calculate_pagination_meta()` (12 tests)

### Implementation Summary
1. Created `PaginationMeta` model with field validation (page >= 1, page_size 1-100, total_items >= 0)
2. Created `SuccessResponse[T]` generic model for single-item responses
3. Created `PaginatedResponse[T]` generic model for paginated list responses
4. Created `ErrorDetail` and `ErrorResponse` models matching middleware format
5. Implemented three helper functions:
   - `create_success_response(data)` - Returns dict with success=True
   - `create_paginated_response(data, page, page_size, total_items)` - Returns dict with pagination metadata
   - `create_error_response(code, message, request_id, debug)` - Returns error dict matching middleware
6. Added `calculate_pagination_meta()` to validation.py for reusable pagination calculation

### Verification
- All 132 unit tests in tests/unit/utils/ pass
- All 772 tests in full suite pass
- MyPy type checking passes with no errors
- Generic types work correctly (verified with type checker)
- Response format matches architecture specification

## PR Created

PR #15: https://github.com/SimonOsipov/learn-greek-easy/pull/15

Awaiting QA verification.

## QA Verification Report (2025-12-07)

### Summary
- **Status**: PASSED - All acceptance criteria verified
- **Tests**: 132 tests pass (61 in test_responses.py + 12 in test_validation.py for calculate_pagination_meta + existing)
- **Type Checking**: MyPy passes with no issues

### Verification Checklist

| # | Acceptance Criterion | Status | Verification Details |
|---|---------------------|--------|---------------------|
| 1 | `src/utils/responses.py` with all 5 models | PASS | File exists with SuccessResponse, PaginatedResponse, PaginationMeta, ErrorResponse, ErrorDetail |
| 2 | `create_success_response(data)` function | PASS | Implemented at line 227-253, returns `{success: True, data: <data>}` |
| 3 | `create_paginated_response(data, page, page_size, total_items)` function | PASS | Implemented at line 256-332, calculates total_pages, has_next, has_previous |
| 4 | `create_error_response(code, message, request_id, debug)` function | PASS | Implemented at line 335-410, matches middleware format |
| 5 | `calculate_pagination_meta()` in `src/utils/validation.py` | PASS | Added at line 113-180, calculates pagination metadata |
| 6 | All utilities exported from `src/utils/__init__.py` | PASS | All 12 exports verified in __all__ list |
| 7 | Unit tests in `tests/unit/utils/test_responses.py` | PASS | 61 tests covering all models and helper functions |
| 8 | Tests pass with pytest | PASS | All 132 tests pass in tests/unit/utils/ |
| 9 | MyPy type checking passes | PASS | `mypy src/utils/responses.py --ignore-missing-imports` - no issues |
| 10 | Response format matches architecture spec | PASS | Verified output matches doc-23 specification exactly |

### Response Format Verification

Success Response:
```json
{"success": true, "data": {...}}
```

Paginated Response:
```json
{"success": true, "data": [...], "pagination": {"page": 1, "page_size": 20, "total_items": 150, "total_pages": 8, "has_next": true, "has_previous": false}}
```

Error Response:
```json
{"success": false, "error": {"code": "ERROR_CODE", "message": "Human-readable message", "request_id": "abc12345"}}
```

All formats match the architecture document (doc-23) specification.

### Files Verified
- `/learn-greek-easy-backend/src/utils/responses.py` (411 lines)
- `/learn-greek-easy-backend/src/utils/validation.py` (244 lines)
- `/learn-greek-easy-backend/src/utils/__init__.py` (44 lines)
- `/learn-greek-easy-backend/tests/unit/utils/test_responses.py` (627 lines)
- `/learn-greek-easy-backend/tests/unit/utils/test_validation.py` (updated with 12 new tests)

### QA Agent: APPROVED
<!-- SECTION:NOTES:END -->
