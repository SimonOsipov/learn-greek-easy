---
id: task-140
title: 05.06 Response Formatting Utilities
status: To Do
assignee: []
created_date: '2025-12-07 09:33'
updated_date: '2025-12-07 10:18'
labels:
  - backend
  - utilities
  - api
  - task-05
  - pydantic
  - responses
dependencies: []
priority: medium
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
# 05.06 Response Formatting Utilities

## Overview

Create standardized response formatting utilities to ensure consistent API response structures across all endpoints. This task complements the existing error handling middleware by providing success response wrappers and pagination support.

## Current State Analysis

### Existing Components
- **Error Handling Middleware** (`src/middleware/error_handler.py`): Already implements error format with `success: false`, `error.code`, `error.message`, `error.request_id`
- **Validation Utilities** (`src/utils/validation.py`): Has `validate_pagination(page, page_size)` returning `(offset, limit)`
- **Domain Schemas** (`src/schemas/`): Individual response models without wrapper

### Gap Analysis
- No generic success response wrapper (`SuccessResponse[T]`)
- No paginated response wrapper (`PaginatedResponse[T]`)
- No helper functions for creating standardized responses
- Inconsistent response structure between success and error cases

## Target Response Format

```json
// Success Response
{
  "success": true,
  "data": { ... }
}

// Paginated Response
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "page": 1,
    "page_size": 20,
    "total_items": 150,
    "total_pages": 8,
    "has_next": true,
    "has_previous": false
  }
}

// Error Response (already implemented in middleware)
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable message",
    "request_id": "abc12345"
  }
}
```

## Technical Specification

### File: `src/utils/responses.py` (NEW)

```python
"""Standard API response formatting utilities.

Provides consistent response wrappers for all API endpoints:
- SuccessResponse[T]: Wrap successful responses
- PaginatedResponse[T]: Wrap paginated list responses
- ErrorDetail: Error structure (matches middleware format)

Usage:
    from src.utils.responses import (
        SuccessResponse,
        PaginatedResponse,
        create_success_response,
        create_paginated_response,
    )

    # Single item
    return create_success_response(data=user)

    # Paginated list
    return create_paginated_response(
        data=users,
        page=1,
        page_size=20,
        total_items=150,
    )
"""
```

### Response Models

#### 1. PaginationMeta
```python
class PaginationMeta(BaseModel):
    """Pagination metadata for list responses."""
    page: int = Field(..., ge=1, description="Current page number (1-indexed)")
    page_size: int = Field(..., ge=1, le=100, description="Items per page")
    total_items: int = Field(..., ge=0, description="Total number of items")
    total_pages: int = Field(..., ge=0, description="Total number of pages")
    has_next: bool = Field(..., description="Whether more pages exist")
    has_previous: bool = Field(..., description="Whether previous pages exist")
```

#### 2. SuccessResponse[T] (Generic)
```python
T = TypeVar("T")

class SuccessResponse(BaseModel, Generic[T]):
    """Standard success response wrapper."""
    success: Literal[True] = True
    data: T
```

#### 3. PaginatedResponse[T] (Generic)
```python
class PaginatedResponse(BaseModel, Generic[T]):
    """Paginated list response wrapper."""
    success: Literal[True] = True
    data: List[T]
    pagination: PaginationMeta
```

#### 4. ErrorDetail (for documentation/typing)
```python
class ErrorDetail(BaseModel):
    """Error detail structure (matches middleware format)."""
    code: str
    message: str
    request_id: str
    debug: Optional[dict] = None  # Only in debug mode

class ErrorResponse(BaseModel):
    """Standard error response (for OpenAPI documentation)."""
    success: Literal[False] = False
    error: ErrorDetail
```

### Helper Functions

#### 1. create_success_response
```python
def create_success_response(data: T) -> dict:
    """Create a success response dictionary.

    Args:
        data: The response data (will be serialized by FastAPI)

    Returns:
        Dictionary with success=True and data field
    """
    return {"success": True, "data": data}
```

#### 2. create_paginated_response
```python
def create_paginated_response(
    data: List[T],
    page: int,
    page_size: int,
    total_items: int,
) -> dict:
    """Create a paginated response dictionary.

    Args:
        data: List of items for current page
        page: Current page number (1-indexed)
        page_size: Number of items per page
        total_items: Total count of all items

    Returns:
        Dictionary with success, data, and pagination fields
    """
    total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
    return {
        "success": True,
        "data": data,
        "pagination": {
            "page": page,
            "page_size": page_size,
            "total_items": total_items,
            "total_pages": total_pages,
            "has_next": page < total_pages,
            "has_previous": page > 1,
        }
    }
```

#### 3. create_error_response (for manual use)
```python
def create_error_response(
    code: str,
    message: str,
    request_id: str = "unknown",
    debug: Optional[dict] = None,
) -> dict:
    """Create an error response dictionary.

    Note: Prefer using exceptions + middleware for error handling.
    This function is for edge cases requiring manual error responses.

    Args:
        code: Error code (e.g., "VALIDATION_ERROR")
        message: Human-readable error message
        request_id: Request correlation ID
        debug: Optional debug information (only included if provided)

    Returns:
        Dictionary matching error middleware format
    """
    error = {"code": code, "message": message, "request_id": request_id}
    if debug:
        error["debug"] = debug
    return {"success": False, "error": error}
```

## Integration Points

### Update `src/utils/__init__.py`
Export new utilities:
```python
from src.utils.responses import (
    SuccessResponse,
    PaginatedResponse,
    PaginationMeta,
    ErrorResponse,
    ErrorDetail,
    create_success_response,
    create_paginated_response,
    create_error_response,
)
```

### Update `src/utils/validation.py`
Add pagination metadata calculation:
```python
def calculate_pagination_meta(
    page: int,
    page_size: int,
    total_items: int,
) -> dict:
    """Calculate pagination metadata from query parameters."""
    total_pages = (total_items + page_size - 1) // page_size if page_size > 0 else 0
    return {
        "page": page,
        "page_size": page_size,
        "total_items": total_items,
        "total_pages": total_pages,
        "has_next": page < total_pages,
        "has_previous": page > 1,
    }
```

## Testing Requirements

### File: `tests/unit/test_responses.py` (NEW)

1. **SuccessResponse Tests**
   - Test wrapping dict data
   - Test wrapping Pydantic model
   - Test wrapping list
   - Test serialization

2. **PaginatedResponse Tests**
   - Test first page (has_previous=False)
   - Test last page (has_next=False)
   - Test middle page (both True)
   - Test empty results
   - Test single page
   - Test total_pages calculation

3. **Helper Function Tests**
   - Test create_success_response output format
   - Test create_paginated_response calculations
   - Test create_error_response format

4. **Edge Cases**
   - Zero total_items
   - page_size = 1
   - Large page numbers
   - Boundary conditions

## Dependencies

- **Requires**: Python 3.11+, Pydantic v2
- **No external dependencies**
- **Depends on**: Task 05.03 (Error Handling Middleware) - already completed

## Non-Goals (Out of Scope)

- Retrofitting existing endpoints to use wrappers (separate task)
- Modifying error middleware (already complete)
- OpenAPI/Swagger customization
- Response compression
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [ ] #1 Create `src/utils/responses.py` with SuccessResponse, PaginatedResponse, PaginationMeta, ErrorResponse, ErrorDetail models
- [ ] #2 Implement `create_success_response(data)` helper function
- [ ] #3 Implement `create_paginated_response(data, page, page_size, total_items)` helper function
- [ ] #4 Implement `create_error_response(code, message, request_id, debug)` helper function
- [ ] #5 Add `calculate_pagination_meta()` to `src/utils/validation.py`
- [ ] #6 Export all new utilities from `src/utils/__init__.py`
- [ ] #7 Create comprehensive unit tests in `tests/unit/test_responses.py`
- [ ] #8 All tests pass with `poetry run pytest tests/unit/test_responses.py -v`
- [ ] #9 Generic types work correctly with type checkers (mypy)
- [ ] #10 Response format matches architecture document specification
<!-- AC:END -->
